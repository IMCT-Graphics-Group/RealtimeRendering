## 读书笔记: Real-time Rendering 4th Edition

### 0. 笔记前言

很难想象，我本来应该是看 Pbrt 并且深耕光线追踪的，但我却突发奇想决定先过一遍 rtr，但仔细梳理逻辑又并不是没有根据的：Pbrt-v4 出版在即，新版本引入了对 Optix 的支持，令我神往，所以先暂缓对 Pbrt 的学习；rtr 更像一本算法目录，提供了大量有关光栅化、实时光追的内容，而我的研究内容是关于实时 Pt 的，也许可以通过 rtr 打开思路；最后一点大概就是对于工程的懈怠吧，我暂时觉得自己还没有做好为学习 Pbrt 做大量工程实践的准备，在这个还不算忙碌的研一下学期，抓住最后一点自由的时间，好好地享受阅读 rtr 的快乐吧~

### 1. 图形渲染管线

管线（或称为流水线），是一种有效提高生产效率的方式。通过将生产全流程拆解成$n$个不同的管线阶段，可以将生产速度提升$n$倍。但管线的生产效率受制于其最慢的管线阶段（木桶效应）。宏观上，渲染管线可以分成四个阶段：应用阶段 → 几何处理阶段 → 光栅化阶段 → 像素处理阶段。实际使用中，每一个阶段的内部又可以继续细分成更多的阶段。

- **应用阶段**：应用阶段由具体的应用驱动，通常表现为由 CPU 端执行的渲染前准备和渲染调度任务。由于应用阶段在 CPU 端执行，所以开发者具有完全的控制权，应用阶段的处理也会很大程度上影响后续阶段的执行，比如优化算法来减少需要绘制的三角形数量。应用阶段的一些工作也可以通过`Compute Shader`交给 GPU 处理。应用阶段最终会将需要绘制的几何信息传递给下一个阶段，这些几何信息通常描述了一些基础的图形元素，比如点、线、三角形。另外，碰撞检测、交互设备（鼠标、键盘、手柄、头显等）的信息处理也都在该阶段进行。

- **几何处理阶段**：几何处理阶段主要负责坐标变换、投射等与几何处理相关的任务。这个阶段会计算出哪些内容需要被绘制、应当怎样绘制，以及绘制到哪里。几何处理阶段一般在 GPU 上执行。几何处理阶段执行逐三角形和逐顶点的处理操作，这个阶段具体分为四个阶段：
  
  1. **顶点着色**：顶点着色阶段有两个主要任务：计算出顶点的位置、顶点输出数据（法线、纹理坐标等）。经典的物体着色都是在顶点上计算光照并存储颜色，然后在三角形中插值。这类可编程的顶点着色单元被称为顶点着色器。随着 GPU 硬件的发展，物体着色基本从顶点着色转换为像素着色，而原先的顶点着色器则被用作一个通用的处理阶段，用于计算各顶点的数据。顶点数据处理包含多次坐标系变换：顶点最初位于所属模型的`模型空间`，每个模型可以生成多个实例副本，每个实例都含有一个`模型变换（矩阵）`，描述了模型的缩放、位置和朝向，`模型变换（矩阵）`作用于模型的顶点和法线，变换之前的坐标系为`模型坐标系`，变换之后的坐标系为`世界坐标系`；为了便于相机投影和裁剪，所有处于`世界坐标系`下的物体都会进行`视图变换（矩阵）`，变换后的物体将处于`相机空间`，相机将位于坐标系原点，朝向$z$轴的负方向，$y$轴朝上，$x$轴朝右。除了`坐标变换`输出新的坐标之外，顶点着色还可以对顶点进行`着色`。有的渲染管线中，`着色`计算发生在几何处理阶段（逐顶点着色），有的则发生在像素处理阶段（逐像素着色）。顶点着色输出的着色数据（颜色、向量、纹理坐标等）将传递到光栅化阶段和像素处理阶段，用于插值和计算最终的表面颜色。顶点着色中，渲染管线底层还会先后执行`投影`和`裁剪`，将`视锥体`变换为从(-1,-1,-1)到(1,1,1)的立方体（或者 0~1）。先执行`投影`变换，有`正交投影`和`透视投影`两种投影方式，`正交投影`是一种平行投影，常用于建筑领域，`透视投影`则是模拟人眼观察事物的方式。`视锥体`是将相机张开的角锥体保留近裁切面和远裁切面之内的部分得到的。经过`投影`变换之后，模型将处于`裁剪空间`，`裁剪坐标`是一种齐次坐标。根据齐次坐标缩放（除以$w$）后得到标准设备坐标系下的坐标（$ndc$），最后再将$ndc$坐标转换到窗口坐标。
  
  2. **细分着色（可选）**：为了使靠近的物体呈现更多的几何细节，可以通过细分着色器来生成更多的三角形面片。
  
  3. **几何着色（可选）**：几何着色器的出现早于细分着色器，所以有更多的 GPU 支持。和细分着色器类似，几何着色器也可以生成新的几何顶点。几何着色器可以生成的范围很有限，用得不多。最常见的情况是用于粒子系统：几何着色器将单个点转换为一个朝向相机的四边面，这样就可以方便地着色。
  
  4. **流输出（可选）**：使用流输出可以将处理好的顶点数据输出到一个数组里，用于其他处理，而不是送入渲染管线的后续阶段。流输出常用于粒子模拟。
     
     **关于裁剪**：只有裁剪空间之内的元素需要被送进下一个光栅化阶段。对于完全处于视锥体外的元素，将被直接丢弃；完全处于视锥体内的元素，将被直接送入下一个阶段；只有部分处于视锥体内的元素需要进行裁剪。举例，当一条直线部分地处于视锥体内时，将裁剪掉处于视锥体外的顶点，并用一个新的顶点替代。裁剪空间中的顶点经过齐次除法（透视除法）后，转入$ndc$空间。

- **光栅化阶段**：光栅化阶段负责将顶点组装成三角形，并且找到被各个三角形覆盖的屏幕像素，将这些信息送入下一个处理阶段。光栅化阶段一般在 GPU 上执行。光栅化分成两个子阶段：三角形装配、三角形遍历。虽然以上两个子阶段都被称为“三角形\_xx”，但实际上也对点和线处理。光栅化阶段也被称为“扫描转换”，意味着将屏幕空间的二维坐标顶点转换为屏幕像素。如何判定某个像素被三角形覆盖，取决于开发者对管线的设置。比如单点采样的方法就是检测某个像素的中心是否位于三角形中。也可以使用多点采样方法，比如超级采样或者多重采样。（三角形装配和遍历阶段是固定函数的 GPU 执行阶段）
  
  1. **三角形装配**：这个阶段负责计算三角形各边的表达式以及其他各种数据。这些数据会在三角形遍历阶段中参与插值。
  2. **三角形遍历**：这个阶段会检查像素中心（或采样点）是否被三角形覆盖，然后生成三角形所覆盖的片元。每个三角形片元的属性都是由三角形的顶点插值得到的；透视矫正也发生在这个阶段。

- **像素处理阶段**：像素处理阶段会逐像素地执行一段程序，这段程序将计算出该像素的颜色。这个计算过程也许很复杂：可能会先执行深度测试，确定是否需要被绘制；也可能会执行颜色混合，将当前计算出的颜色和已有颜色混合。像素处理阶段一般在 GPU 上执行。像素处理阶段分为像素着色阶段和合成阶段。
  
  1. **像素着色**：可编程的着色器阶段，最终将一个或多个颜色送入下一阶段。
  2. **合成**：将像素着色阶段输出的颜色合成。也被称为**ROP**（raster operations pipeline）（render output unit）。该阶段虽然不可编程，但是高度可配置。这个阶段也会负责解决可见性问题（Z-Test&Z-Write）。早期的图形 API 中，也会在合成阶段处理 Alpha-Test 来丢弃完全透明的片元；现代的图形 API 则可以在可编程的阶段控制丢弃片元。模板缓冲（stencil buffer）是一个后台缓冲，用于记录各个元素的位置信息（一般是 8bit 每像素）。**模板缓**冲会被用于控制颜色缓冲和深度缓冲。举个例子：一个实心圆被写入了模板缓冲，后续的元素写入就可以依据该模板缓冲，仅写入实心圆所覆盖的区域。**帧缓冲（framebuffer）**是由全部缓冲组成的。

### 2. 图形处理单元

GPU 采用了和 CPU 很不一样的处理方式。GPU 芯片的绝大多数面积都用于放置数千个**shader cores**。GPU 是一种**流处理器**，大量排好序的相似数据将依次执行。正是由于数据的相似性（比如顶点数据集或者像素数据集），GPU 才可以最大程度地并行执行。另一个重要的因素是，GPU 会尽可能地将调度彼此独立，这样就不需要相邻指令的调度信息，也不需要共享内存的写入地址。GPU 对吞吐量（数据的最大处理速率）进行了专门优化，代价是 GPU 上减少了缓存和控制单元的面积，这也使得 GPU 上的延迟比 CPU 更高。使用同一段着色器程序的 GPU 线程会被捆成一组，NVIDIA 称之为**warp**，AMD 称之为**wavefront**。每个 warp/wavefront 会用多个 shader cores 执行，通常是 8~64 个 cores，通过 SIMD 处理技术。举例，有 2000 个线程需要执行，每个 NVIDIA Warp 如果由 32 个线程组成，则需要$2000\div32=62.5$个 warps，也就是实际使用 63 个 warps 执行（其中有一个 warp 半空）这些任务。由于是 SIMD，所以当一个 warp 中有线程遇到需要读取内存的情形时，所有的 32 个线程都是同时遇到的，warp 中的线程会进行换出操作，先执行下一个 warp 的 32 个线程，等待内存读取完毕后再继续执行之前的线程。每个线程都有一个寄存器，用于临时存储执行状态，合适的时候可以恢复之前的执行任务。当然，warp 执行换入换出操作的时机是不一定的，这和优化策略有关，由于换入换出的延迟很低，所以有许多优化技术都会用在 warp 的换入换出上。shader 代码结构也会在很大程度上影响执行效率，如果一段 shader 程序**过度地使用寄存器**，那么分配给每个线程的寄存器就会变多，线程和 warp 的数量就会被迫减少，warp 换出优化就没法使用。GPU 中的 warp 占用率越高，意味着 GPU 的使用越充分，性能表现越好。另一个影响执行效率的重要因素是**动态分支**，主要由 if 语句和循环语句引发。当 shader 程序遇到 if 分支时，如果它们结果相同，走相同的分支，没有任何问题；但只要有一条线程走其他分支，那么整个 warp 都必须把涉及到的分支全部执行一遍，然后丢弃掉错误分支的结果。这类问题被称为**线程发散（thread divergence）**，即只有一小部分线程需要执行其他分支，却导致整个 warp 一起执行（或等待）的情况。

GPU 实现了渲染管线（逻辑模型）中的几何处理、光栅化和像素处理阶段。其中最重要的是四个可编程的阶段：顶点着色、细分着色（可选）、几何着色（可选）和像素着色。现代 GPU 为着色器编程提供了统一的设计，这意味着四个可编程阶段使用相同的编程模型。从本质上来说，它们具有相同的指令集架构（ISA）。DirectX 中称实现了该编程模型的处理核心为“通用着色器处理核心（common-shader core）”，具备这种核心的 GPU 被称为具备“统一着色器架构”。这种设计背后的思路是，着色处理器可以用于许多不同的情形，GPU 可以统一一致地处理。比如，如果一组模型网格中含有大量的小三角形，而另一组大的四边形面片都是由两个三角形组成的，那么前者需要更多的顶点着色处理，后者则主要依赖于像素着色处理；如果区分使用顶点着色处理核心和像素着色处理核心，那么在需求不平衡的情况下，资源就会闲置；而使用统一的着色处理核心就可以由 GPU 平衡处理任务。

DirectX 的 HLSL 可以被编译为中间语言（IL, or DXIL），实现硬件解耦，然后再由 GPU 的驱动器使用相应的 ISA 编译。

基础的数据类型为 32-bit 单精度浮点标量和向量，但向量只是着色器代码的一部分。现代 GPU 一般也会提供 32-bit 整型和 64-bit 浮点类型的支持。浮点向量比较常见的是位置信息(xyzw)、法线信息、矩阵行、颜色信息(rgba)、纹理坐标(uvwq)；整型常被用于计数器、索引、掩码。合成数据类型，比如结构体、数组和矩阵，也都是支持的。

一次 draw call 指令会调用图形 API 进行一组图形元素的绘制，相继地会由图形管线执行其中的 shader。每个可编程的着色阶段都有两种类型的输入数据：统一输入数据，一次 draw call 中不会变化的数据；可变输入数据，由三角形顶点或光栅化产生。举例，像素着色会提供统一的光源数据，而三角形面的位置数据则是可变数据。纹理是一种特殊的统一数据，曾经是一张彩色图片，现在一般会被当做数组数据。

底层的虚拟机会对不同类型的数据提供不同类型的寄存器。统一数据可以获取的常量寄存器数量是远远大于可变数据的，这是由于不同顶点和像素的可变数据需要分开来单独存储，所以在寄存器数量上有着天然的限制。

Shader 的流程控制有两种：静态流程控制是以统一输入数据控制的，这意味着在一次 draw call 中的分支结果不会发生改变；动态流程控制则是以可变输入数据控制的，这意味着每个片元执行的代码可能都是不一样的。

#### 2.1 细分着色器（Tessellation Stage）

细分着色器分为三个部分：外壳着色器（hull shader / tessellation control shader）、细分器（tessellator）和域着色器（domain shader / tessellation evaluation shader）。

输入外壳着色器的是一些图元，这些图元由控制点组成，这些控制点以某种曲线形式（如贝塞尔）定义了细分面。外壳着色器有两个功能，第一个功能是告诉接下来的细分器有多少三角形需要生成，以及它们的相关配置；第二个功能是它可以对每个控制点进行处理，可以修改这些控制点的信息，或者增删控制点。外壳着色器将处理好的控制点和细分控制数据输出到域着色器。

细分器是一个固定函数阶段，仅用于细分着色器中，负责生成新的顶点传递给域着色器。外壳着色器会将细分器需要的信息传递过去，比如细分面的类型（三角面、四边面或者线束）、细分系数（tessellation factor）。细分系数包括两种类型：内边系数、外边系数。内边系数决定了图元内部的细分程度；外边系数决定了图元边缘挤出的分段数。

域着色器有着和顶点着色器类似的数据流模式，将每一个由细分器输入的顶点处理后生成一个相应的输出顶点。域着色器使用重心坐标计算出每个顶点的位置、法线、纹理坐标等各种信息。

#### 2.2 几何着色器（Geometry Shader）

几何着色器可以将图元转换为其他类型的图元，这是细分着色器无法实现的。比如将三角形网格的每天边转换为线段，则网格就可以转变为线框。

几何着色器的输入是一个物体和它的顶点。几何着色器也可以定义和处理扩展图元，实际上，一个三角形可以扩展三个额外顶点，一个线段也可以扩展额外的两个顶点。

几何着色器用于修改输入数据，或者做一些简单的拷贝，它不能生成任何图元。常被用于生成级联阴影、不同尺寸的粒子、为毛发渲染挤出边缘等。

几何着色器保证了输出的图元顺序与输入图元的顺序相同，这也导致几何着色器不适合在一次调用中复制或创建大量的几何体。

一次 draw call 中 GPU 可能产生绘制对象的阶段只有三个：光栅化、细分着色器和几何着色器。其中，几何着色器是最难预测的，很多移动端设备的几何着色器都是软件实现的，所以很少乃至不鼓励使用几何着色器。

#### 2.3 流输出（Stream Output）

流输出可以在光栅化之前将数据输出并存储起来，跳过后续的阶段。常被用于模拟水面流动或者粒子效果等。流输出的数据都是浮点类型，所以对显存有着明显的开销。另外，流输出按照图元存储数据，所以三角形就会在每个顶点存储多个数据，开销比较高；一种常见的处理方法是，将图元都转为点数据进行流输出。送入流输出的图元顺序是不会被改变的。

#### 2.4 像素着色器（Pixel Shader）

受益于 MRT（multiple render targets）技术，一个 rendering pass 可以生成多张图像，比如同时生成颜色图片、ID 图片和世界空间距离图片。MRT 技术也带来了不同类型的渲染管线，比如延迟渲染，第一个 pass 存储物体的位置和材质信息，后续的 pass 对其进行着色。一般来说，像素着色器无法获取到相邻像素的信息，但是有一个间接方法，可以通过获取当前像素和相邻像素的梯度信息（差值）来重建相邻像素的值，但这就要求所有同组的像素着色都使用相同的指令。

DX11 提供了一种可以向任意位置写入信息的缓冲类型，称为 unordered access view(UAV)。最初仅允许像素着色器和计算着色器使用 UAV，在 DX11.1 中更新为所有的可编程着色器都可以使用。该技术在 OpenGL4.3 中出现，称为 shader storage buffer object(SSBO)。GPU 使用专用的原子单元避免数据竞争的情况，但也因此会产生略微的阻塞。DX11.3 提供了 Rasterizer order views(ROVs)来保证执行顺序，这样就可以在像素着色器阶段编写颜色混合的算法而不再需要合成阶段，代价是会产生一些阻塞而牺牲性能。

#### 2.5 合成阶段（Merging Stage）

大部分传统管线中，模板缓冲和深度缓冲的操作都发生在该阶段。当片元可见时，颜色混合也会发生在这个阶段（对于不透明物体来说，没有颜色混合，而是颜色替换）。

但由于深度缓冲在传统流水线中的位置比较靠后，导致了大量无效的计算，所以许多 GPU 会在像素着色器之前进行合成阶段的测试。片元的一些信息（深度）被用于测试可见性，不可见的片元会被提前裁剪掉，这项功能被称为 early-z。像素着色器中是可以对片元的深度信息进行调整的，也可以控制片元是否被丢弃，所以一旦有这些操作，为了防止冲突，early-z 就不会执行，但也会使得管线效率略微下降。

#### 2.6 计算着色器（Compute Shader）

有一些平台是为了实现通用 GPU 计算的，比如 CUDA 和 OpenCL，这类框架一般是使用 C/C++这样的语言并扩展实现一些使用 GPU 的库。

DX11 推出了 compute shader 用于通用的 GPU 计算，这个 shader 并不参与渲染管线的运作。但 compute shader 和渲染结合紧密，因为它由图形 API 调用，它使用和统一着色器相同的计算资源池。由于计算着色器的线程之间可以共享显存，有些操作在计算着色器中可能会更快。

### 3. 变换

从旋转矩阵中提取欧拉角：由于旋转矩阵$\textbf E(h,p,r)=\textbf R_z(r)\textbf R_x(p)\textbf R_y(h)$，将矩阵展开可以得到$e_{21}=sinp,\quad\frac{e_{01}}{e_{11}}=\frac{-sinr}{cosr}=-tanr,\quad\frac{e_{20}}{e_{22}}=\frac{-sinh}{cosh}=-tanh$。从而解出$p,r,h$。但如果$cosp=0$，那么$tanr和tanh$就不能正确求解，这时候可以假定$h=0，然后由\frac{e_{10}}{e_{00}}=\frac{sinr}{cosr}=tanr解出r值$。

变换矩阵行列式的值如果为负数，则该变换包含反射（负缩放）。

绕任意方向的旋转：先将任意方向**r**旋转到 x 轴方向，这需要构建旋转矩阵**M**，也就是找到和**r**相互垂直的向量。一种数值稳定的解法是，找到**r**最小的分量，将其设为 0，交换剩下的两个分量的值，并将其中一个分量值取反。接着通过归一化和叉乘，就可以获得以**r**为轴的正交坐标系，从而建立旋转矩阵**M**。之后就可以将绕**r**旋转的问题转化为绕 x 轴旋转的问题，最后只需要应用$\textbf M^T$将其转回来即可。当然，Goldman 还提出了一种旋转方法，他的变换矩阵可以参考书上 P75。

四元数（P76）：$\hat{\textbf{q}}=(\textbf{q}_v,q_w)=iq_x+jq_y+kq_z+q_w=\textbf{q}_v+q_w=sin\phi\textbf{u}_q+cos\phi$

乘法：$\hat{\textbf{q}}\hat{\textbf{r}}=(\textbf{q}_v\times\textbf{r}_v+r_w\textbf{q}_v+q_w\textbf{r}_v,\quad q_wr_w-\textbf{q}_v\cdot\textbf{r}_v)$

加法：$\hat{\textbf{q}}+\hat{\textbf{r}}=(\textbf{q}_v+\textbf{r}_v,\quad q_w+r_w)$

共轭：$\hat{\textbf{q}}^*=(-\textbf{q}_v,q_w)$

模：$n(\hat{\textbf{q}})=\sqrt{\hat{\textbf{q}}\hat{\textbf{q}}^*}=\sqrt{\textbf{q}_v\cdot\textbf{q}_v+q_w^2}=\sqrt{q_x^2+q_y^2+q_z^2+q_w^2}$

单位量：$\hat{\textbf{i}}=(\textbf{0},1)$

求逆：$\hat{\textbf{q}}^{-1}=\frac{1}{n(\hat{\textbf{q}})^2}\hat{\textbf{q}}^*$

共轭法则：

- $(\hat{\textbf{q}}^*)^*=\hat{\textbf{q}}$
- $(\hat{\textbf{q}}+\hat{\textbf{r}})^*=\hat{\textbf{q}}^*+\hat{\textbf{r}}^*$
- $(\hat{\textbf{q}}\hat{\textbf{r}})^*=\hat{\textbf{r}}^*\hat{\textbf{q}}^*$

模法则：

- $n(\hat{\textbf{q}}^*)=n(\hat{\textbf{q}})$
- $n(\hat{\textbf{q}}\hat{\textbf{r}})=n(\hat{\textbf{q}})n(\hat{\textbf{r}})$

乘法规则：

- 分配律：$\hat{\textbf{p}}(s\hat{\textbf{q}}+t\hat{\textbf{r}})=s\hat{\textbf{p}}\hat{\textbf{q}}+t\hat{\textbf{p}}\hat{\textbf{r}}$
- 结合律：$\hat{\textbf{p}}(\hat{\textbf{q}}\hat{\textbf{r}})=(\hat{\textbf{p}}\hat{\textbf{q}})\hat{\textbf{r}}$
- 四元数乘法不服从交换律

对数运算：$log(\hat{\textbf{q}})=log(e^{\phi\textbf{u}_q})=\phi\textbf{u}_q$

指数运算：$\hat{\textbf{q}}^t=(sin\phi\textbf{u}_q+cos\phi)^t=e^{\phi t\textbf{u}_q}=sin(\phi t)\textbf{u}_q+cos(\phi t)$

将一个四维表示的点或者向量$\textbf{p}=(p_x,p_y,p_z,p_w)^T$视作四元数$\hat{\textbf{p}}$，则另一个单位四元数$\hat{\textbf{q}}=(sin\phi\textbf{u}_q,cos\phi)$可以对其进行四元数乘法$\hat{\textbf{q}}\hat{\textbf{p}}\hat{\textbf{q}}^{-1}$实现绕轴$\textbf{u}_q旋转2\phi$角度。

任何非零实数乘以$\hat{\textbf{q}}$得到的都是相同的变换，这意味着$\hat{\textbf{q}}和-\hat{\textbf{q}}$表示相同的变换，也意味着给旋转轴$\textbf{u}_q$以及实部$q_w$随意地增减负号，并不会影响四元数的旋转变换。

连续使用四元数旋转变换：$\hat{\textbf{r}}(\hat{\textbf{q}}\hat{\textbf{p}}\hat{\textbf{q}}^*)\hat{\textbf{r}}^*=(\hat{\textbf{r}}\hat{\textbf{q}})\hat{\textbf{p}}(\hat{\textbf{r}}\hat{\textbf{q}})^*=\hat{\textbf{c}}\hat{\textbf{p}}\hat{\textbf{c}}^*$

四元数转齐次矩阵：

$\textbf{M}^q=\begin{pmatrix}
&{1-s(q_y^2+q_z^2)} &{s(q_xq_y-q_wq_z)} &{s(q_xq_z+q_wq_y)} &{0}\\&{s(q_xq_y+q_wq_z)} &{1-s(q_x^2+q_z^2)} &{s(q_yq_z-q_wq_x)} &{0}\\&{s(q_xq_z-q_wq_y)} &{s(q_yq_z+q_wq_x)} &{1-s(q_x^2+q_y^2)} &{0}\\&{0} &{0} &{0} &{1}\end{pmatrix}$

其中$s=\frac{2}{(n(\hat{\textbf{q}})^2)}$

从矩阵中提取四元数则可以通过相互消元法得到，最后都和$q_{w}$相关，而$q_{w}$可以通过矩阵的迹得到：$tr(\textbf{M}^q)=4-2s(q_x^2+q_y^2+q_z^2)=4(1-\frac{q_x^2+q_y^2+q_z^2}{q_x^2+q_y^2+q_z^2+q_w^2})=\frac{4q_w^2}{(n(\hat{\textbf{q}}))^2}$

球面线性插值：$\hat{\textbf{s}}(\hat{\textbf{q}},\hat{\textbf{r}},t)=(\hat{\textbf{r}}\hat{\textbf{q}}^{-1})^t\hat{\textbf{q}}$

软件中的球面线性插值：$slerp(\hat{\textbf{q}},\hat{\textbf{r}},t)=\frac{sin(\phi(1-t))}{sin\phi}\hat{\textbf{q}}+\frac{sin(\phi t)}{sin\phi}\hat{\textbf{r}}$

其中，$cos\phi=q_xr_x+q_yr_y+q_zr_z+q_wr_w$

球面线性插值的本质是在一个单位球上构造了从$\hat{\textbf{q}}$（t=0）指向$\hat{\textbf{r}}$（t=1）的最短弧。

已知两个单位方向$\textbf{s}和\textbf{t}$，则实现$\textbf{s}转到\textbf{t}$的旋转四元数$\hat{\textbf{q}}$可以表示为：$\hat{\textbf{q}}=(\textbf{q}_v,q_w)=(\frac{1}{\sqrt{2(1+e)}}(\textbf{s}\times\textbf{t}),\frac{\sqrt{2(1+e)}}{2})$

其中，$e=\textbf{s}\cdot\textbf{t}=cos(2\phi),\quad \|{\textbf{s}\times\textbf{t}}\|=sin(2\phi)$

上述表示法避免了两方向相近时的数值不稳定性，但当两方向相反时，仍然会出现分母为零的情况，遇到这种情况时，任何垂直于两方向的向量都可以作为转轴。

#### 3.2 顶点混合

顶点混合用于解决不同物体的衔接处在发生变换时的过渡问题。衔接处的模型可能会受到来自不同物体变换矩阵的影响。

第一种顶点混合的方法：找到所有会对目标顶点产生影响的骨骼，将它们的变换矩阵按照权重进行混合，得到对顶点的变换矩阵。

第二种顶点混合的方法：找到所有会对目标顶点产生影响的骨骼，对它们的变换矩阵作用于顶点的变换结果进行插值。

权重的和不一定为一，但这种情况一般是出现在使用一些特殊的算法，比如*morph targets*

顶点混合的一个缺点是，混合处可能会产生折叠和穿插。一种解决方案是使用“对偶四元混合（双四元混合）”，平移部分也使用一个四元数表示，这样插值的时候是沿着圆弧插值的。但对偶四元混合也会引起膨胀问题，所以还有一种“旋转中心蒙皮法”可以选择。

#### 3.3 变形

模型的变形方法通常是在一个中性模型的基础上，根据权重叠加其与不同模型之间的差值得到的。

#### 3.4 几何缓存回放

对于高质量模型的变形动画，需要缓存每一帧的顶点位置，但这对硬盘读写的要求很高，通常会采用一些优化方案。首先是对数据进行压缩，通过 16-bit 的整型来存储位置和纹理坐标，会产生压缩损失；其次可以通过对时间、空间重新编码来压缩数据，仅存储它们的差值。

#### 3.5 投影

- 正交投影：最简单的正交投影可以直接把 z 分量设为零，但一般来说，在正交投影中希望约束投影的范围。更常见的正交投影通常由六个分量描述（$l,r,b,t,n,f$）分别代表左、右、底、顶、近、远，六个平面。
- 投影矩阵将约束空间压缩成一个轴对齐的方盒，在 OpenGL 中，这个方盒的坐标是从(-1,-1,-1)到(1,1,1)；在 DirectX 中则是从(-1,-1,0)到(1,1,1)。这个方盒被称为*canonical view volume*（标准视体），其中的物体坐标被称为*normalized device coordinates*（归一化设备坐标）。使用标准视体可以使裁剪变得更容易和高效。
- 透视投影相对复杂很多，需要考虑深度的存储和矫正。

### 4. 着色

*Punctual Lights*为“点”光源（词源为拉丁语“punctus”），是指光源本身没有大小和形状，但是有一个特定的位置。“点光源”和“聚光灯源”都属于“点”光源。(point and spotlight are two different forms of punctual lights)

光照衰减的平方反比虽然很简单也很正确，但在实际使用中却有很多问题，比如当距离无限接近零时，会出现“除以零”的情况；所以一般在使用的时候，会加一个小的固定偏差值$\epsilon$，虚幻引擎使用$\epsilon=1 cm$；CryEngine 和 Frostbite Game Engine 中使用的方法是使用$r=max(r,r_{min})$。相比于虚幻引擎的$\epsilon$可以任取，CryEngine 采用的钳制方法有其物理意义，小于$r_{min}$的表面点意味着它穿插进了光源体的内部，这是不可能的。另一个问题是希望当光照衰减达到一定程度的时候，可以直接裁剪掉，减少性能开销；不同的引擎给出了不同的解决方案，基本都是修正出了一个光照衰减的曲线，达到某一距离时会衰减到零。

在设计着色实现方案时，需要根据**计算频率**划分计算。首先看这个计算结果在一次 draw call 中是否维持不变，如果不变的话可以由应用阶段计算；如果是硬件配置或者设置信息这种很少修改的结果，可以在编译阶段就存储起来，也就不必存到 shader input 中了，或者也可以通过一些离线的预计算 pass，在应用程序的安装和加载阶段运行；另一种情况是修改的结果不需要立即应用起来，就可以把计算摊销到多个帧上；其他的划分还有逐帧的、逐模型的、逐 draw call 的等，根据**计算频率**分组可以有效提高执行效率、帮助 GPU 优化执行策略。

如果计算结果在一次 draw call 中也会发生改变，那么就需要依赖可编程着色器阶段来更新了，各个可编程阶段对应不同的计算频率：

- 顶点着色器：逐（细分前）顶点
- 壳着色器：逐面块
- 域着色器：逐（细分后）顶点
- 几何着色器：逐图元
- 像素着色器：逐像素

实际上，大部分的着色计算都是逐像素的，在像素着色器里执行；其他阶段主要执行一些几何相关的计算，比如变换和变形。

即使在顶点着色器中对向量归一化，在像素着色器中插值时，仍然会产生不符合归一化的插值结果，所以需要再次归一化。另外，如果输入向量没有进行归一化，插值结果很可能不正确。鉴于以上两点因素，在进行插值的前后通常都会对向量进行归一化处理。

通常会在顶点着色器中完成一些几何信息的坐标变换，减少像素着色器中的计算开销。坐标变换的方式需要整体考虑，从性能、灵活性和简便性的角度考虑。比如场景中存在大量光源时，使用世界空间坐标可以避免对光源坐标的变换；相机空间也是常用的坐标空间，在相机空间中运算可以优化有关视线方向的运算，也可以提升一些精度。

**Shader**输入有两种类型，第一种是统一输入，由应用层提供，并且在一次 draw call 中全程保持不变；第二种是可变输入，可以在不同着色器之间有所改变。

**材质**是一个艺术端概念，一种材质可能对应多个 shader，一个 shader 也可能对应多种材质。参数化材质由两部分组成：材质模板和材质实例。有些渲染框架比如虚幻，可以设置更复杂的层级材质结构，即一种材质模板可以派生自其他模板而构成多个层级。

实现着色计算过程，对着色计算进行效率优化，通常有以下几种思路：

- 找到表达式中可以化简的部分
- 区分表达式中具有不同计算频率的部分，并调整其计算时期
- 在交互和跨平台支持中取得平衡，做合适的拆分与封装

**抗锯齿**问题的本质是一个采样问题。对于连续信号，计算机中通过对采样的离散信号重建来还原原本的信号。在离散采样的过程中会产生走样问题，走样是由采样频率低于实际频率引起的，计算机图形中的走样通常呈现为边缘锯齿或者高光闪烁。为了正确地重建连续信号，采样频率必须大于原始频率的二分之一，这被称为“采样定理”（奈奎斯特定理）。

但三维空间中的点采样几乎是无解的，无论采样点之间取多近，总可以存在更小的物体无法被采样到，所以对于使用点采样渲染图像的方法来说，是不可能彻底解决走样问题的。当然，有时也可以知道一些图像的频率带宽，比如对物体表面应用纹理贴图时，可以计算出屏幕像素的采样频率和纹理贴图的采样频率，如果符合奈奎斯特定理，则贴图采样过程不需要额外的处理。

信号重建需要使用滤波器，三种常用的滤波器分别是盒式滤波器（box filter）、帐篷型滤波器（tent filter）、正弦滤波器（sinc filter）；滤波器的面积需要为一，否则会造成重建信号被放大或者缩小。

box filter 重建的信号并不连续，效果很差；tent filter 重建的信号虽然连续，但不平滑，所以需要引入额外的低通滤波器；最理想的低通滤波器是 sinc filter，该结论由傅里叶分析给出，简单来说，频域空间最好的滤波器是 box filter（消除了频率大于滤波器宽度的所有信号），将 box filter 转换到空间域（图像域）时需要使用正弦函数；同时，滤波器在频域的叠加也会变成在空间域的卷积。

但是，sinc filter 的宽度是无限的，而且有些区域是负的，所以实际中很少使用。实际中用得更多的是对 sinc filter 的近似滤波器，约束了单个滤波器的作用范围。越接近 sinc filter 的滤波器，越可能包含产生负数的部分，所以实际会使用一些不含负数的滤波器，比如高斯滤波器。

重建得到连续信号之后，并不能直接使用，因为计算机图形只能输出离散信号。但重建得到的连续信号可以调节信号大小，在此基础上可以重新采样信号进行输出。重采样中的上采样（减少采样间隔，更多的采样点）是容易进行的，只需要按照目标采样间隔采样重建的信号即可；降采样就会复杂一些，直接降低采样数会引起走样问题，所以需要使用 sinc filter 滤波器。

几种屏幕空间抗锯齿技术：

- **SSAA**：超级采样抗锯齿技术，使用更高的分辨率渲染图像，然后通过滤波获得目标分辨率的图片。该方法性能开销严重。
- 一种与 SSAA 类似的方法是，渲染出沿 x,y 方向偏移半个像素的同分辨率图像，通过**累积缓存**（遗弃，可使用高精度像素颜色混合）将这四张图像叠加起来。但由于需要重新绘制场景并且多次写入缓存，性能开销也非常严重。但相比于 SSAA 的优势是，对累积的图像数量没有限制，可以生成质量非常高的图片。
- 但物体边缘的走样问题仍然是一个严重问题，目前的主流方法是通过**分析法**解决。在渲染过程中找到物体的边缘，将边缘的影响因素考虑进抗锯齿中。
- **MSAA**：多重采样抗锯齿技术意识到对子像素进行完整运算所造成的计算开销过高，对其进行了优化（仅在光栅化阶段对子像素的覆盖进行额外计算）。如果所有子像素都被同一个物体片元所覆盖，那么该像素的颜色直接采用像素中心点的采样值；但如果覆盖的子像素比较少，则会使用合适的权重（占比）修正该像素中心位置的着色结果。该过程基本由 GPU 来实现（光栅化阶段由 GPU 负责），所以这是一个依赖于硬件的抗锯齿算法，虽然该算法效率很高，但是也可能会产生不正确的结果，对于延迟渲染的支持也很难说。总而言之，由于只进行一次着色计算，MSAA 在提高计算效率的同时也节省了大量的显存空间。基于该技术，NVIDIA 提供了 CSAA，AMD 提供了 EQAA。
- NVIDIA 的 TXAA 技术和 MFAA 技术都利用了**TAA**技术，使用之前渲染的多帧画面信息进行抗锯齿。但 TAA 技术会使静止的场景出现颜色溢出（发光）；使快速运动的物体出现鬼影。可以通过重投影的方法修正鬼影问题，即对画面生成速度缓冲用于寻找正确的采样点。由于 TAA 技术的效果很好，且不需要额外的采样点，成为了近几年最受欢迎的抗锯齿技术，而之前应用最多的 MSAA 则因为对延迟渲染的支持欠佳而逐渐遭到淘汰。
- 采样图案对抗锯齿的影响也是显著的。奈曼提出人眼对水平和竖直方向的边缘更加敏感，对接近 45° 的斜边也较为敏感。基于此，旋转网格超采样（RGSS）将采样图案旋转，使得水平和竖直方向可以被更多采样点覆盖。RGSS 图案实际上是一类“拉丁超立方体采样”（分层采样）。但如果图案中的采样点沿着某个方向分布，则对与该方向平行的边缘采样的效果会很差，我们通常希望得到分布更加均匀的采样图案，因此分层采样方法常常和其他一些方法结合使用，比如抖动采样、霍尔顿序列、泊松圆盘等。
- 尽管子像素的图案采样可以得到不错的效果，但仍然不理想。场景中可能会存在非常小的物体，这意味着可能没有合适的采样图案可以用。如果这些小物体本身会形成一种图案，再通过固定间隔去采样，就很可能会产生摩尔纹。一种解决方案是使用随机采样，比较典型的就是对不同的像素使用不同的采样图案。
- **形态学方法**：锯齿通常出现在边缘，比如物体边缘、阴影边缘、高光边缘。形态学是指有关结构和形状的研究，形态学抗锯齿方法主要工作在于寻找和重建边缘。基于图像的方法会遇到一些问题，首先是边缘不一定能找到，当两个物体之间的颜色差别小于算法阈值时，就很难确定物体边缘；具有高对比度、高频率元素的物体表面，也容易误导算法，从而难以确定边缘；应用形态学抗锯齿常常会影响文本质量；图像抗锯齿算法也很难处理边角位置，一种处理方法是结合 MSAA 的子像素覆盖来确定边缘；图像抗锯齿算法处理不同的图像的时间复杂度也是不同的，草坪可能需要天空三倍的时间。总之，图像抗锯齿算法非常节省显存和算力，所以其应用面非常广；又由于其不依赖于其他信息，非常容易从渲染管线中解耦出来。最流行的图像抗锯齿算法是 FXAA 和 SMAA，SMAA 还可以结合 MSAA 的采样进行更好的抗锯齿处理，两种方法都可以和 TAA 结合。每帧的时间开销大约是 1~2 毫秒。

光线穿透半透明物体的方式有很多种，在渲染领域可以简单分为两类：基于光线的、基于相机的；基于光线的半透明效果侧重于光线穿透时的衰减和散射，会使周围的其他物体也被照亮；基于相机的半透明效果侧重于渲染半透明的物体本身。

一种透明渲染方法被称为“纱门透明”，使用一种带有透明部分的棋盘格图案渲染三角形面片，使得一部分被遮挡的物体露出来。这种方法的一个主要缺陷是，只有一层透明可以被渲染得很好；这种方法的主要优势是，足够简单，它可以在任何时间按任何顺序渲染透明物体，对硬件没有额外要求。

大部分的透明算法使用的是透明度混合技术。其中的$alpha$值指的是“不透明度”，即占比为$\alpha$的光线会被物体表面阻挡。

向上混合：$\textbf{c}_o=\alpha_s\textbf{c}_s+(1-\alpha_s)\textbf{c}_d$

向上混合在处理一些透明塑料和透明玻璃时的效果比较差，因为实际中的玻璃和滤镜等透明物体也会减少光线的穿透，从而使得最终的颜色更暗一些（不透明度提升），而不是简单的颜色混合。（s=source, d=destination）

加法混合：$\textbf{c}_o=\alpha_s\textbf{c}_s+\textbf{c}_d$

加法混合对于发光效果很好用，比如闪电、火花，这些效果会使透明混合的部分更亮。加法混合对于大多数透明物体来说都不正确，但是用在多层透明的物体上（如烟雾、火焰）可以提亮颜色。

由于 z-buffer 只能存储一个深度信息，所以靠 z-buffer 是不能解决透明混合的深度问题的，仍然需要按深度顺序的排序。一种方法是对每个物体进行排序，按质心到相机的距离排序；但这种方法有很多问题，比如互相交错的物体就很难正确处理，自遮蔽也无法处理。虽然有着这样那样的问题，但这种方法胜在简单高效，仍有用武之地。实际使用中通常会关掉深度写入，这样深度测试就始终基于最近的不透明物体进行。

向下混合：$\textbf{c}_o=\alpha_d\textbf{c}_d+(1-\alpha_d)\alpha_s\textbf{c}_s\quad\textbf{a}_o=\alpha_s(1-\alpha_d)+\alpha_d$

向下混合和向上混合很相似，将目标和源对调了一下，另外修正了 α 值。通过向下混合可以将所有透明物体的渲染结果混合到一张颜色缓冲中，然后再使用向上混合将不透明物体的渲染结果和透明物体的渲染结果混合。

顺序无关的透明渲染（OIT）：**深度剥离**算法可以实现顺序无关的透明渲染。首先使用一个 pass 获取所有物体的深度信息（包括透明物体），写入第一个深度缓冲；接着第二个 pass 渲染所有的透明物体，找到所有命中第一个深度缓冲的透明面片，将这些面片的 RGBA 信息写进一个单独的颜色缓冲中，然后将深度大于第一个深度缓冲的最小深度写入第二个深度缓冲，这样就得到了第二深的面片深度信息；重复上述步骤若干次，并将颜色缓冲按向下混合做透明混合，就可以得到顺序无关的正确透明混合结果，没有交错面和自遮蔽问题。可以使用固定的次数，也可以使用 pixel draw counter 来确定，当该 pass 没有处理任何 pixel 时，就意味着深度剥离触底了，可以停止了。

OIT 中使用向下混合的一个好处是，它最大化了近处透明物体的透明混合效果。当经过若干次混合之后，不透明度会越来越大，接近于不透明的效果，之后的物体几乎被遮挡。而向下混合会从前向后进行透明混合，可以保证上层的透明物体更加清晰。另外可以搭配使用一些剪枝优化算法，比如向下混合次数达到一定次数后就可以中止计算，几乎不会影响混合效果；反之，若使用向上混合就不太行，因为向上混合最后才计算离相机最近的像素。

OIT 的计算效率比较低，需要多次 pass。它有一些优化算法，比如 dual depth peeling，每次剥离最近和最远的两个面；桶排序法，每个 pass 可以对多达 32 层透明面片进行排序，缺陷是需要较大的显存；另外，搭配使用 MSAA 也可以减少开销。

透明混合的问题不在于缺少算法，而是在于如何将算法映射到 GPU 上。Carpenter 提出使用 A-buffer 存储像素所覆盖的透明片元的链表。在 GPU 上使用链表存储片元，使用 DX11 的 UAVs 可以实现。链表存储有时是一个优势，比如不会浪费额外的空间；有时也是一个劣势，由于没有预分配，对于一些特殊的场景，透明覆盖的链表可能很长，有些复杂的游戏场景中可能会多达 50 个透明面片、200 个半透明粒子。

另一种 OIT 算法是对 α 算加权平均和，公式是：

$\textbf{c}_o=\sum\limits_{i=1}^{n}(\alpha_i\textbf{c}_i)+\textbf{c}_d(1-\sum\limits_{i=1}^{n}\alpha_i)$

实际运算使用拆分计算的方式（书 P157），多个面根据它们的不透明度贡献颜色，不透明度越高则权重越大。

**显示编码**：通常计算各种光照和图像操作时，默认都是按照线性方式计算的；但是为了校正视觉效果，显示器的缓冲和纹理贴图一般都是使用非线性的编码方式。最简单的校正方式就是将着色器输出的颜色（范围在 0~1）乘以$\frac{1}{2.2}$次方，这种方式被称为“gamma correction”（伽马校正），对于输入使用的纹理贴图和颜色，则需要乘以$2.2$次方。

最早的电子显像设备是 CRT（阴极管射线显示器），这种显像设备的发光强度和电压之间呈指数关系，当作用于某个屏幕像素的能量提升时，该像素发光强度并不是线性提升的；举个例子，假设电压和发光强度之间的指数比是$2$，则将像素的电压设置为$50\%$时，实际的发光强度为$0.5^2=0.25$，而当电压设置为$100\%$时，发光强度则为$1$。虽然后来的显像设备（如液晶显示器，LCD）有其自身特定的响应曲线，但是厂商一般都会将响应曲线调校成接近 CRT 的响应曲线。

巧的是，这种指数关系恰好与人眼知觉的响应互为倒数，这也就使得显示编码的操作符合人的感知。这意味着，显示范围内两个邻近值的差别在编码之后是固定的。类似于人眼对比度阈值（倒数为对比敏感度）的测量方式，可以在响应曲线上各处测试$1\%$的亮度差别。这种近似最优分布减小了由于显示缓冲区精度限制而产生的条带状伪影，对于纹理贴图的使用也起到相同的优化效果。

显示转换函数可以反映显示缓冲中的数值和显示器的发光强度之间的关系，因此也被称为电光转换函数（EOTF）。这是一种和硬件相关的函数，电脑显示器、电视机、电影放映机都有关于该函数的不同标准。相反的转换函数也有一个标准函数，被用于描述摄影摄像设备，称为光电转换函数（OETF）。

当为显示器编码线性颜色值时，需要抵消显示转换函数造成的影响，这样才能产生相应的发光强度。比如说，我们的计算结果翻倍了，我们希望发光强度也翻倍，就需要应用一个显示转换函数的指数倒数来抵消非线性关系，这种消除显示设备响应曲线的处理就被称为伽马校正。当解码纹理贴图的数值时，则需要应用一个显示转换函数来获得线性值，以供后续着色处理。

总结一下着色的过程：

- 一张已经编码过的纹理贴图被传递进 shader（GPU）中，由于是编码过的，也就是在线性的基础上乘以了类似于$\frac{1}{2.2}$次方，函数图像是一段斜率减小的曲线
- 为了重新得到线性值用于着色计算，需要给这张纹理贴图应用一个类似于$2.2$次方的解码函数，函数图像是一段斜率增大的曲线
- 着色计算完成之后，需要将计算出的颜色编码后写进帧缓冲中，也就是应用编码函数后传递进帧缓冲
- 最后，显示设备会将帧缓冲中的颜色刷新到屏幕上，这个过程中会天然地应用了显示转换函数（电光转换函数），这个函数相当于一个解码函数，所以最后呈现的发光强度和计算出的颜色呈线性关系
- 注意，虽然最终的颜色是线性的，但是对于人眼来说则不是。

电脑显示器的标准显示转换函数是被称为**sRGB**的色彩空间。大部分的图形 API 在调度 GPU 时，都会自动完成基于 sRGB 的转换，例如 mipmap 的生成也会按照 sRGB 编码。在线性空间下，双线性插值就可以正确无误地进行；alpha 混合前也会先将图像解码到线性空间，混合之后再编码回去。

显示编码可以看作一种压缩方法，因为编码之后拓宽了暗部的范围，从而使得暗部数据的精度得到提升。

正如计算之后的图像需要先进行显示编码再传递给显示设备一样，摄像机拍摄的画面也需要先转换到线性空间再进行编辑。屏幕上显示的图像可以直接通过屏幕截图或者取色器获得，这类颜色会以某种图像格式存储，比如 PNG、JPEG 或者 GIF，这种格式可以直接发送给显示器用以输出显示，不需要经过额外的转换。换句话说，所有屏幕上最终显示的图像，实际上都是经过了显示编码的，所以在着色器中使用这些图像时，需要先将它们解码回线性空间。

encode to sRGB: $y=\left\{\begin{matrix}1.055x^{1/2.4}-0.055,&{where\;x>0.0031308,}\\12.92x,&{where\;x\leq 0.0031308,} \end{matrix}\right.$

decode to linear: $x=\left\{\begin{matrix}\left(\frac{y+0.055}{1.055}\right)^{2.4},&{where\;y>0.04045,}\\\frac{y}{12.92},&{where\;y\leq0.04045,}\end{matrix}\right.$

### 5.纹理

纹理上的像素一般被称为“纹素”（texel），区别于屏幕像素。

应用纹理的流程一般是这样的：

- 确定物体模型空间内一个三维坐标点
- 通过投射器（Projector）将该三维坐标点映射到二维纹理空间，得到 UV 坐标
- 根据 UV 坐标和纹理规格，采样纹理
- 根据纹理的格式，将采样值转换到线性空间

模型师在建模的时候通常会定义好模型的展开 UV，而投射器函数可以帮助模型师快速生成一个初始化的 UV 映射结果；投射器函数有很多种不同的投射方式，最常见的有球形投射、圆柱投射、平面投射。纹理投射的主要问题出现在模型接缝处，有一种多立方体投射方法，它将整个模型映射成多个立方体投射集合，模型的不同部分使用不同的立体方体进行投射。其他有一些投射器函数并不进行投射，它们本身其实是表面构建和细分的一个隐式部分；比如参数化的曲面模型具有天然的 UV。UV 坐标可以基于不同的需求建立，例如视角方向、表面温度等；使用投射器函数只是为了构建纹理坐标，通过位置信息构建只是其中一种最常见的构建方式而已。

一般来说，对一个模型应用一种投射器就足够了，但艺术家有时需要将模型拆分成多个部分，并对不同的部分应用不同的投射器。

对于实时渲染来说，投射函数通常在建模阶段使用，然后把投射的结果存储到模型文件的顶点信息中（UV 坐标）。当然也有例外，有时更适合在顶点或者像素着色器中使用投射函数，可以增加投射的精度或者达到某些特殊效果，比如动画。另外有一些渲染方法，比如环境贴图映射，会使用专门的投射函数进行逐像素的计算。

纹理坐标不一定总是二维平面，有时也可能是三维体，这种情况下的纹理坐标被表示成三维向量（u,v,w），其中的 w 是投射方向的深度。有些系统中会将其表示成四维（s,t,r,q），其中的 q 作为齐次坐标的第四个值。三维体的投射类似于电影放映机，随着距离的增加，投影的纹理面积也在增大。

另一种重要的纹理坐标空间是方向空间，空间中的每一点可以通过一个方向获取。这种坐标空间的一种可视化方法是将它放在单位圆上，则球面上每一点的法线方向就是获取到这点的方向。这类纹理常常用在立方体贴图（cube map）上。

一维的纹理贴图同样值得注意，比如地形模型的颜色可能由地形高度决定，低洼的地方是绿色的，山峰则是白色的。线条也可以带有纹理，比如渲染雨就可以使用一些带有半透明图片的线条。这类纹理也常被用于值的转换，例如作为查找表。

接下来涉及到 corresponder function，不知道怎么翻译好，就姑且翻译成“关联函数”吧。

在对纹理坐标进行插值之前，需要先将纹理坐标转换到纹理空间位置，这个转换函数就是“关联函数”。一种关联函数是使用图形 API 选择纹理中的某块区域显示，那么就只有这部分区域会被用在后续的操作中。另一种关联函数就是一个变换矩阵，可以被用于顶点或像素着色器中。

关联函数的另一个重要的控制项是图片的使用方式。图片会被按照 UV 映射到模型的表面，那么 UV 之外会是什么样？关联函数可以控制这种情况，OpenGL 中的“wrapping mode”和 DirectX 中的“texture addressing mode”提供了一下的控制选项：

- **wrap**(DirectX), **repeat**(OpenGL)：默认选项，超出部分重复使用贴图，即 UV 坐标丢弃掉整数部分。
- **mirror**：每次重复使用贴图时都会进行镜像翻转。
- **clamp**：超出范围的部分使用图像边缘的值。该选项对于图像边缘采用双线性插值时很有用。
- **border**：超出范围的部分使用指定的颜色值。

以上的控制选项可以根据不同的轴单独配置，比如对 U 轴使用 repeat，对 V 轴使用 clamp。DirectX 中还支持一种叫做**mirror once**的选项，即只对超出部分使用一次镜像翻转，之后的部分就会使用 clamp，该选项对于制作对称贴花效果很有用。

重复纹理贴图是一种增加细节效果的实惠方案，但达到三次重复就容易被眼睛发现重复性；一种常见的解决周期性问题的方法是，将不同的图片结合到一起；另一种解决方案是使用 shader 来实现特殊的关联函数，将纹理图案随机地组合。

关联函数的另一个作用是可以轻易地在不同分辨率的图片之间切换；无论原始分辨率如何，关联函数都会完成相应的 UV 映射。

像素着色器中采样纹理，是通过向类似于 texture2D 的类型提供纹理坐标得到的，纹理坐标的范围在[0.0, 1.0]。GPU 会谨慎地将纹理坐标转换为纹素的坐标位置，不同 GPU 的处理不完全一样，主要区别是：DirectX 中左上角的纹理坐标是(0,0)，右下角的纹理坐标是(1,1)；而 OpenGL 中左下角的纹理坐标是(0,0)，右上角的纹理坐标是(1,1)。纹素的坐标都是整数，但有时候会想要两个纹素混合得到它们中间位置的颜色，这就引发了一个问题：像素中间的浮点值应该如何确定？有两种方案：截尾和四舍五入。DirectX 9 使用四舍五入，认为每个像素的中心是(0.0, 0.0)，但这容易使人困惑，左上角像素的左下角的坐标值变成了(-0.5, -0.5)；DirectX 10 中改用了 OpenGL 的形式，即纹素的中心坐标值为(0.5, 0.5)，然后使用截尾的方式定义纹素坐标值，例如像素(5, 9)即指 u 轴坐标在 5.0~6.0，v 轴坐标在 9.0 到 10.0 的区域。

Dependent texture read，依赖纹理读取，有两种含义。第一种含义用于移动设备上，当像素着色器使用计算出的纹理坐标而不是使用顶点着色器提供的纹理坐标获取纹理时，就会触发依赖纹理读取，任何改变纹理坐标的操作都会触发，即使是简单地交换了 u 轴和 v 轴的值；对于早期的桌面 GPU，当纹理的坐标依赖于之前某张纹理的值时，就会触发依赖纹理读取，比如当纹理改变法线，进而改变对立方体贴图的采样时。

DirectX 12 最大允许 16384\*16384 的纹理。

应用纹理主要考虑两种情形：放大和缩小。效果主要取决于使用的采样和滤波方法。

对纹理放大采样和缩小采样的问题，主要是处理对采样值的滤波方法；而抗锯齿问题主要是处理输出值的滤波方法。两者虽然都涉及滤波，但是作用于不同的阶段，不过由于大多数情况下输入和输出是线性相关的，所以对输出值滤波与采样时滤波是等价的。

#### 5.2 放大

最常见的放大技术是“最近邻法”和“双线性插值”。最近邻法有很明显的“像素化”问题，因为采样了周边最近点的像素颜色；虽然效果不好，但是最近邻法的每个像素只需要采样一个纹素即可。双线性插值法则是根据邻近的四个纹素的值，在两个方向上插值出中间值作为像素颜色，插值结果看上去比较模糊，但大幅减少了最近邻法的锯齿。

双线性插值的流程：

- 根据 OpenGL 表示法（像素中心位置为 0.5, 0.5）修正后找到相邻的四个像素，即减去(0.5, 0.5)之后，截尾得到左下相邻像素$(x,y)$，从而得到全部的四个像素$(x,y),(x,y+1),(x+1,y),(x+1,y+1)$
- 截取的小数部分即为插值的权重$(u^{'},v^{'})$
- 用$1-u^{'}和u^{'}$插值$(x,y),(x+1,y)$
- 用$1-u^{'}和u^{'}$插值$(x,y+1),(x+1,y+1)$
- 用$1-v^{'}和v^{'}$插值以上两值

放大的纹理通常会显得比较模糊，可以在其上叠加细节纹理。细节纹理上的高频重复图案结合低频的放大纹理，可以创造出接近于高分辨率纹理的视觉效果。

双三次插值（bicubic filter）可以消除绝大多数的图像不平滑，但是计算开销比双线性插值大很多；当然，很多高阶的插值方法可以通过重复多次线性插值得到。

有一种开销比双三次插值小的算法是使用一段平滑的插值曲线进行插值。常用的两种曲线是$smoothstep$和$quintic$：

$smoothstep:s(x)=x^2(3-2x)$

$quintic:q(x)=x^3(6x^2-15x+10)$

这两种曲线都足够平滑，其中$smoothstep$满足$s^{'}(0)=s^{'}(1)=0$；$quintic$满足$q^{''}(0)=q^{''}(1)=0$。

#### 5.3 缩小

对于需要缩小纹理的情况，一个像素可能会对应多个纹素。可以像放大一样采用最近邻采样，即选用像素中心所对应的最近纹素，但该方法会产生严重的走样问题。

为了解决走样问题，就需要考虑奈奎斯特极限，即采样频率不能低于原始频率的一半。当原始频率（纹理）比较高时，要么提高每个像素的采样频率，要么降低原始频率。

解决该问题的算法很多，但基本思路是相同的：预计算纹理。

首先是**多级纹理（_mipmap_）**，这是用得最多的方案，几乎所有的图形加速结构都支持生成多级纹理。第 0 级纹理是原始纹理；第 1 级纹理是原始纹理的四分之一大小，通过对相邻的四个原始纹素取平均得到；之后每一级纹理都是上一级纹理的四分之一，直到某个边上只剩下一个纹素；这些多级纹理组成的图集一般被称为”多级纹理链“（_mipmap chain_）

多级纹理生成中需要考虑两个重要的因素：滤波和伽马校正。

一般的多级纹理滤波采用的是$2\times2$的盒式滤波，是一种效果比较差的滤波，可能会将不必处理的低频信息模糊掉，保留容易引发走样的高频信息；更好的选择是使用高斯滤波、兰佐斯滤波、Kaiser 滤波，或者其他相似的滤波器。

由于纹理大多都编码进了非线性空间，如果不进行伽马校正可能会使滤波结果不正确（看上去偏暗）。但有一些纹理本身就是非线性的，对于这类纹理的滤波需要单独考虑。

确定*mipmap*的采样层级通常有两种方法，一种是使用屏幕像素覆盖的纹理四边形中的长边；另一种是求出$\partial u/\partial x,\partial v/\partial x,\partial u/\partial y,\partial v/\partial y$中的最大值。后一种方法在 shader model 3.0 之后可以在像素着色器中容易得到，但如果是在动态分支语句，或者顶点着色器中使用导数信息的话，就需要提前计算好或者手动计算。

访问*mipmap*时使用的是(u, v, d)三个值，其中 d 值不是整数，实际使用中会先根据 u,v 做双线性插值得到两个不同层级上的采样值，再根据 d 值对两个采样值做线性插值，整个采样过程被称为“三线性插值”。

*mipmap*也有一些问题，一个主要问题就是过度模糊，当视线沿着掠射角观察物体表面时，屏幕像素在两个方向上覆盖的纹理数量会有比较大的差距，有时甚至会出现一个方向上应该放大纹理，而另一方向上应该缩小纹理，由于我们在选择*mipmap*层级时，总是会按照覆盖最大的一个选，那么在这种情况下往往会得到过于模糊的效果。

然后是**Summed-Area Table**。首先需要创建和纹理一样大小的数组，但是存储颜色的精度更高（比如给每个颜色通道都分配 16bits 或者更多）。数组的每一个元素都存储了从纹素起点(0, 0)到当前元素映射位置所张开的矩形覆盖的纹素值之和。

SAT 是一种各向异性的滤波算法，可以对非正方形的区域计算纹素值，但存储开销略大。无约束各向异性滤波算法会沿着纹理上区域的长边生成一条各向异性的平行线，在这条线上增加采样，使最终结果沿着该方向看来更加清晰。

cube map 通过一个三维向量采样，表示的是从立方体中心向外发射射线所采样到的点。首先找到最大的一个分量，以此确定立方体的面（例如(-3.2, 5.1, -8.4)就采用-z 面），接下来需要将剩下的分量按比例映射到[0, 1]（即(-3.2/8.4 +1)/2 和(5.1/8.4 +1)/2；得到(0.31, 0.80)）

#### 5.4 纹理压缩

一张$512^2$分辨率、每个纹素使用 3 字节的纹理，需要占用 768kB 空间；如果按 6:1 压缩率压缩，一张$1024^2$分辨率的纹理也只需要 512kB。

图片压缩的方法有很多，比如 JPEG 和 PNG，但是这类方法不适合在 GPU 中实时解压缩。S3 开发过一种被称为*S3 Texture Compression*的压缩算法用于 GPU 计算，DirectX 中被称为*DXTC*，DirectX 10 中被称为*BC（Block Compression）*，OpenGL 中也有相应的实现，几乎所有的 GPU 都支持该纹理压缩算法，主要优势在于压缩后的各部分模块之间以及查找表之间都没有耦合，可以并行快速解码。

以*BC1*为例，每$4\times4$的纹素作为一个 block 进行压缩运算，其中的每个纹素仅存储 2 个 2bit 的插值系数，插值对象则是由指针指向的两个参考颜色，相比于无压缩的 24bit 颜色*BC1*压缩率可以达到 6:1(即每纹素的占用空间由 24bit 下降至 4bit)

其他还有很多的压缩方法，比如移动端常用的 ETC，通过直方图归一化优化，或者换到其他的颜色空间（比如 YCoCg）压缩。

#### 5.5 程序纹理

程序纹理很适合用来合成体积纹理。一种最常用的方法是，使用一个或多个噪声函数来生成纹理数值。另一种程序纹理的生成则是来自于物理模拟的结果，比如水波、裂纹扩散等。

普通纹理可以通过手动方式解决拉伸、接缝等瑕疵问题，但程序纹理就没有那么容易；程序纹理的抗走样问题既有方便的地方，也有麻烦的地方：预计算生成 mipmap 是没法用了；但是程序纹理有其描述函数，可以专门设计抗走样算法，比如噪声函数的频率已知，则可以规避掉可能产生走样问题的频率，还可以顺带优化性能。

#### 5.6 透明

纹理带透明通道可以提供很多有意思的用法，比如贴花（decal）、cross tree 等。当使用类似 cross tree 的技术模拟草地的时候，需要解决大量的透明面片相互交叠的问题，一种优化方案是使用透明度测试（alpha testing），可以丢弃所有不透明度小于阈值的面片；但使用该技术时也需要注意一些问题，比如使用了 mipmap 后可能会进一步丢弃更多的面片，从而产生不正确的效果，这种问题可以通过修正各级 mipmap 的不透明度解决，具体公式参考书 P204。

使用带透明度的颜色进行线性运算时，需要先进行透明度预乘，否则结果可能会不正确：

- 未进行透明度预乘：$(255,0,0,255)\otimes(0,255,0,2)=(127,127,0,128)$
- 进行过透明度预乘：$(255,0,0,255)\otimes(0,2,0,2)=(127,1,0,128)$

未进行透明度预乘可能会使贴花或透明裁切的图像产生黑边；但一些图像格式（如 PNG）如果进行预乘，则会损失精度，一种解决方案是对透明区域的颜色部分填充相邻的不透明颜色值。

#### 5.7 凹凸贴图

物体表面的细节效果可以分成三类：宏观特征（覆盖许多像素）、中等特征（覆盖些许像素）和微观特征（小于一个像素）。这个分类并不严谨，在动画或某些情况下可能会从多个距离观察物体。

宏观特征一般通过建模来表现（人的肢体、头，是一种宏观特征）；微观特征一般通过着色模型来表现；中等特征介于两者之间（如皱纹、衣服接缝等），通常使用各种凹凸贴图来表现。

凹凸贴图有很多种类型，不同类型之间的区别主要在于其对细节特征的表现方式。

TBN 标架（tangent, bitangent, normal）矩阵将光线从世界空间转换到切线空间。有一种节省空间的存储方法，是仅存储切线和副切线向量，但这种方法只能用在偏手性一致的矩阵中，比如很多物体都是对称的，所以制作一半的模型并将它镜像翻转，这种方案就会使两边的模型偏手性不一致；也可以额外存一个 bit 的数据来描述偏手性。如果 TBN 标架是一个正交基底，那么就可以用四元数来表示，既节省空间也能节省一些逐像素的计算，是常用的存储方式。

切线空间对于材质描述非常重要，虽然大部分的着色模型都只依赖于表面法线的方向，但是像拉丝金属、绒布之类的材质则额外需要视线、光源相对于表面的方向。

除了正常地存储切线空间法线之外，还有一些方法可以在运行时计算法线，比如使用表面位置导数和高度图导数来计算法线扰动；当然，这些方法都可能会产生瑕疵。

可以存储和使用世界空间或物体空间的法线，但这样会降低法线贴图的泛用性。切线空间法线的另一个好处是便于压缩，因为切线空间法线默认是向上的。

法线贴图的滤波比较困难，因为它通常不是线性的，如果法线滤波不正确就会产生高光闪烁。

从高度图导出法线图：首先沿 x 和 y 方向计算差分导数，即可得到未归一化的法线

$h_x(x,y)=\frac{h(x+1,y)-h(x-1,y)}{2},\quad h_y(x,y)=\frac{h(x,y+1)-h(x,y-1)}{2}$

$\textbf{n}(x,y)=(-h_x(x,y),-h_y(x,y),1)$

视差映射：根据视角方向修正法线采样点，就可以得到很不错的随视角改变的凹凸效果。另外可以通过光线步进的方式得到交点以解决遮蔽问题。

### 6. 阴影

非点光源（多光源、面光源、体积光源）会产生复杂的阴影效果，一般由本影和半影两部分构成。软阴影不能简单地通过对本影边缘做模糊化处理得到，正确的阴影效果是越接近物体的部分越实，远离的部分变虚。本影部分也不等同于点光源产生的硬阴影，当光源变大时，本影部分就变少，甚至完全消失。

通过投影矩阵变换可以得到被投射阴影物体在平面上的三角形面，绘制该三角形面即可得到阴影；不过有几点需要注意，首先是避免接受阴影的平面之下也被画上阴影，这个问题可以通过适度增加阴影三角形的偏移解决；另一种方法是先绘制平面，然后关闭深度缓冲直接绘制阴影三角形，最后再绘制其他部分，但如果阴影溢出平面，就可能会产生问题；解决方法是使用模板缓冲，只在接受阴影的表面绘制阴影三角形。

另一种绘制阴影的方法是将阴影三角形绘制到一张纹理图中，之后再将该纹理图应用到接受阴影的平面上，这种纹理图其实正是一类光照贴图。

如果光源位于阴影投射物体和阴影接受物体之间，或者阴影接受平面位于阴影投射物体之上，可能会产生反阴影，通过 GPU 管线的投影裁剪可以修正这个问题。

比较快的软阴影生成方法是使用卷积模糊硬阴影，但一般效果会很失真。Hanies 的软阴影方法是对硬阴影的边缘从内向外由黑转白绘制近似的软阴影效果。

最常用的阴影投射方法是使用 shadowmap，具有计算量可控、便于优化等优势，缺点是阴影质量和贴图分辨率挂钩，也和深度缓冲的数值精度挂钩；另外会存在例如 shdow acne 的问题，这个问题一般由两部分原因构成，一方面是精度问题，另一方面则是由于表面点采样来替代局部面上的深度值而造成的不精确问题（比如屏幕像素采样是从像素中心出发的），使用偏移系数可以一定程度解决这个问题。偏移有很多种方案，有沿着固定方向的、沿着背向光线的、沿着面法线的等，但偏移过多都会导致 Peter Panning 问题，表现为物体似乎像是浮起来。

为了解决对不同物体的阴影细节需求，级联阴影技术被提出，但级联阴影的使用需要对深度进行划分。一种划分方式是根据上一帧画面中的深度信息进行调整，但这无法处理新出现的物体；另一种处理方法是统计不同深度下的物体分布信息，但可能会产生阶跃的情况。一般用得最多的是第一种方案。级联阴影还会出现一些突变问题，可以通过混合或者抖动法解决。

PCF 的思路恰好和光照过程相反，它通过表面某点观察光源的可见性来计算阴影的软硬。对于表面某点，PCF 会在它周围相同深度生成多个采样点，根据这些点对光源的可见性来决定阴影的软硬程度。PCF 的一个问题是，由于周围采样点的半径范围不变，所以软阴影区域固定不变，存在失真问题。

PCSS 的主要思路在于，通过投射阴影物体的距离来决定 PCF 的采样半径。当投射阴影的物体距离阴影接受面变远时，采样半径就会增大，软阴影区域也会更大。（接触处阴影更硬，远离处阴影更软）

使用 VSM 可以对 shadowmap 进行滤波，它使用两张贴图分别存储深度值和深度值的平方。VSM 可以显著提升运算效率，因为它可以利用硬件进行滤波。但 VSM 在一些特殊情况下会存在漏光现象。

例如烟雾、头发等模型需要产生自阴影，一种解决方案是使用带深度分片的阴影贴图，但这类贴图的开销较大，且存储和更新需要依赖于压缩算法及硬件设施。

不规则深度缓冲技术（IZB）将多个阴影接受物体存储到阴影贴图中，即每个纹素中可能存储了零个或多个阴影接受坐标。首先从视角空间产生深度信息，然后将该深度信息转换到光源空间下，此时就得到了光源的不规则深度缓冲，每个纹素中存储了所有可以被看到的阴影接受坐标信息；最后使用保守光栅化的策略绘制阴影。使用不规则深度缓冲技术可以生成非常完美的硬阴影，不会有 Peter Panning 等问题；为了叠加上软阴影效果，实际运用中也经常使用混合了 IZB 和 PCSS 的技术。

### 7. 光照和颜色

#### 7.1 辐射度量

辐射度量用于测定电磁辐射。不同波长的电磁波通常具有不同的性质。人眼可见的波长范围约为 400nm~700nm。

辐射度量的基本单位为“**辐射通量**”（radiant flux），常用字母$\Phi$表示，描述单位时间内辐射的能量，单位为“瓦特”（$W$）。

“**辐照度**”（irradiance），常用字母$E$表示，描述单位面积上的辐射通量，表达式为$d\Phi/dA$，单位为“瓦特每平方米”（$W/m^2$）。

“**辐射强度**”（radiant intensity），常用字母$I$表示，描述单位立体角内的辐射通量，表达式为$d\Phi/d\omega$，单位为“瓦特每立体角”（$W/sr$）。

“**辐射度**”（radiance），常用字母$L$表示，描述单位立体角内单位面积上的辐射通量，表达式为$d^2\Phi/dAd\omega$，单位为“瓦特每平方米每立体角”（$W/m^2sr$）。（注意：这里的面积是按照垂直于光线的面积计算的，实际计算时需要根据光线方向使用余弦值修正）

辐射度是传感器（例如人眼、相机传感器等）对电磁辐射的度量方式。环境中的辐射度可以用具有 5 个变量的函数（考虑波长就是 6 个）描述，即 3 个描述空间坐标、2 个描述方向。辐射度在公式中长表述为$L_o(\textbf{x},\textbf{d})或者L_i(\textbf{x},\textbf{d})$，即离开或进入$\textbf{x}$的辐射度，按照惯例，其中的$\textbf{d}$都采用离开$\textbf{x}$的方向。另外值得一提的是，辐射度的传播不随距离发生衰减。

光线传播中通常包含很多不同波长的电磁波，这可以通过光谱功率分布图看出。

每一种辐射度量都有其对应的光谱分布，由于光谱分布是在波长轴上的，所以光谱分布版的辐射量的单位就是加上一个“每纳米”（例如“瓦特每平方米每纳米”）。

#### 7.2 光度测定

辐射度量是基于物理的电磁辐射测量方式，并未考虑人眼的感知因素。光度测定和辐射度量很相似，但它根据人眼对不同波长电磁波的敏感程度，对测量结果进行权重修正。将辐射度量的计算结果乘以**CIE 测光曲线**，即可转换为光度测定结果。

CIE 测光曲线是一条以 555nm 波长为中心的钟形曲线，描述了人眼对不同波长电磁波的敏感程度。

同样的，每一种辐射度量都有其对应的光度测定量：

辐射通量 →**光通量**（luminous flux），单位为流明（lumen，lm）

辐照度 →**光照度**（illuminance），单位为勒克斯（lux，lx）

辐射强度 →**光照强度/照度**（luminous intensity），单位为坎德拉（candela，cd）

辐射度 →**光度/亮度**（luminance），单位为尼特（nit）

逻辑上来说应当以流明为光度测定的基本单位，但因为一些历史原因，坎德拉被用作基本单位，其他单位都从坎德拉导出。

光度常被用于描述平面的亮度，比如 HDR 电视屏幕的峰值亮度一般在 500~1000nits，天空的亮度一般是 8000nits，一个 60 瓦的灯泡的亮度一般是 120000nits，而处于地平线上的太阳的亮度是 600000nits。

#### 7.3 色度学

色度学主要用于建立光谱功率分布和颜色感知之间的联系。

人类可以区别大约一千万种不同的颜色。人眼通过视网膜内的三种不同视锥细胞感知不同波长的电磁波。其他动物的视锥细胞种类数可能和人类不同，有些多的可以达到十五种。所以，对于人眼来说，只需要三个数值就可以精确地描述所有可以感知的颜色。

CIE（国际照明委员会）设计了一套实验用于寻找这三种颜色，一组测试结果是 645nm 红波、526nm 绿波和 444nm 蓝波，通过这三种颜色拟合各波长可见光的函数被称为“颜色匹配函数”。它将光谱功率分布转换成三个数值的组合。

但这三种颜色不能直接用于表达所有的可见光颜色，对于一些波长的颜色，可能会需要负数值描述。CIE 于是提出了一种假想的三原色，使得所有波长的颜色都可以用正数值描述，这三种假想三原色一般表示为$\bar{x}(\lambda),\bar{y}(\lambda),\bar{z}(\lambda)$，其中的$\bar{y}(\lambda)$和 CIE 测光曲线相同。通过对光谱功率分布按假想的三原色积分，就可以得到 CIE XYZ 颜色空间。为了将颜色分解成亮度和色度，需要进一步地将颜色空间描述成一个二维的色度空间，当固定亮度为 1 之后，可以得到$X+Y+Z=1$这个色度平面。

色度坐标$x=\frac{X}{X+Y+Z}$

色度坐标$y=\frac{Y}{X+Y+Z}$

得到的(x,y)会形成一条曲线，这条曲线是所有的可见光谱，连接两个端点的直线被称为“紫线”，中间的点代表自然白光，这张图被称为“CIE 色品图”。任取一点颜色，从白色点过该点向边缘连一条直线，到边缘长度的占比即表示该颜色的纯度，越接近边缘纯度越高；边缘上的点表示主波长。图形学中一般不用纯度和主波长描述，而是用饱和度和色相描述，虽然它们只是有点关系。

除了色度之外，剩下的一个用来描述颜色的维度就是亮度，用$Y$表示，这就被称为$xyY$坐标系。

电视或显示器使用特定光谱功率分布的 RGB 值作为显像基色，按不同值混合后形成目标颜色。

色品图中的三角形用来框定一个颜色域，用作显示设备的色域标准。色域三角形的三个顶点是三原色，是显示设备所能显示的饱和度最高的 R、G、B 颜色。用线段连接这三个顶点，其内部的所用颜色都可以通过三原色混合得到，这也是它们所形成的色域范围。实际上，显示设备的完整色域是三维的，色品图中展示的三角形只是它在二维平面上的投影。

不同 RGB 色彩空间通常是在 CIE 1976 UCS 色品图中对比的；因为 XYZ 空间中不同颜色对之间的差距可能会非常大，与人的感知不符，CIE 对此进行了修正，给出了 CIELUV 色彩空间，颜色之间的距离尺度更符合人眼的感知，而 CIE 1976 UCS 正是 CIELUV 的一部分。后续有关颜色距离感知尺度的研究提出了例如$IC_TC_P和J_Za_Zb_Z$颜色空间，它们的距离感知尺度比 CIELUV 更精确，特别是对于高亮度和高饱和度的颜色，但目前尚未普遍使用。

在不同的颜色空间下进行渲染，得到的结果也不尽相同；例如在更广色域 DCI-P3 或者 ACEScg 中执行颜色计算可以得到比在线性 sRGB 下执行相同计算更精确的结果。

实际上，人眼对色彩的感知还依赖于环境光照、周边颜色以及其他一些先决条件，“色貌模型”（Color appearance models）就是一类用于预测颜色感知的模型。

#### 7.4 使用 RGB 进行渲染

严格来说，RGB 是一种感知模型，用它进行基于物理的渲染是不正确的；正确的方式是使用光谱渲染，最后再通过密集采样或者坐标映射的方式转换到 RGB 颜色空间。

举例来说，物体表面对光线的反射，实际上会因为波长的不同而具有不同的反射率，这种特性一般用“光谱反射曲线”描述。正确的反射计算应当对光谱功率分布中的每个波长乘以其对应的光谱反射曲线得到，然后再转换到 RGB 色彩空间。而完全使用 RGB 色彩空间的光照计算则直接对 RGB 颜色进行混合来得到反射结果，这并不正确，但现实中大部分材质的光谱反射曲线都比较平滑，这也使得完全使用 RGB 的颜色计算结果误差较小。

但对于一些执行预测渲染的应用来说，这种误差就很重要了。两条不同的光谱反射曲线可能在某一种光源下表现为相同的颜色，但在另一种光源下就完全不同，这种现象被称为“异光源色度差”，对于汽车补漆等应用场景来说是非常重要的。

#### 7.5 HDR

HDR 显示器使用 Rec. 2020 和 Rec. 2100 色域标准。Rec. 2020 使用比 Rec.709 和 sRGB 更宽的色域范围，但相同的白值；Rec. 2100 则定义了两个非线性的显示编码：感知量化器（PQ）、混合对数伽马（HLG），渲染领域一般使用 PQ，它定义了最大峰值亮度为$10,000cd/m^2$。

实际上，当前主流的消费级 HDR 显示器很难达到需要用 Rec. 2020 评估的程度，人们往往更倾向于使用 DCI-P3 标准衡量 HDR 显示器的色域范围。使用 HDR 显示图像通常有三种方案（并不是所有的应用程序和操作系统都完全支持所有方案）：

- HDR10：使用 32bit 无符号整型存储每个像素的颜色，即 R10G10B10A2，使用 PQ 编码和 Rec. 2020 色域空间，HDR10 的映射没有统一标准。
- scRGB（线性）：仅支持 Windows 操作系统，通常按照 sRGB 标准显示，但允许数值低于 0 或者超过 1，使用每个颜色通道 16bit 的线性值，可以兼容 HDR10，该方案主要是为了向后兼容 sRGB。
- 杜比视界（Dolby Vision）：专用格式，并不是一种广泛支持的格式。使用每个颜色通道 12bit 存储颜色值，使用 PQ 编码和 Rec. 2020 色域空间。内部映射是标准化的，但没有文档。

将像素 RGB 值转换到 Rec. 2020 色域空间并使用 PQ 编码，通常产生比 sRGB 高很多的开销，有一些优化方法可以快速近似求解。另外，使用 HDR 显示的时候，需要注意调节 UI 的显示效果，避免过亮或者过暗。

#### 7.6 色调映射

色调映射将场景辐射度转换为显示辐射度。这一步转换被称为“端到端转换”或者“场景到屏幕转换”。使用“图像状态”来描述映射过程，两个基本的图像状态分别为“场景图像”和“显示图像”，“场景图像”是用场景辐射度描述的图像，”显示图像“是用显示辐射度描述的图像；图像状态与显示编码无关，无论哪一种图像状态都可以进行线性或非线性的显示编码。

色调映射并不是一种从场景到屏幕的恒等变换，也不是为了将场景的颜色空间压缩到显示器的颜色空间（尽管两者的动态颜色范围确实需要考虑）。色调映射是根据观看环境和显示特性，提供一种尽可能接近于临场体验的视觉颜色效果。

但还原临场感实际上是非常困难的，现实中的环境亮度可能比显示设备所支持的最大亮度高出几个数量级，颜色饱和度也可能远远超出显示设备所支持的范围。为了实现这样的效果，就需要充分利用人眼的视觉系统。

人眼视觉系统的适应能力可以补偿绝对亮度上的差距，但这种补偿是有缺陷的，在亮度较低的情况下会使对比度下降，也就是感受到的”视彩度“减少（亨特效应）。

环境因素也会影响感知对比度，例如显示设备所处房间的照明条件、屏幕反光等。

以上现象说明，为了达到临场感的效果，就需要提高显示图像的对比度和饱和度。

提高对比度会进一步地压缩亮度范围，这就需要通过渐入渐出来补充暗部和亮部地细节，也就是使用 S 型映射曲线，这和光化学胶片的灵敏度曲线是一致的，也就是讨论色调映射时常说的”胶片质感“。

曝光对于色调映射来说也是至关重要的，但是如何确定曝光系数是设计色调映射时的一个棘手问题。一般来说，色调映射应当以一种确定的曝光方式映射整个场景，这种色调映射是一种”全局色调映射“；另一种”局部色调映射“则对不同区域的像素使用不同的曝光系数。实时渲染中一般都使用全局色调映射。

对颜色的非线性映射可能会产生饱和度与色调的偏移，尽管这种偏移有助于抵消亨特效应，但现代的色调映射还是倾向于消除这种偏移并在色调映射之后使用额外的颜色校正。

对亮度的映射几乎不产生饱和度与色调的偏移，但亮度可能会超出显示器的色域，需要映射回色域范围。

### 8. 基于物理的着色

#### 8.1 物理光照

在物理光学中，光被描述为一种横波（电磁波），是一种垂直于传播方向、使电场和磁场振动的波。电场和磁场的振动是相互激发的，它们的矢量相互垂直且长度的比值固定为相位速度。

现实中大多数的光都是非偏振光，也就是电场和磁场的振动会沿着垂直于传播轴的各个方向均匀分布。光在真空中的相位速度为*c*，约为$300,000 km/s$，常被称为“光速”。光波带有能量，能量流的密度（能流密度）等于电场大小和磁场大小的乘积。在渲染领域中更关注“平均能流密度”（辐照度，单位面积上的辐射通量），它与波幅的平方成正比，用$E$表示。

光波是线性叠加的，这可能看起来和辐照度的描述相矛盾，有时也确实会出现诸如“1+1=4”这样的情况。举例来说，将$n$个仅相位不同的单色光波叠加，当它们刚好相差若干个波长时，它们叠加得到的光波波幅也达到了原来的$n$倍（相长干涉），辐照度也就变成了原来的$n^2$倍；当它们互相抵消时（比如依次相差半个波长），叠加的波幅为零（相消干涉），辐照度也为零；某种特殊的情况下，它们叠加的波幅刚好是原来的$\sqrt{n}$倍，则辐照度也就变成了原来的$n$倍。同样的，这也并不违背能量守恒定律，光波在空间中的叠加会使某些区域上的能量大于各光波能量的线性和，在另外一些区域上则会小于各光波能量的线性和，它们相互抵消，最终表现为各光波的能量总和不变。

> 电磁波或光波是粒子相互碰撞时，电子绕原子核振动时产生的波动。
> 
> 电子振动的周长决定了电子发出的电磁波或光波的波长；电子振动的时间周期决定了电子发出的电磁波或光波的周期频率；电子振动速度几乎等同于光速；电磁波或光波是电子的周期性运动带动时空运动产生的波动或粒子，并不是电子本身。

当物体中的电子振动时就会产生光波，引起振荡的能量（热能、电能、化学能等）就转换为了光能，从物体中辐射出去。在渲染中，这类向外辐射光能的物体就是光源。光波一旦被发射出去，就会在空间中不断传播，直到遇到其他物质。光波和绝大多数物质的作用都是简单的，光波的电场会带动物质中的电子振动，振动的电子又会产生新的光波向外辐射，这就表现为入射光波的一部分能量被调转了方向，也就是所谓的“散射”，是最常见的一种光学现象。

散射光波的频率是和原始光波相同的。一般情况下，原始光波包含了各种频率的光波，每一种频率的光波都单独地和物质发生作用。一种频率的入射光波能量对另一种频率的出射光波能量没用贡献，除了极少数的光致发光现象（荧光、磷光）。

一个孤立的分子会向各个方向散射光波，但在不同方向上有强度的变化。大部分光波都沿着靠近原始传播的方向散射，包括正向和反向的散射。分子附近的光波被散射的可能性很大程度上受波长的影响，短波比长波更可能被散射。

实际渲染中更关注于大量分子的集合体，其所体现的与光波的相互作用可能与孤立的分子不同。来自于附近分子的散射光波通常是相干的，也就表现为光的干涉（因为有相同的入射光）。

#### 8.2 粒子模型

在理想气体中，分子做无规则运动且不会产生相互作用。这种模型下，不同分子散射光波的相位差是随机的且不断变化的，也就表现为不同散射光波之间的不相干，能量上呈线性叠加。换句话说，这种模型下由$n$个分子散射的光波能量就是单个分子的$n$倍。

另一种情况下，如果分子被紧密地排列成小于光波波长的一个个小簇，那么每个分子簇散射的光波就是相干的，则散射的光波能量会随光波数量的增长呈平方级增加。也就是说，一小簇聚在一起的分子会散射出$n$倍于理想气体中同等数量分子散射的光波能量。

以上两种情况说明，对于立方米体积中固定的分子密度来说，将分子聚成簇可以显著增加散射光的强度。在整体分子密度不变的情形下继续增大分子簇，可以进一步增强散射光的强度，直到分子簇的直径接近光的波长。当分子簇的直径超过波长后，再增加分子簇直径并不会增强散射光的强度。这种现象解释了云层和雾的散射效果，它们实质上是由空气中的水分子聚集形成的分子簇，即使空气中的水分子密度不变，云和雾也可以形成强烈的光线散射效果。

这类基于粒子模型的散射被称为大气的“瑞利散射”（Rayleigh scattering）或者固体颗粒的“丁达尔散射”（Tyndall scattering）。

当大气中的分子簇（粒子）直径继续增大到超过波长时，散射特性会发生改变，散射的光线向前方比向后方更强，且对波长的依赖性降低，直到所有可见光都可以均匀地散射。这类散射被称为“米氏散射”（Mie scattering）。

#### 8.3 介质模型

另一种重要的情形是穿过均匀介质（具有均匀间隔的同种分子形成的区域）的光线传播。介质中的分子不要求像在晶体中那样完全规则，不含有气泡和间隙的液体或非晶体纯净物，都可以是光学均匀的介质。

在均匀介质中，散射光波排列整齐，在除了初始传播方向的其他所有方向上都是非相干的。原始光波与所有散射的光波结合后，基本和原始光波相同，除了相位速度以及某些情形下的振幅可能略有区别。最终体现为未发生任何的散射现象，因为散射现象被非相干性抑制了。

原始光波的相位速度和新光波的相位速度的比值定义了该介质的一种光学特性——折射率（IOR），用$n$表示。一些介质具有吸收特性，它们会将部分光波能量转换为热能，从而使得介质中的光波振幅随行进距离呈指数级下降，下降的速率用衰减系数（attenuation index）定义，用$\kappa$表示。不同波长光的$n和\kappa$都不相同，这两个数值定义了不同介质对特定波长光波的作用效果，它们通常结合在一起通过复数$n+i\kappa$表示，被称为复折射率。

介质对光线的吸收会直接影响视觉效果，表现为光线强度的减弱甚至是颜色的变化。

非均匀介质可以当作带有散射粒子的均匀介质。光波的非相干性是由均匀介质中分子的均匀分布引起的，任何局部的分布变化都可以打破这种非相干性。这种局部的分布变化可以是不同类型的分子、气泡或是密度变化。

介质对光线的散射和吸收是与规模有关的。一种介质在小规模下不产生可见的散射，可能会在大规模下产生非常显著的散射效果。比如在空气和水中的光线散射在房间内或杯子中是很难观察到的，但在自然环境中可能会非常显著。

#### 8.4 表面模型

从物理光学角度来看，物体的表面实际上是分离两个具有不同折射率体积的二维平面。最典型的情况下，外层的体积是包含空气的，也就是折射率约为 1.003；内层的体积则需要根据物质构成来确定折射率。

当光波抵达物体表面时，通常由两个因素决定它们之间的作用：表面两侧的物质、表面的几何特征。

首先假设表面是一个理想的完美平面，只考虑表面两侧物质的作用，并将外侧的折射率用$n_1$表示，将内侧的折射率用$n_2$表示。平面对光线的散射是在一种特定的情况下发生的，边界条件是光波的电场与平面平行，也就是光波的电场在物体表面的投影需要保证内外一致，这其中包含了几个隐藏条件：

- 散射的光波和原始光波是同相的，或者 180° 反相；也就是同相时的透射，或者反相时的反射。
- 散射的光波和原始光波是同频的，非偏振光可以看成多个偏振光的组合。
- 当光波从一种介质进入另一种介质时，它的相位速度会随相对折射率（$n_1/n_2$）成比例地变化；由于频率不变，所以波长也随之变化。

折射光线与法线的夹角$\theta_t$符合斯涅尔定律：$sin(\theta_t)=\frac{n_1}{n_2}sin(\theta_i)$

即使不透明的物体也会发生折射。光线折射进金属内部后，会被金属内部的大量自由电子吸收，重新向反射的方向辐射出去，所以金属同时具备高吸收率和高反射率。

除了发生突变的折射以外，也有折射率发生缓慢变动的情形，例如温度变化引起的空气密度变化就会产生热流扰动。

即使是具有良好定义边界的物体，如果被浸没在具有完全相同折射率的物质中也会变得表面不可见。没有折射率的变化就没有反射和折射现象。

除了表面两侧物质的作用，另一个决定因素是表面的几何特征。比波长小的不规则性并不会影响光照效果；而比波长大得多的不规则性只会将局部表面倾斜，同样也不会影响光照效果；只用不规则平面的尺度在 1~100 倍波长的情况下，会使得表面看上去和理想平面很不一样，因为会产生衍射效应。

渲染领域中一般使用几何光学，也就是不考虑干涉、衍射之类的波动效应。这相当于假定了物体表面的不规则性都是小于波长或者远大于波长的。

即使是远大于波长的尺度，很多时候对于一个屏幕像素来说还是太小了，但光线又是从各个方向汇聚而来的，所以渲染中一般用统计学方式来描述微小几何结构的不规则性对宏观表面的影响，也就是微尺度的粗糙度。

**次表面散射**：进入金属表面的大部分物体会被反射出去，少部分折射进入内部的光线也会被快速吸收。但对于非金属物体来说，光线的散射和吸收就有很大的差别。散射程度和吸收率比较低的物质就会呈现为透明或者半透明，折射进入内部的光线会穿透整个物体；光线进入不透明的物体后会在发生多次散射和吸收后，重新从表面出去，这种现象被称为次表面散射。

光线离开表面时的位置可能距离入射点很近也可能较远，这主要取决于物质的散射特性。当着色尺度（像素尺寸或者采样点间距）大于这种距离时，可以当作光线从入射点射出，这样可以很容易地在光照着色模型中使用额外的反射项来描述。高光项（specular term）是用来描述表面反射的，漫反射项（diffuse term）是用来描述局部次表面散射的。但如果着色尺度小于入射点和出射点之间的距离，就需要专门处理这种视觉效果，被称为“全局次表面散射”技术。

#### 8.5 物理相机

实际上的相机会在针孔相机的孔径处使用一块较大的镜头来增加进光量，这样可以得到更好和更可控的光线效果，但是也会产生景深的限制。

#### 8.6 BRDF

渲染中，一个典型的场景是由一堆处于某种介质中的物体构成的。大部分情况下，这种介质都是干净的空气，并不会对光线的辐射度传播产生影响；但有时候介质会明显地影响光线辐射度的传播，这种介质被称为“参与介质”。当不考虑参与介质时，进入相机的辐射度等同于离开物体时的辐射度，即$L_i(\textbf{c},-\textbf{v})=L_o(\textbf{p},\textbf{v})$

物体表面的局部反射由双向反射分布函数（BRDF）描述，记作$f(\textbf{l},\textbf{v})$

由于入射方向和出射方向各需要两个自由度，所以 BRDF 函数一般需要四个标量值作为变量。各向同性的 BRDF 是一类特殊的 BRDF，入射和出射方向关于面法线旋转时不变，所以只需要三个标量值（可以只记录一个光线和视线方向在平面上的夹角）。不同波长的处理有两种方法，一种是将其作为额外的输入参数，多见于离线渲染中；另一种是将返回值作为光谱分布值，实时渲染中常使用 RGB 值作为返回值。结合反射方程，就可以得到：

$L_o(\textbf{p},\textbf{v})=\int_{\textbf{l}\in\Omega}f(\textbf{l},\textbf{v})L_i(\textbf{p},\textbf{l})(\textbf{n}\cdot\textbf{l})d\textbf{l}$

其中$\Omega$是面法线所指向的半球面。

（省略$\textbf{p}$）展开得到：

$L_o(\theta_o,\phi_o)=\int_{\phi_i=0}^{2\pi}\int_{\theta_i=0}^{\pi/2}f(\theta_i,\phi_i,\theta_o,\phi_o)L(\theta_i,\phi_i)cos\theta_isin\theta_id\theta_id\phi_i$

物理上，BRDF 有两个约束条件。一个是赫尔姆霍兹互易性（_Helmholtz reciprocity_），即$f(\textbf{l},\textbf{v})=f(\textbf{v},\textbf{l})$；另一个是能量守恒，射出的能量不多于射入的能量。

定向半球反射率（_directional-hemispherical reflectance_）$R(\textbf{l})$是一个与 BRDF 相关的函数，可以用于度量 BRDF 是否能量守恒。$R(\textbf{l})$度量来自特定方向入射光线的全部反射能量：

$R(\textbf{l})=\int_{\textbf{v}\in\Omega}f(\textbf{l},\textbf{v})(\textbf{n}\cdot\textbf{v})d\textbf{v}$

另一种高度相似的度量是半球定向反射率（_hemispherical-directional reflectance_）：

$R(\textbf{v})=\int_{\textbf{l}\in\Omega}f(\textbf{l},\textbf{v})(\textbf{n}\cdot\textbf{l})d\textbf{l}$

因为 BRDF 的互易性，上述两种反射率其实是等价的。另外，根据能量守恒，$R(\textbf{l})$应当在[0,1]范围内，取 0 表示完全吸收所有光线，取 1 表示完全反射所有光线。

正如 BRDF 与波长相关，$R(\textbf{l})$实际上也与波长相关，所以实际使用时通过 RGB 值来表示，也就是当作颜色来处理。

最简单的 BRDF 模型是兰伯特模型（Lambertian），是一个常值模型，经常用在实时渲染中表示局部次表面散射。兰伯特模型的定向半球反射率也是一个常数，结合兰伯特自身的 BRDF，可以得到：$R(\textbf{l})=\pi f(\textbf{l},\textbf{v})$

注：$\int_{\textbf{v}\in\Omega}(\textbf{n}\cdot\textbf{v})d\textbf{v}=\pi$

其中的兰伯特 BRDF（$f(\textbf{l},\textbf{v})$）常用漫反射颜色$\textbf{c}_{diff}$或者反照率（_albedo_）$\rho$表示，本节中统一使用“次表面反射率”$\rho_{ss}$表示，所以漫反射的 BRDF 表述为：$f(\textbf{l}.\textbf{v})=\frac{\rho_{ss}}{\pi}$

#### 8.7 局部光照

在局部光照（Local illumination）中，入射光$L_i(\textbf{l})$通常都是给定的，不需要计算。

实际上，入射光$L_i(\textbf{l})$是来自于各个方向的非零辐射，或直接来自于光源，或是从其他物体表面反射而来。 现实中的光源通常是面光源，出于需要，本小节的内容只在平行光和点光源下讨论。尽管平行光和点光源是不物理正确的一种抽象模型，但它们可以近似派生出物理光源，这种派生可以让我们在基于物理的渲染框架下继续使用这种模型，并且把握它们可能产生的误差。

取一个小的远距离面光源，用$\textbf{l}_c$表示物体表面指向光源中心的向量，用$\textbf{c}_{light}$表示从正对光源（$\textbf{n}=\textbf{l}_c$）的纯白兰伯特表面得到的反射辐射度。这是一种直观的描述，因为颜色实际上与视觉效果相关。

有了上述的定义，平行光就可以被认为是限制了光源大小，但保持$\textbf{c}_{light}$不变的面光源。这样，反射方程的积分就可以被简化为数值计算：$L_o(\textbf{v})=\pi f(\textbf{l}_c,\textbf{v})\textbf{c}_{light}(\textbf{n}\cdot\textbf{l}_c)$

注：乘以$\pi$抵消了 BRDF 中除掉的$\pi$，这样可以减少计算（不需要积分），也便于阅读。

点光源也是相似的处理，但需要考虑$\textbf{c}_{light}$的平方反比衰减。对于多个点光源，可以得到：

$L_o(\textbf{v})=\pi\underset{i=1}{\overset{n}{\sum}}f(\textbf{l}_{c_i},\textbf{v})\textbf{c}_{light_i}(\textbf{n}\cdot\textbf{l}_{c_i})^+$

#### 8.8 菲涅尔反射

物体表面是周围相关介质的交界面，比如空气和物体材质。光线和交界面的交互关系由 Fresnel 给出，Fresnel 方程描述了几何光学在平面上的交互作用。

入射光线分成反射和折射两个部分，用$\textbf{r}_i$表示反射光方向，用$\textbf{l}$表示入射光方向：

$\textbf{r}_i=2(\textbf{n}\cdot\textbf{l})\textbf{n}-\textbf{l}$

以下讨论沿用讨论折射率时的标记，即$n_1$表示上层材质的折射率；$n_2$表示下层材质的折射率。

**外反射**：当$n_1<n_2$时发生外反射，即光线进来的材质折射率较低时，发生外反射；大部分物体表面发生的都是外反射。与之相反的是内反射，比如光线从物体内部进入空气中时。

实际上菲涅尔函数随光谱变化，但在渲染中通常当作 RGB 处理。菲涅尔函数$F(\theta_i)$有如下特性：

- 当入射角$\theta_i=0\degree$时，即入射光线垂直于表面（$\textbf{l}=\textbf{n}$）时，$F(\theta_i)$可以当作是材质的一项基本属性，这里可以把$F_0$理解为是材质的高光颜色。
- 当$\theta_i$逐渐增大时，$F(\theta_i)$也相应增大，直到$\theta_i=90\degree$时增大至 1。

对于镜面反射来说，出射角等同于入射角，这意味着当镜面和入射光线处于一个掠射角（$\theta_i\rightarrow 90\degree$）时，也会和视线处于掠射角。因此，菲涅尔反射的增大多见于物体的边缘处。更进一步，由于相机的透视，菲涅尔反射的陡增只会体现为很少的几个像素，为了更好地描述菲涅尔的视觉效果，通常使用入射角的正弦值（$sin(\theta_i)$），因此，菲涅尔函数可以用$F(\textbf{n},\textbf{l})$表示。

由于菲涅尔方程的复杂性，比如需要可见光谱的复折射率，实际运用中通常使用 Schlick 近似：

$F(\textbf{n},\textbf{l})\approx F_0+(1-F_0)(1-(\textbf{n}\cdot\textbf{l})^+)^5$

该近似函数对白色和$F_0$之间做了 RGB 插值。

对于一些金属材质，Schlick 近似没有那么准确，可以考虑使用 Gulbrandsen 近似，但运算开销更大。

Schlick 近似公式中只需要设定$F_0$即可，既可以直接设置颜色，也可以通过折射率计算。对于空气中的物体，可以假设$n_1=1$，用$n$表示物体材质的折射率，则$F_0=(\frac{n-1}{n+1})^2$。该计算对于复折射率也有效。

在实际应用中，也经常会使用另一种 Schlick 近似：

$F(\textbf{n},\textbf{l})\approx F_0+(F_{90}-F_0)(1-(\textbf{n}\cdot\textbf{l})^+)^{\frac{1}{p}}$

该近似公式使得掠射角颜色可以控制。

根据光学特性，材质一般分成三种类别：电介质（绝缘体）、金属（导体）和半导体。

当物体不是被空气包围，那就需要同时考虑两种介质的折射率了，更完备的表述$F_0=(\frac{n_1-n_2}{n_1+n_2})^2$。

**参数化菲涅尔值**：常用的参数化方法是将高光颜色$F_0$和漫反射颜色$\rho_{ss}$结合到一起。主要是利用了金属几乎没有漫反射，而电介质的$F_0$被限制在一个特定的小范围内。参数化方法主要包括表面颜色（RGB 值）$\textbf{c}_{surf}$和金属度$m$。如果$m=1$，则$F_0=\textbf{c}_{surf}$且$\rho_{ss}$被设为黑色；如果$m=0$，则$F_0$被设为相应电介质值且$\rho_{ss}=\textbf{c}_{surf}$。

使用金属度来描述菲涅尔反射和漫反射效果也有缺陷，比如无法描述清漆电介质的高光颜色；金属和电介质材质的边缘处也会出现瑕疵。

另一种参数化方法的使用技巧是基于“除清漆材质外，没有其他材料的$F_0$低于 0.02”。该方法用于抑制空腔或者空洞区域的高光，避免了使用高光遮蔽纹理。该技巧被用于虚幻和寒霜引擎。

**内反射**：当$n_1>n_2$时发生内反射。根据 Snell 定律，当入射角$\theta_i$大于某个关键值$\theta_c$时，折射角$\theta_t$可能会大于 1，这是不可能的，所以会发生**全内反射**。

内反射只会发生在电介质中，因为金属和半导体都会快速吸收掉光线。根据折射率可以直接算出关键值$\theta_c$：

$sin\theta_c=\frac{n2}{n1}=\frac{1-\sqrt{F_0}}{1+\sqrt{F_0}}$

对于内反射，Schlick 近似仍然是适用的，只需要交换$\theta_t和\theta_i$即可。

#### 8.9 微几何

每一个可见的微表面点都包含了许多微表面法线将光线反射向各个方向。由于单个微表面的朝向是随机的，所以对它们整体的统计学分布建模更合适。对于大多数表面来说，微几何表面法线的分布是连续的，峰值位于宏观表面的法线方向。法线分布的“峰度”反映了表面的粗糙程度，越是粗糙的表面，其微几何表面法线的分布峰度越低。

对于大部分表面来说，微表面的法线分布是各向同性的，即具有旋转对称性，不具有方向性。其它的表面被称为“各向异性”表面，具有反射或高光的方向性模糊。有些表面具有高度结构化的微几何，会产生各种各样的微尺度法线分布。织物是最常见的例子，天鹅绒和绸缎的独特外观就是由于它们独特的微几何结构。

对于所有的表面类型来说，当入射角增大时，不规则微表面的可见尺寸就会减小。当入射角增大到掠射角时，不规则微表面就会减小到低于波长而“消失”。这个特性和菲涅尔效果叠加，就会使得物体表面在掠射角下看上去像是镜面。

被遮挡的光线并不会消失，大部分都被反射到其他的微几何上了，光线在进入相机前通常会经历多次弹射。由于每次菲涅尔反射都会使能量衰减，所以微几何之间的反射不易处理。由于金属材质缺少次表面散射，多次弹射的反射是其漫反射的来源。有色金属的多次弹射反射，颜色会比主反射更深。

在一些情况下，微表面细节可能也会影响次表面散射。当微几何的不规则面比次表面距离更大的时候，阴影和遮挡会引起“回射”现象，也就是光线会从进入的方向原路返回。这是由于阴影和遮挡会遮蔽掉与视线方向不一致的光线。回射现象会使粗糙的表面看上去平坦光滑。

#### 8.10 微平面理论

微平面（microfacet）理论是对微几何按微平面集合建模的理论。每一个微平面都有自己的法线$\textbf{m}$，微平面依据 micro-BRDF$f_\mu(\textbf{l},\textbf{v},\textbf{m})$各自独立地反射光线，所有的反射汇总后形成宏观表面的 BRDF。微平面通常选用完美菲涅尔镜面，也就是镜面微平面 BRDF 模型；当然也可以选用其他的微平面模型，比如漫反射 micro-BRDF 模型常被用于次表面散射模型，衍射 micro-BRDF 模型常被用于结合几何光学与波动光学。

对于微平面模型很重要的一个属性是其微平面法线的统计分布。该统计分布通过表面的法线分布函数（_normal distribution function, NDF_）定义，使用$D(\textbf{m})$表示。法线分布函数描述一块微几何表面区域上的微平面法线分布，它在整个微平面法线球上的积分是这块微表面的面积；换句话说，对$D(\textbf{m})(\textbf{n}\cdot\textbf{m})$的积分，也就是$D(\textbf{m})$在宏观表面上的投影平面，得到的就是面积为 1 个单位的区域：

$\int_{m\in\Theta}D(\textbf{m})(\textbf{n}\cdot\textbf{m})d\textbf{m}=1$

该积分是在整个球面上的积分，所以积分域用$\Theta$表示。实际上，大部分微结构模型都是高度场，也就意味着对于半球面上任何方向来说，$D(\textbf{m})=0$。

更一般地，微表面和宏观表面在垂直于视线方向的平面上的投影是相等的：

$\int_{m\in\Theta}D(\textbf{m})(\textbf{v}\cdot\textbf{m})d\textbf{m}=\textbf{v}\cdot\textbf{n}$

上述两个方程是对 NDF 的约束条件。

尽管微平面在投影上会相互覆盖，实质上渲染只关心最终可见的微平面，这给投影微平面和投影宏观平面提供了联系：可见微平面的投影面积和等于宏观表面的投影面积。可以通过数学语言来描述，定义遮挡函数*masking function* $G_1(\textbf{m},\textbf{v})$，描述法线为$\textbf{m}$的微平面在视线方向可以被看到的比例。则可以得到：

$\int_{m\in\Theta}G_1(\textbf{m},\textbf{v})D(\textbf{m})(\textbf{v}\cdot\textbf{m})^+d\textbf{m}=\textbf{v}\cdot\textbf{n}$

式中的$G_1(\textbf{m},\textbf{v})D(\textbf{m})$是可见法线的分布。

Heitz 在论文中指出，只有 Smith 函数和 Torrance-Sparrow 的“V=cavity”函数是遵守第三个方程的，因而是数学上有效的。Heitz 还证明了 Smith 函数更接近于随机微平面的分布，并且 Smith 遮挡函数也是唯一可以遵守第三个方程的同时维持法线和遮挡之间的独立性，这意味着只要$\textbf{m}$不是背面，$G_1$就不依赖于$\textbf{m}$的方向。Smith $G_1$函数表示为：

$G_1(\textbf{m},\textbf{v})=\frac{\chi^+(\textbf{m}\cdot\textbf{v})}{1+\Lambda(\textbf{v})}$

其中，$\chi^+(x)$是正特征函数：

$\chi^+(x)=\left\{\begin{matrix}1,&{where\quad x>0,}\\0,&{where\quad x\leq0.}\end{matrix}\right.$

而$\Lambda$函数则根据不同的 NDF 而有所区别。如何从给定的 NDF 推导出相应的$\Lambda$函数可以参考 Walter 和 Heitz 的论文。

Smith 的遮挡函数（masking function）也有一些缺陷。从理论角度看，其要求与实际表面结构并不一致，甚至可能在物理上是无法实现的。从实践角度看，虽然它和随机表面的分布非常接近，但对于一些法线方向和遮挡之间有较强依赖的表面，它的精度就会下降，特别是对于有着重复结构的表面（比如织物）。尽管如此，除非有更好的选择，它仍然是目前渲染应用中最合适的模型。

当有了 micro-BRDF$f_\mu(\textbf{l},\textbf{v},\textbf{m})$，有了法线分布函数$D(\textbf{m})$，以及遮挡函数$G_1(\textbf{m},\textbf{v})$后，整体的宏观表面 BRDF 可以推导出：

$f(\textbf{l},\textbf{v})=\int_{m\in\Omega}f_\mu(\textbf{l},\textbf{v},\textbf{m})G_2(\textbf{l},\textbf{v},\textbf{m})D(\textbf{m})\frac{(\textbf{m}\cdot\textbf{l})^+}{|{\textbf{n}\cdot\textbf{l}}|}\frac{(\textbf{m}\cdot\textbf{v})^+}{|{\textbf{n}\cdot\textbf{v}}|}d\textbf{m}$

积分区域是以$\textbf{n}$为中心的半球面$\Omega$，可以避免对表面下半部分的积分。这里并没有用遮挡函数$G_1$而是采用它的伴随遮挡-阴影函数$G_2$。它是从$G_1$导出的，可以给出在$\textbf{v}$和$\textbf{l}$方向上以$\textbf{m}$为法线的微平面的可见比例，这样可以同时考虑到遮挡和阴影，但仍然没有考虑进微平面之间的相互反射。微平面之间相互反射的缺失是所有由该式导出的 BRDF 模型的缺陷，这会使得该类 BRDF 模型最终略微有些偏暗。

Heitz 给出了几种不同的$G_2$函数，其中最简单的是可分离的形式，也就是用$G_1$单独计算遮挡和阴影，最后再乘到一起：

$G_2(\textbf{l},\textbf{v},\textbf{m})=G_1(\textbf{v},\textbf{m})G_1(\textbf{l},\textbf{m})$

这种独立形式相当于假定了遮挡和阴影之间没有任何联系，但实际上不是，所以这种假设也会使得最终得到 BRDF 模型偏暗。

考虑一个极端的例子，当视线方向和光线方向重合时，$G_2$应当等同于$G_1$，也就是所有能看到的微平面都不会处于阴影中，但使用独立形式得到的$G_2$实际上等于$G_1^2$。

如果微表面是用高度场表示的，这是一种很常见的情形，那么当$\textbf{v}$和$\textbf{l}$之间的相对方位角$\phi$等于$0\degree$时，$G_2(\textbf{l},\textbf{v},\textbf{m})$应当等于$min(G_1(\textbf{v},\textbf{m}),G_1(\textbf{l},\textbf{m}))$，这提供了两者之间的关联用于修正：

$G_2(\textbf{l},\textbf{v},\textbf{m})=\lambda(\phi)G_1(\textbf{v},\textbf{m})G_1(\textbf{\textbf{l},\textbf{m}})+(1-\lambda(\phi))min(G_1(\textbf{v},\textbf{m}),G_1(\textbf{l},\textbf{m}))$

其中，$\lambda(\phi)$是一个随着$\phi$增大而从 0 增大到 1 的函数。Ashikhmin 等人推荐使用$15\degree$的高斯函数：

$\lambda(\phi)=1-e^{-7.3\phi^2}$

另一种常用的是 Ginneken 等人提出的：

$\lambda(\phi)=\frac{4.41\phi}{4.41\phi+1}$

除了光线方向和视线方向的重合，还有另一种关联遮挡和阴影的因素，它们都与表面剩下部分的相对高度有关。阴影和遮挡的概率都会随高度的下降而增加。可以通过*Smith 关联高度的遮挡-阴影函数*描述：

$G_2(\textbf{l},\textbf{v},\textbf{m})=\frac{\chi^+(\textbf{m}\cdot\textbf{v})\chi^+(\textbf{m}\cdot\textbf{l})}{1+\Lambda(\textbf{v})+\Lambda(\textbf{l})}$

Heitz 也给出了一种结合了方向和高度关系的 Smith$G_2$函数：

$G_2(\textbf{l},\textbf{v},\textbf{m})=\frac{\chi^+(\textbf{m}\cdot\textbf{v})\chi^+(\textbf{m}\cdot\textbf{l})}{1+max(\Lambda(\textbf{v}),\Lambda(\textbf{l}))+\lambda(\textbf{v},\textbf{l})min(\Lambda(\textbf{v}),\Lambda(\textbf{l}))}$

以上这些方案中，Heitz 最推荐的是倒数第二个的关联高度的版本。它和无关联版本的计算开销相似，但精确性有了较大提升。所以这也是使用很广的一个形式。

虽然可以推导出宏观表面 BRDF 的表示，但实际渲染中一般不直接使用该式，而是使用由其导出的封闭形式的解，或者一种近似解。下节中将着重介绍。

#### 8.11 BRDF 表面反射模型

基于物理的渲染中，几乎所有的镜面 BRDF 项都是从微平面理论中导出的。在镜面反射中，每一个微平面都是理想的光滑菲涅尔镜面。这意味着只用当视线方向与反射方向平行时，才有不为零的 micro-BRDF $f_\mu(\textbf{l},\textbf{v},\textbf{m})$。这相当于衡量微平面法线$\textbf{m}$和半角方向$\textbf{h}$的对齐程度，其中$\textbf{h}=\frac{\textbf{l}+\textbf{v}}{|{\textbf{l}+\textbf{v}}|}$

那么在积分过程中，只需要考虑$\textbf{m=h}$的情形即可：

$f_{spec}(\textbf{l},\textbf{v})=\frac{F(\textbf{h},\textbf{l})G_2(\textbf{l},\textbf{v},\textbf{h})D(\textbf{h})}{4|{\textbf{n}\cdot\textbf{l}}||{\textbf{n}\cdot\textbf{v}}|}$

下标“spec”表示这只是镜面反射项，因为完整的 BRDF 中通常还包含漫反射（次表面散射）项。微平面的镜面反射只会发生在那些法线方向和半角方向相同的微平面上，这个微平面的数量由式中的微平面法线分布函数$D(\textbf{h})$决定；具体有多少光线可以被看见，则有遮挡-阴影函数$G_2$决定；以及每个微平面的反射占比，则由菲涅尔反射函数$F$控制。由于半角范围不会大于$90\degree$，所以$\chi^+$可以被简化移除。

NDF 固然对表面的粗糙度、高光有着重要影响，但镜面 lobe 并不是简单地复制 NDF 的形状。高光的形状会受到表面曲度和观察视角的影响，当从掠射角观察平面上的高光时，高光区域会被剧烈拉伸。

**各向同性的 NDF**：渲染中使用的大部分 NDF 都是各向同性的，也就是关于宏观表面法线$\textbf{n}$具有旋转对称性。这种情况下，NDF 只需要一个参数，也就是宏观法线和微平面法线之间的夹角$\theta_m$。理想情况下，NDF 可以用$cos\theta_m$表示，也就是使用$\textbf{n}\cdot\textbf{m}$快速得到。

---

Beckmann NDF 是使用最早的 NDF，也是 Cook-Torrance BRDF 中使用的 NDF，它的表述形式为：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})}{\pi\alpha_b^2(\textbf{n}\cdot\textbf{m})^4}exp(\frac{(\textbf{n}\cdot\textbf{m})^2-1}{\alpha_b^2(\textbf{n}\cdot\textbf{m})^2})$

其中的$\chi^+$项用于将所有指向宏观之下的微平面法线置为 0，这也能说明该 NDF 是描述了一个高度场微表面。$\alpha_b$则用于控制表面的粗糙程度，它与微几何表面斜率的均方根成比例，$\alpha_b=0$则表示这是一个完美的光滑表面。

为了导出 Beckmann NDF 对应的 Smith $G_2$函数，就需要先求出相应的$\Lambda$函数。由于 Beckmann NDF 是形状不变的函数，这简化了$\Lambda$函数的导出。根据 Heitz 的定义，各向同性的 NDF 是形状不变的，就是指对粗糙度的调整等同于对微表面尺度的调整。这类形状不变的 NDF 可以表述为：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})}{\alpha^2(\textbf{n}\cdot\textbf{m})^4}g(\frac{\sqrt{1-(\textbf{n}\cdot\textbf{m})^2}}{\alpha(\textbf{n}\cdot\textbf{m})})$

其中，$g$表示一个任意的单变量函数。对于任意的各向同性 NDF，其$\Lambda$函数依赖于两个变量，第一个是粗糙度$\alpha$，第二个是所需要的入射角（$\textbf{v}或者\textbf{l}$）。对于形状不变的 NDF，$\Lambda$就只需要一个变量$a=\frac{\textbf{n}\cdot\textbf{s}}{\alpha\sqrt{1-(\textbf{n}\cdot\textbf{s})^2}}$

其中，$\textbf{s}$是所需要的入射角（$\textbf{v}或者\textbf{l}$），通过计算$a$就只需要一个变量来描述$\Lambda$函数，这种单变量的函数更容易使用曲线来拟合，也可以用一维数组来制成表格。

这样就可以得到 Beckmann NDF 的$\Lambda$函数：

$\Lambda(a)=\frac{erf(a)-1}{2}+\frac{1}{2a\sqrt{\pi}}exp(-a^2)$

显然，上式的计算开销很大，而且其中还包含了误差函数$erf$。所以一般使用近似式：

$\Lambda(a)\approx\left\{\begin{matrix}\frac{1-1.259a+0.396a^2}{3.535a+2.181a^2}&{where\quad a<1.6,}\\0,&{where\quad a\geq1.6.}\end{matrix}\right.$

---

Blinn-Phong NDF 的优势是计算开销很低，它的表述形式为：

$D(\textbf{m})=\chi^+(\textbf{n}\cdot\textbf{m})\frac{\alpha_p+2}{2\pi}(\textbf{n}\cdot\textbf{m})^{\alpha_p}$

其中，$\alpha_p$是 Phong NDF 的粗糙度参数，值越大则表面越光滑（$\alpha_p=\infin$表示完美镜面），值越低则表面越粗糙。由于$\alpha_p$并不均匀，所以不适合用于直接控制表面粗糙程度，通常使用导出值$\alpha_p=m^s$来表示粗糙程度，其中$s$在 0~1 之间，而$m$则是$\alpha_p$的取值上限（比如 COD 黑色行动中，$m$就取值为 8192）。Blinn-Phong 和 Beckmann 的$\alpha$值也可以联系起来：$\alpha_p=2\alpha_b^2-2$

Blinn-Phong NDF 并不是形状不变的，其$\Lambda$函数也没有解析式，Walter 等人建议通过$\alpha_p=2\alpha_b^2-2$来使用 Beckmann 的$\Lambda$函数。

在 Blinn 将 Phong 着色函数引入 NDF 的同一篇 Paper 中，他还提出了另外两种 NDF。通过这三种分布，Blinn 推荐使用从 Trowbridge 和 Reitz 导出的那个 NDF，但当时并没有引起广泛关注。30 年后，Walter 独立发现了 Trowbridge-Reitz 分布，并将它取名为 GGX 分布，从此开始被广泛使用。GGX 分布的表述为：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})\alpha_g^2}{\pi(1+(\textbf{n}\cdot\textbf{m})^2(\alpha_g^2-1))^2}$

其中，$\alpha_g$是粗糙度参数，和 Beckmann NDF 的$\alpha_b$相似。在迪士尼原则的着色模型中，Burley 提出使用$\alpha_g=r^2$，这里的$r$是用户控制的粗糙度参数，范围在 0~1 之间。该方案在使用 GGX 分布的应用中被广泛使用。

GGX 分布是形状不变的，其$\Lambda$函数也较为简洁：

$\Lambda(a)=\frac{-1+\sqrt{1+\frac{1}{a^2}}}{2}$

该式中与$a$相关的部分只有一个$a^2$，恰好避免了$a$本身的开方运算。

由于 GGX 分布以及 Smith 遮挡-阴影函数使用广泛，人们尝试将两者结合起来使用。Lagarde 给出了：

$\frac{G_2(\textbf{l},\textbf{v})}{4|{\textbf{n}\cdot\textbf{l}}||{\textbf{n}\cdot\textbf{v}}|}\Rightarrow\frac{0.5}{\mu_o\sqrt{\alpha^2+\mu_i(\mu_i-\alpha^2\mu_i)}+\mu_i\sqrt{\alpha^2+\mu_o(\mu_o-\alpha^2\mu_o}}$

其中，出于简洁考虑，$\mu_i=(\textbf{n}\cdot\textbf{l})^+\quad\mu_o=(\textbf{n}\cdot\textbf{v})^+$

Karis 提出了一种在 GGX 中使用 Smith $G_1$的近似方法：

$G_1(\textbf{s})\approx\frac{2(\textbf{n}\cdot\textbf{s})}{(\textbf{n}\cdot\textbf{s})(2-\alpha)+\alpha}$

同样的，其中的$\textbf{s}$为$\textbf{l}或\textbf{v}$。Hammon 证明了该$G_1$可以有效地近似$G_2$和镜面微平面 BRDF 的分母：

$\frac{G_2(\textbf{l},\textbf{v})}{4|{\textbf{n}\cdot\textbf{l}}||{\textbf{n}\cdot\textbf{v}}|}\approx\frac{0.5}{lerp(2|{\textbf{n}\cdot\textbf{l}}||{\textbf{n}\cdot\textbf{v}}|,|{\textbf{n}\cdot\textbf{l}}|+|{\textbf{n}\cdot\textbf{v}}|,\alpha)}$

该式使用了线性插值$lerp(x,y,s)=x(1-s)+ys$

GGX 的分布有着更突出的峰值和更长的尾，这在渲染结果上也表现为具有更长的高光拖尾。

Burley 提出了通用的 Trowbridge-Reitz（GTR）NDF，可用于控制 NDF 的形状，特别是对于拖尾的控制：

$D(\textbf{m})=\frac{k(\alpha,\gamma)}{\pi(1+(\textbf{n}\cdot\textbf{m})^2(\alpha_g^2-1))^\gamma}$

其中的$\gamma$参数是用于控制拖尾形状的。当$\gamma=2$时，GTR 和 GGX 相同；当$\gamma$减小，拖尾变长；当$\gamma$增大，拖尾变短；当 $\gamma$很大时，GTR 接近于 Beckmann。$k(\alpha,\gamma)$项是规范化因子，可以表述为：

$k(\alpha,\gamma)=\left\{\begin{matrix}\frac{(\gamma-1)(\alpha^2-1)}{(1-(\alpha^2)^{(1-\gamma)})},&{where\space y\neq1\space and\space\alpha\neq1,}\\\frac{(\alpha^2-1)}{ln(\alpha^2)},&{where\space\gamma\neq1\space and\space\alpha\neq1,}\\1,&{where\space\alpha=1.}\end{matrix}\right.$

GTR 分布并不是形状不变的，这增加了寻找 Smith $G_2$ 遮挡-阴影函数的难度。最后得到的$G_2$函数也是相当复杂，不同的$\gamma$值给出了不同的解析解，使用的时候也需要对它们进行合理插值。GTR 分布的另一个问题是，它的控制参数$\alpha和\gamma$并不是那么直观。

学生 t 分布和指数幂分布的 NDF 也包含形状控制参数，相较于 GTR 来说，它们关于粗糙度参数是形状不变的，它们的应用还有待挖掘。

除了不断增加 NDF 的复杂度外，另一种可选的改进方案是使用多个镜面反射 lobe。该想法由 Cook 和 Torrance 提出，由 Ngan 设计实验验证。Imageworks 使用了一种较为折衷的方案，他们使用两个 GGX NDF 来混合得到目标的 NDF，这样就只需要提供额外的粗糙度和混合系数。

---

**各向异性的 NDF**

为了渲染各向异性材质，就需要支持各向异性的 BRDF，尤其是需要支持各向异性的 NDF。

与各向同性的 NDF 不同，各向异性的 NDF 不能简单地使用一个$\theta_m$来计算，它还需要额外的方向信息。一般情况下，微平面的法线$\textbf{m}$方向需要在局部的切线空间中描述；实际使用中则通过三个独立乘积来表示：$\textbf{m}\cdot\textbf{n},\textbf{m}\cdot\textbf{t},\textbf{m}\cdot\textbf{b}$

当使用各向异性的 BRDF 时，需要确保法线贴图也会同时对切线和副切线产生影响，这一般通过*改进的格拉姆-施密特正交化*来处理。

对于像拉丝金属、卷发这样的材质来说，需要进行逐像素的调节，一般会使用一张切线贴图。切线贴图通常会存储切向量在垂直于法线的平面上的二维投影。这种存储方式可以正常地进行纹理滤波，也可以使用与法线贴图相似的纹理压缩方法。有些应用中会使用标量来存储切向量绕法线的旋转值，虽然这种存储方式更节省空间，但是在纹理滤波中容易产生瑕疵。

获得各向异性 NDF 的一种常见方法是推广已有的各向同性 NDF。这种推广方法可以应用到所有形状不变的各向同性 NDF 上，这也是形状不变的 NDF 备受推荐的另一个原因。

形状不变的各向同性 NDF 的表述为：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})}{\alpha^2(\textbf{n}\cdot\textbf{m})^4}g(\frac{\sqrt{1-(\textbf{n}\cdot\textbf{m})^2}}{\alpha(\textbf{n}\cdot\textbf{m})})$

则，它的各向异性版本表述为：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})}{\alpha_x\alpha_y(\textbf{n}\cdot\textbf{m})^4}g(\frac{\sqrt{\frac{(\textbf{t}\cdot\textbf{m})^2}{\alpha_x^2}+\frac{(\textbf{b}\cdot\textbf{m})^2}{\alpha_y^2}}}{(\textbf{n}\cdot\textbf{m})})$

其中，参数$\alpha_x,\alpha_y$分别表示沿$\textbf{t},\textbf{b}$方向的粗糙度，如果$\alpha_x=\alpha_y$，则退化回各向同性的形式。

各向异性的$G_2$遮挡-阴影函数与各向同性的版本是一样的，只有传入$\Lambda$函数的$a$值的计算有些区别（同样的，其中的$\textbf{s}$表示$\textbf{v}或\textbf{l}$）：

$a=\frac{\textbf{n}\cdot\textbf{s}}{\sqrt{\alpha_x^2(\textbf{t}\cdot\textbf{s})^2+\alpha_y^2(\textbf{b}\cdot\textbf{s})^2}}$

通过以上方式，就可以推导出 Beckmann NDF 和 GGX NDF 的各向异性版本：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})}{\pi\alpha_x\alpha_y(\textbf{n}\cdot\textbf{m})^4}exp(-\frac{\frac{(\textbf{t}\cdot\textbf{m})^2}{\alpha_x^2}+\frac{(\textbf{b}\cdot\textbf{m})^2}{\alpha_y^2}}{(\textbf{n}\cdot\textbf{m})^2})$

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})}{\pi\alpha_x\alpha_y(\frac{(\textbf{t}\cdot\textbf{m})^2}{\alpha_x^2}+\frac{(\textbf{b}\cdot\textbf{m})^2}{\alpha_y^2}+(\textbf{n}\cdot\textbf{m})^2)^2}$

在迪士尼原则的着色模型中，使用各向同性粗糙度参数$r$和另一个 0~1 标量参数$k_{aniso}$，则可以通过这两个值计算出$\alpha_x,\alpha_y$：

$k_{aspect}=\sqrt{1-0.9k_{aniso}}\\\alpha_x=\frac{r^2}{k_{aspect}}\\\alpha_y=r^2k_{aspect}$

其中，0.9 可以将纵横比限制在 10:1。Imageworks 使用了另一种参数化方法，允许任意程度各向异性：

$\alpha_x=r^2(1+k_{aniso})\\\alpha_y=r^2(1-k_{aniso})$

---

**多次弹射的表面反射**

延续之前的讨论，微平面的 BRDF 模型实际上没有考虑微表面间的多次弹射，这会产生能量损失引起表面变暗，特别是粗糙的金属表面。

Imageworks 给出了一种方法，通过在 BRDF 中引入额外的项来模拟微表面之间的多次弹射：

$f_{ms}(\textbf{l},\textbf{v})=\frac{\overline{F}\overline{R_{sF1}}}{\pi(1-\overline{R_{sF1}})(1-\overline{F}(1-\overline{R_{sF1}}))}(1-R_{sF1}(\textbf{l}))(1-R_{sF1}(\textbf{v}))$

其中，$R_{sF1}$是$f_{sF1}$的定向反照率，是将$F_0$设为 1 的镜面反射 BRDF 项。$R_{sF1}$函数依赖于粗糙度$\alpha$和仰角$\theta$。由于该函数足够光滑，所以能预计算后存在一张较小的二维纹理中（Imageworks 认为$32\times32$分辨率的纹理就足够了）。

$\overline{R_{sF1}}$函数是$R_{sF1}$在半球面上的余弦加权平均，它只依赖于$\alpha$，所以能存在一维的纹理中，或者用曲线拟合。由于$R_{sF1}$关于法线旋转对称，所以$\overline{R_{sF1}}$可以通过一维积分计算。一般使用积分变量$\mu=cos\theta$：

$\overline{R_{sF1}}=\frac{\int_{s\in\Omega}R_{sF1}(\textbf{s})(\textbf{n}\cdot\textbf{s})d\textbf{s}}{\int_{s\in\Omega}(\textbf{n}\cdot\textbf{s})d\textbf{s}}=\frac{1}{\pi}\int_{\phi=0}^{2\pi}\int_{\mu=0}^1 R_{sF1}(\mu)\mu d\mu d\phi\\=2\int_{\mu=0}^1 R_{sF1}(\mu)\mu d\mu$

最后，$\overline{F}$是菲涅尔项的余弦加权平均：

$\overline{F}=2\int_{\mu=0}^1 F(\mu)\mu d\mu$

Imageworks 给出了上式的一种闭合形式的解（基于通用 Schlick 形式）：

$\overline{F}=\frac{2p^2F_{90}+(3p+1)F_0}{2p^2+3p+1}$

如果使用的是原版的 Schlick 近似，则可以将上式简化为：

$\overline{F}=\frac{20}{21}F_0+\frac{1}{21}$

在各向异性的情况下，Imageworks 提出使用$\alpha_x,\alpha_y$的中间值来计算$f_{ms}$。该近似方案避免了给$R_{sF1}$增加一个额外维度，且不会引起较大的误差。

#### 8.12 次表面散射的 BRDF 模型

本节讨论不透明电介质材质的局部次表面散射现象的 BRDF 模型。

**次表面反照率**（Subsurface Albedo）

不透明电介质材质的次表面反照率$\rho_{ss}$是指逃离表面的光线能量和进入表面的光线能量的比值。$\rho_{ss}$值在 0~1 之间，0 意味着全部能量被吸收，1 意味着没有能量被吸收。$\rho_{ss}$也和波长有关，所以渲染中使用 RGB 向量来表示。在使用中，$\rho_{ss}$经常被用作“漫反射颜色”或者“表面颜色”，正如菲涅尔反射中的$F_0$经常被用作“高光颜色”。

由于电介质材质通常会将大部分入射的光线折射进内部而不是反射出去，所以次表面反照率$\rho_{ss}$通常会比高光颜色$F_0$更明亮也更显眼。由于产生自不同的物理现象（高光颜色来自于菲涅尔反射，次表面散射来自于内部的吸收），$\rho_{ss}$通常都有着与$F_0$不同的光谱分布，比如红色塑料球却有着白色的高光。

次表面反照率可以被当作是吸收和散射的竞争，光线是否会在散射出物体内部之前被完全吸收？新雪是一个很好的例子，它通常有着很亮的反照率，这是由于雪粒和空气之间发生了大量的散射，但吸收却很少，这使得次表面反照率能达到 0.8 甚至更高，而白色油漆也不过只有 0.7 的反照率。混凝土、石头、泥土的平均反照率大约在 0.15~0.4；煤炭是一种反照率极低的材料，接近 0。当物体被弄湿了，通常会显得更暗（特别是多孔材质），这是由于此时电介质材料的折射系数更接近于水的折射系数而不是空气，这种相对折射率的下降将减少材质内部的光线散射，光线在离开物体之前也需要经过更长的距离。

有一种长期的误解是，真实材质的$\rho_{ss}$值不能低于某个下限（大约是 0.015~0.03）。实际上的材质可能有更低的$\rho_{ss}$值，比如联邦标准的“OSHA Black”的 Y 值大约只有 0.35（最高是 100），当给定测量条件和表面光泽度后，该 Y 值对应于$\rho_{ss}$值约为 0.0035。

当从现实中的物体表面测出$\rho_{ss}$值后，很重要的一点是分离出其中的镜面反射，可以通过仔细地控制照明和偏振滤波器实现。为了得到精准地颜色，还需要进行色彩的校正。

并不是所有的 RGB 值都有对应的$\rho_{ss}$，反射光谱的限制很大，任何波长的值都不能超过 1，且它们的曲线都非常光滑，这些限制使得即使是较小的 sRGB 颜色也可能反射出超出范围的颜色，所以需要谨慎地设置$\rho_{ss}$值，避免出现过饱和或者过曝的颜色。除了真实性受损外，也可能会对预计算全局光照产生影响。

**粗糙度和次表面散射的尺度**

一些局部次表面散射的 BRDF 模型会考虑进表面的粗糙度，比如使用具有漫反射 micro-BRDF $f_\mu$的微平面理论。选择使用哪种模型的决定因素是表面不规则性与次表面距离的相对大小。

- 如果微几何的不规则性大于次表面散射的距离，则次表面散射将表现出更多和微几何相关的效果，比如回射，这种情况下应当选用粗糙表面漫反射模型，这类模型将次表面散射作为局部次表面散射处理，仅对 micro-BRDF $f_\mu$产生影响。

- 如果散射距离都大于不规则性，则应当认为对于次表面散射来说，这个表面是平整的，不会出现诸如回射的效果，次表面散射不再是局部效果，不能再通过微平面理论建模，需要使用光滑表面的漫反射模型。

- 在上述两种情况之间，应当使用粗糙表面漫反射模型，但需要考虑*有效表面*。漫反射和镜面反射都可以使用微平面理论建模，但需要使用不同的粗糙度值，镜面反射项的粗糙度值需要基于实际表面的粗糙度，漫反射项的粗糙度则需要根据有效表面设置一个更低一些的值。

**光滑表面的次表面模型**

当表面的不规则性小于次表面散射距离时，需要使用光滑表面的次表面模型。这种情况下，表面的粗糙度几乎不会影响到漫反射着色，除非模型中的漫反射项和镜面反射项是耦合的。

实时渲染应用中通常会将局部次表面散射用兰伯特项建模，这种情况下的漫反射项为：

$f_{diff}(\textbf{l},\textbf{v})=\frac{\rho_{ss}}{\pi}$

兰伯特模型没有考虑到，表面反射的光线并不能参与次表面散射。通过菲涅尔效果可以调节镜面反射和次表面反射的比例。菲涅尔效果认为，当入射角增大时，漫反射减少，镜面反射增加。如果镜面反射项是属于平面镜的，则其漫反射项为：

$f_{diff}(\textbf{l},\textbf{v})=(1-F(\textbf{n},\textbf{l}))\frac{\rho_{ss}}{\pi}$

如果镜面反射项是属于微平面 BRDF 模型的，则其漫反射项为：

$f_{diff}(\textbf{l},\textbf{v})=(1-F(\textbf{h},\textbf{l}))\frac{\rho_{ss}}{\pi}$

上述两式都默认了射出方向是均匀分布的，这有一定的道理，因为光线往往经过多次散射后才会射出表面，所以射出方向是随机的。但是，有两点理由说明射出方向并不是完全均匀的。第一点，由于第一个式子中的漫反射 BRDF 项受到入射方向的影响，根据赫尔姆霍兹互易性原则，它也应当收到出射方向的影响；第二点，光线是经过折射离开物体内部的，这会对出射方向产生影响。

Shirley 提出了一种耦合的漫反射项模型，可以兼顾能量守恒和赫尔姆霍兹互易：

$f_{diff}(\textbf{l},\textbf{v})=\frac{21}{20\pi}(1-F_0)\rho_{ss}(1-(1-(\textbf{n}\cdot\textbf{l})^+)^5)(1-(1-(\textbf{n}\cdot\textbf{v})^+)^5)$

上式假定了 Schlick 近似是用于菲涅尔反射的，所以仅可以用于镜面反射为完美菲涅尔镜面反射的表面。

Ashikhmin 和 Shirley 提供了更一般的模型（经 Kelemen&Szirmay-Kalos 完善），可以耦合任意镜面反射项：

$f_{diff}(\textbf{l},\textbf{v})=\rho_{ss}\frac{(1-R_{spec}(\textbf{l}))(1-R_{spec}(\textbf{v}))}{\pi(1-\overline{R_{spec}})}$

其中，$R_{spec}$是镜面反射项的定向反照率，$\overline{R_{spec}}$是它在半球面上的余弦加权平均。这里的$R_{spec}$包含全部的镜面反射 BRDF 项，所以它不仅依赖于粗糙度$\alpha$和仰角$\theta$，还需要包括菲涅尔反射。Imageworks 使用三维的查找表存储该漫反射项，当考虑进多次弹射项时，$R_{spec}$比$R_{sF1}$更光滑，所以只需要$16\times16\times16$的查找表就可以满足需求。

如果只使用 Schlick 菲涅尔近似而不使用多次弹射的镜面反射项，则可以做进一步的简化，且简化方式与 Image-based lighting 相仿，它们可以共用一张查找表以提升效率。

上述模型主要从漫反射和镜面反射之间的能量守恒出发，实际上还有另一类基于物理法则的模型。这类物理模型基于一种半无限、各向同性的散射体积 BRDF 模型（Chandrasekhar）。Kulla&Conty 证明了，当平均自由路径足够短的时候，该 BRDF 模型可以完美拟合任意形状的散射体积。不过，由于 Chandrasekhar 的模型没考虑折射，所以其只能用于折射率高度相似的表面；对于折射率发生变化的表面，就需要考虑折射的影响，这些工作有 Hanrahan 等人推进。

**粗糙表面的次表面模型**

作为迪士尼原则的着色模型的一部分，Burley 也给出了一种包括了粗糙度效果且匹配测量材质的漫反射 BRDF 项：

$f_{diff}(\textbf{l},\textbf{v})=\chi^+(\textbf{n}\cdot\textbf{l})\chi^+(\textbf{n}\cdot\textbf{v})\frac{\rho_{ss}}{\pi}((1-k_{ss})f_d+1.25k_{ss}f_{ss})$

其中：

$f_d=(1+(F_{D90}-1)(1-\textbf{n}\cdot\textbf{l})^5)(1+(F_{D90}-1)(1-\textbf{n}\cdot\textbf{v})^5)\\F_{D90}=0.5+2\sqrt{\alpha}(\textbf{h}\cdot\textbf{l})^2\\f_{ss}=(\frac{1}{(\textbf{n}\cdot\textbf{l})(\textbf{n}\cdot\textbf{v})}-0.5)F_{SS}+0.5\\F_{SS}=(1+(F_{SS90}-1)(1-\textbf{n}\cdot\textbf{l})^5)(1+(F_{SS90}-1)(1-\textbf{n}\cdot\textbf{v})^5)\\F_{SS90}=\sqrt{\alpha}(\textbf{h}\cdot\textbf{l})^2$

上式中的$\alpha$是镜面粗糙度，在各向异性材质中使用$\alpha_x,\alpha_y$的中间值。

上述的漫反射项一般被称为“迪士尼漫反射模型”。

次表面项$f_{ss}$受 Hanrahan-Krueger BRDF 的启发，是一种对远距离物体全局次表面散射的近似替代。该漫反射模型在次表面项$f_{ss}$和粗糙漫反射项$f_d$之间，通过参数$k_{ss}$混合。

完整的迪士尼漫反射 BRDF 中还包含一个光泽项（sheen），用于织物的建模，也有助于缓解缺少多次弹射引起的能量损失。

由于迪士尼漫反射模型中使用与镜面反射 BRDF 项相同的粗糙度，所以一些特定的材质可能难以描述。当然，把它改成使用不同的粗糙度也并不复杂。

---

其他的粗糙表面漫反射 BRDF 大多是基于微平面理论的，只不过选用了不同的 NDF、micro-BRDF $f_\mu$或者$G_2$函数。其中最著名的是 Oren-Nayar BRDF 模型，它使用了兰伯特 micro-BRDF，球面高斯 NDF，以及 Torrance-Sparrow "V"型遮挡-阴影函数。Oren-Nayar 在论文中还给出了简化的版本。近几年有很多基于 Oren-Nayar 模型的改进模型被提出，使得模型更加精准而不增加开销。

其他的模型还有 Hammon 给出的漫反射模型，参考书上 P355。

#### 8.13 布料的 BRDF 模型

布料的微几何通常都和其他材质不一样。根据织物类型的不同，有些布料具有高度重复的编制微结构，有些则是会有细线从表面凸出，或者两者都有。布料表面有着特别的外表，需要专门的着色模型来描述诸如各向异性高光、光谱散射、颜色偏移等现象。

除了 BRDF，织物通常具有高频的空间变化，这也是做好布料的关键因素，比如增加编制细节、织物老化、织物破碎和小褶皱等。

布料的 BRDF 模型通常可以分为三类：基于观察的经验模型、基于微平面理论的模型以及微柱体模型。

**布料-经验模型**

《神秘海域 2》中布料表面的漫反射 BRDF 项为：

$f_{diff}(\textbf{l},\textbf{v})=\frac{\rho_{ss}}{\pi}(k_{rim}((\textbf{v}\cdot\textbf{n})^+)^{\alpha_{rim}}+k_{inner}(1-(\textbf{v}\cdot\textbf{n})^+)^{\alpha_{inner}}+k_{diff})$

其中，$k_{rim},k_{inner},k_{diff}$分别用于控制织物的轮廓光照、向前内表面的亮度，以及兰伯特项；$\alpha_{rim},\alpha_{inner}$分别用于控制轮廓光照和内表面亮度的衰减。显然，该式并不物理。

与之相反，《神秘海域 4》中的布料模型则根据布料类型使用微平面模型或者微柱体模型来建模镜面反射项，使用次表面散射的近似经验模型来建模漫反射项：

$f_{diff}(\textbf{l},\textbf{v})(\textbf{n}\cdot\textbf{l})^+\Rightarrow\frac{\rho_{ss}}{\pi}(\textbf{c}_{scatter}+(\textbf{n}\cdot\textbf{l})^+)^\mp\frac{(\textbf{n}\cdot\textbf{l}+w)^\mp}{1+w}$

其中，$\textbf{c}_{scatter}$是设定的散射颜色；$w$值在 0~1 之间，控制光亮的宽度。

迪士尼使用额外的光泽项来建模布料的漫反射 BRDF 项：

$f_{sheen}(\textbf{l}.\textbf{v})=k_{sheen}\textbf{c}_{sheen}(1-(\textbf{h}\cdot\textbf{l})^+)^5$

其中，$k_{sheen}$用于控制光泽项的强度；光泽色$\textbf{c}_{sheen}$是由白色和$\rho_{ss}$的标准亮度值混合得到的。

**布料-微平面模型**

Ashikhmin 等人提出使用逆高斯 NDF 来建模绒布材质。该 NDF 是对已有模型的轻微修改，它还给出了一种通用的建模微平面 BRDF 模型的变体，没有遮挡-阴影项且调整了分母。《教团 1886》中使用了该 BRDF 模型以及它的泛化版本：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})}{\pi(1+k_{amp}\alpha^2)}(1+\frac{k_{amp}exp(\frac{(\textbf{n}\cdot\textbf{m})^2}{\alpha^2((\textbf{n}\cdot\textbf{m})^2-1)})}{(1-(\textbf{n}\cdot\textbf{m})^2)^2})$

其中，$\alpha$控制逆高斯的宽度，$k_{amp}$控制逆高斯的幅度。

完整的布料 BRDF：

$f(\textbf{l},\textbf{v})=(1-F(\textbf{h},\textbf{l}))\frac{\rho_{ss}}{\pi}+\frac{F(\textbf{h},\textbf{l})D(\textbf{h})}{4(\textbf{n}\cdot\textbf{l}+\textbf{n}\cdot\textbf{v}-(\textbf{n}\cdot\textbf{l})(\textbf{n}\cdot\textbf{v}))}$

《神秘海域 4》中使用上式的变体来建模粗糙织物，例如羊毛和棉。

Imageworks 使用一种不同的逆 NDF 用于 BRDF 的光泽项：

$D(\textbf{m})=\frac{\chi^+(\textbf{n}\cdot\textbf{m})(2+\frac{1}{\alpha})(1-(\textbf{n}\cdot\textbf{m})^2)^\frac{1}{2\alpha}}{2\pi}$

虽然该 NDF 没有 Smith 遮挡-阴影函数的闭合形式解，Imageworks 使用解析函数对其求取数值近似解。

**布料-微柱体模型**

用于布料的微柱体模型和用于毛发的模型是相似的，所以之后有关毛发模型的讨论可以视作本节内容的延续。这类模型的基本思路是，假定了表面是由一维的线覆盖。Kajiya 和 Kay 为此类模型提供了一种简单的 BRDF 模型，这成为了 Banks 模型的理论基础。因此，该模型又被称为 Kajiya-Kay BRDF 或者 Banks BRDF。该模型的基本出发点是观察到，由一维线构成的表面在任何地方都具有无数的法线，由垂直于切向量$\textbf{t}$的法平面定义。尽管有很多新的微柱体模型都是由该框架发展出来的，最原始的 Kajiya-Kay 模型仍得益于它的简洁而长盛不衰。例如，在《神秘海域 4》中，Kajiya-Kay BRDF 就用于光泽织物（如丝绸、绒布）的镜面项。

梦工厂（Dreamworks）使用一种相对简单且艺术家可控的微柱体模型来建模织物。可以通过纹理来描述粗糙度、颜色和织线的方向。经纱、纬纱可以设置不同的参数来建模复杂的变色织物，例如闪光绸。

Sadeghi 等人提出了一种基于织物样本测量的微柱体模型。该模型还考虑了内部织线间的遮挡和阴影。

在一些情况下会使用毛发 BSDF 模型来描述布料。比如 RenderMan 渲染器、迪士尼的某些布料渲染系统。

#### 8.14 波动光学的 BRDF 模型

如前所述，几何光学是假定了物体表面的不规则性或是比波长小，或是大于波长的 100 倍。介于 1~100 倍波长的不规则性被称为*纳米几何*不规则性，以区别于使用几何光学的微几何不规则性。纳米几何上的反射效果无法使用几何光学描述，需要通过波动光学建模。厚度与波长相近的表面层或者镀膜也会产生与波动效应相关的现象。

本节介绍诸如衍射、薄膜干涉等波动光学现象，讨论它们在真实感渲染中的重要性。

**衍射模型**

纳米几何会引起衍射（diffraction）现象。惠更斯-菲涅尔原理认为波阵面上的点集可以看作球面波的波源。当光波遇到障碍物时，惠更斯-菲涅尔原理表明光波会在边角上发生轻微的弯折，这便是光波的衍射现象。衍射现象无法通过几何光学来描述。几何光学认为光线只会向单一的方向反射，而惠更斯-菲涅尔原理则给出了一种新的观点，物体表面的球面波会相互干涉，只剩下反射方向的波阵面。这种观点对于处理纳米几何的不规则性是至关重要的。由于表面的高度不同，表面的球面波不再整齐一致，这会影响波阵面的描述。

镜面反射方向周围的衍射角度扩散依赖于纳米几何的凹凸宽度相对于波长的大小。有点反直觉的结论是，相对越宽的不规则性会产生更小的扩散，如果不规则性大于波长的 100 倍，则衍射方向和反射方向之间的夹角可以小到忽略不计。不规则性的减小会产生更大的衍射光扩散，直到不规则性小于波长时，不再产生衍射。

对于具有周期性纳米几何结构的表面，光的衍射现象更加显眼，因为重复的结构加强了衍射光的相长干涉，产生虹色。这种现象可以在 CD、DVD 光碟，以及一些昆虫身上看到。虽然衍射也可以发生在非周期性的表面，但多年来的图形学研究认为这种效果是轻微的，所以鲜有图形学文章讨论衍射现象。

然而，由 Holzschuch 和 Pacanowski 进行的材质测量研究表明，许多材质都表现出了重要的衍射效应，并阐释了当前模型拟合这些材质的困难性。他们在后续的工作中给出了一种结合了微平面理论和衍射理论的模型，这是通过在通用微平面 BRDF 中使用考虑了衍射的 micro-BRDF 实现的。同时，Toisoul 和 Ghosh 提出了获取周期性纳米几何引发的虹色现象的方法，并给出了用点光源和基于图片的光照实时渲染它们的方法。

**薄膜干涉模型**

薄膜干涉是一种波动光学现象，它发生于光线在薄膜电介质上下面反射中的相互干涉。不同波长的光会依据波长和光程的不同发生相长干涉或相消干涉。由于光程差和角度相关，所以不同波长的光在相长干涉和相消干涉下出现虹色偏移。薄膜干涉现象需要“薄”膜是由于“相干距离”的需要。相干距离是复制波可以替换原波，且仍然与原波产生相干作用的最远距离。相干距离与光的带宽成反比，比如激光的带宽很窄，所以相干距离很长，可以有几英里长。如果是单色激光，它可以有无限远的相干距离，但实际上激光的带宽还是大于零的。反之，带宽很宽的光有着混沌的波形，它只需要移动很短的距离就会停止与原波的相干。

理论上，混合了全部波长的理想白光的相干距离为零。然而，可见光的带宽是基于人眼视觉系统的，其相干距离约为 1 微米。所以，小于约 1 微米的薄膜会产生薄膜干涉。

与衍射相似，多年来人们一直认为薄膜干涉是一种特殊效果，只会产生在例如肥皂泡或油迹的表面。但是，Akin 指出，薄膜干涉会使许多日常物体的表面产生细微的颜色，为这些效果建模可以提升真实感。

适用于实时渲染的薄膜干涉技术已经存在了一段时间了。Smits 和 Meyer 提出了一种考虑一阶和二阶光路间薄膜干涉的高效方法。他们观察到最终的颜色主要是光程差的函数，可以由薄膜厚度、视角和折射率快速计算得出。这类方法无法模拟薄膜中的多次弹射和其他物理现象，Belcour 和 Barla 给出了一个更精确也更消耗算力的实时渲染算法。

#### 8.15 分层材质

现实中的材质通常都是一层叠一层的，比如物体表面可能被灰尘、水渍、冰或者雪覆盖，也可能被涂上油漆或其他材料用于装饰或者保护，又或者它的基础结构形成了多层材质（例如大多数的生物材料）。

最简单和直观的一个例子便是清漆，它是在其他材料上的一层光滑透明层。迪士尼原则的着色模型包括清漆项，虚幻引擎、RenderMan 等渲染系统中也都有。清漆最明显的效果是清漆层和底层的两次光线反射，当底层材质是金属的时候，二次反射尤为明显，这是由于两者的折射率相差悬殊；当底层材质为电介质时，两者折射率相近，这会使得二次反射较弱。

清漆层也可以带有色彩，从物理的角度来说，这种色彩是由吸收引起的。光线的吸收量取决于穿透清漆层的光路的长度，这由 Beer-Lambert 定律描述。光路的长度取决于视线和光线的角度，以及材质的折射率。较简单的清漆实现，比如迪士尼原则模型和虚幻引擎，并没有对视线角度建模。

最一般的情况下，不同的材质层具有不同的表面法线。比如纸箱上皱巴巴的塑料膜。影视使用的分层材质大多支持每层单独设置法线，但这在实时应用中少见，虚幻引擎的清漆材质支持额外设置法线。

Weidlich 和 Wilkie 提出了一种分层微平面模型，假定了各层的厚度相比于微平面很小。他们的这个模型支持任意数量的分层，自顶向下跟踪反射和折射事件，再自底向上跟踪一遍。这种模型确实可以在实时应用中使用，但它没有考虑多层材质之间的反射。Jakob 等人提出了一种全面而准确的框架来模拟分层材质，包括层间反射；虽然该框架不适合实时实现，但该框架给事实比对提供了一个很好的参考，而且其中的思想推动了实时技术的发展。

#### 8.16 材质混合与滤波

材质混合是对材质属性的处理，比如对多层材质 BRDF 参数的混合。例如建模一块带有锈迹的金属片，可以绘制一张遮罩纹理来控制锈迹的位置，然后用这张纹理来将金属材质和锈迹材质的材质属性（高光颜色$F_0$，漫反射颜色$\rho_{ss}$，粗糙度$\alpha$）混合。材质混合操作既可以预处理得到一张纹理，也可以在运行时计算。尽管法线不是 BRDF 的参数，但它的空间变化对材质表现非常重要，所以材质混合也需要包括法线的混合。

对于很多实时渲染应用来说，材质混合是非常重要的技术。比如《教团 1886》中就有一个复杂的材质混合系统，可以从材质库中提取材质加入无深度限制的材质堆栈中，并使用不同的遮罩。大多数的材质混合都是离线预处理的，但某些特定的合成操作可以根据需要推迟到运行时执行（比如环境变化）。运行时混合纹理可以提供不同的效果同时也能节省内存。

游戏中一般会为以下目的执行材质混合：

- 呈现动态破坏效果，如建筑、交通工具、活物。
- 允许玩家在游戏中定制装备和服装。
- 增加角色或环境的视觉变化。

有时，上层的材质向下混合时并不是$100\%$的不透明度；但是即使是完全不透明的材质，其在遮罩的边界处也应当采用部分混合。

法线贴图的混合需要特别注意，一般通过混合高度图得到的结果更好；另一些时候，比如在基础表面上叠加细节法线贴图时，其他方法会更合适。

材质滤波是和材质混合紧密相关的话题。材质的属性通常都存储在纹理中，需要经过 GPU 的滤波处理，比如双线性滤波和多级纹理。然而，这实际上假定了需要滤波的数值是和最终颜色呈线性关系的。对法线贴图使用线性滤波生成多级纹理可能会产生瑕疵，对其他一些含有非线性 BRDF 参数（如粗糙度）的纹理使用也是一样的道理。这些瑕疵可能会是高光闪烁、相机距离改变时的表面光泽度或亮度的变化。其中，高光闪烁尤为显眼，解决这种瑕疵的技术被称为“高光抗走样”技术。

**对法线和法线分布的滤波**

材质滤波中的主要瑕疵都与法线、法线分布的滤波有关。法线分布函数 NDF 是亚像素表面结构的统计学模型。当相机变远时，物体表面原先覆盖多个像素的结构就会缩小成亚像素尺寸，从而由凹凸贴图采样转为 NDF 采样。这种转换与多级纹理紧密相关，它封装了由纹理到亚像素中遗失的细节。

现在假设相机远离了物体，使得一个屏幕像素覆盖了四个法线纹素，该分辨率下最理想的表现方式可以精确地描述出（大尺度）像素上的法线分布情况。这种分布情况可以通过对四个纹素求平均 NDF 得到，这对于渲染来说已经足够精确。也可以分开来求法线的均值，分别求法线分布、粗糙度的均值，它们得到的均值是正确的，但分布区域却比较狭窄，会使表面过于平滑，也可能会引起高光闪烁。

我们无法直接求取理想的法线分布，但可以通过在法线贴图中存储 lobe 的中心方向，在粗糙度贴图中存储对应的粗糙度值，来得到接近于理想分布的 NDF 描述。

早期的 NDF 滤波方法是使用数值优化方法来拟合一个或多个 NDF，得到它们的平均分布。这种方法受限于鲁棒性和计算速度，今天已经很少使用了。今天的主流技术是通过计算法线分布的方差来得到平均分布。Toksvig 观察到，（未单位化的）法线分布的宽度与法线分布的长度成反比，这意味着原分布的方向越分散，他们的平均法线长度就越短。他使用法线长度来调整 NDF 的粗糙度参数，再通过粗糙度参数来近似法线滤波：

$\alpha_p'=\frac{\|{\overline{\textbf{n}}}\|\alpha_p}{\|{\overline{\textbf{n}}}\|+\alpha_p(1-\|{\overline{\textbf{n}}}\|)}$

其中，$\alpha_p$是初始粗糙度参数，$\alpha_p'$是调整后的值；$\|{\overline{\textbf{n}}}\|$是平均法线长度。该方程描述的是 Blinn-Phong NDF 中粗糙度值的调整，它也可以用在 Beckmann NDF 中（$\alpha_p=2\alpha_b^{-2}-2$）。在 GGX 中的使用就不是那么直观了，如果使用$\alpha_b=\alpha_g$，虽然高光中心值相同，但高光区域则非常不一样。更麻烦的是，GGX 分布的方差是没有定义的，这也使得所有基于方差的方法无法在 GGX 上使用。但就算是这样，人们也经常使用$\alpha_p=2\alpha_g^{-2}-2$代入 GGX 中，因为实际效果还不错。

Toksvig 的方法对于动态生成的法线贴图也很有效，比如水波法线贴图；但由于它不适用于常用的法线贴图压缩技术，所以它用在静态法线贴图上的效果不算好（压缩技术往往是基于单位法线的）。

Olana 和 Baker 的 LEAN 映射技术使用法线分布的协方差矩阵。该技术同样适用于动态法线贴图，还支持各向异性法线分布，但为了避免精度问题也需要大量空间存储静态法线。LEAN 的一种简化变体，CLEAN，只需要更少的空间，但牺牲了对各向异性的支持。LEADR 扩展了 LEAN，使其可以支持视差贴图。

实时应用中的绝大多数法线贴图都是静态的，为了使用基于方差的滤波技术，会在生成多级纹理贴图的同时计算它们丢失的方差，这就解决了方差滤波技术的大部分缺陷。比如《使命召唤：黑色行动》中就使用了该技术。

方差也可以沿着纹理空间的 x 和 y 方向计算，然后存储进各向异性的粗糙度贴图中。但这样就使得它仅可以用于轴对齐的各向异性，通常是人造物体的表面会呈现各向异性，而自然生成的物体则不是。使用额外的存储空间可以支持定向各向异性。

与原始方法不同，计算生成方差贴图时并未考虑由 GPU 纹理滤波引起的方差。为了解决该问题，方差贴图的实现方法通常包含对原始法线贴图的卷积。

法线方差也可能由几何体的高曲率引起（多见于角色模型）。解决这类问题通常将几何曲率“烘焙”进粗糙度贴图中；也可以在运行时计算曲率，比如在渲染几何体或者后处理中。

法线方差也会对漫反射产生影响，所以考虑进法线方差可以同时提高漫反射和镜面反射的精确度。

方差贴图技术采用法线的高斯分布近似，这对每像素覆盖成千上万凹凸是合理的近似；但也可能一个像素只覆盖了数百或数千个凹凸，这种情况下物体表面就会出现闪光。如果还使用光滑的高斯近似，那么就不会有这种闪光细节。在影视行业，通常使用额外的超采样来解决该问题，该问题对于实时应用来说很难解决，甚至是对于离线渲染也是如此。

### 9. 局部光照

现实中的光照环境远比点光源和平行光源复杂，这就要求对半球面上的 BRDF 进行积分。在实时渲染中，我们倾向于寻找这种积分的闭合形式的解。为了寻找易于求解的形式，通常会对光源或 BRDF 进行近似。在感知框架下进行最终着色计算很重要，这有利于寻找渲染中最重要的部分，并投入更多的精力。

#### 9.1 面光源

对无穷小光源的近似为：

$L_o(\textbf{v})=\int_{\textbf{l}\in\omega_l}f(\textbf{l},\textbf{v})L_l(\textbf{n}\cdot\textbf{l})^+d\textbf{l}\approx\pi f(\textbf{l}_c,\textbf{v})\textbf{c}_{light}(\textbf{n}\cdot\textbf{l}_c)^+$

这种光源所引入的误差主要来自于两方面：光源的大小，表面的光滑度。

可以注意到，面光源的高光可以通过增加表面粗糙度后用点光源近似。这个现象也解释了为何许多实时渲染系统可以只用几个点光源就作出很逼真的面光源效果。但显然，这么做是不好的，因为这会耦合材质属性和光照设置，当光照环境发生变化就很容易出现错误。

对于兰伯特表面来说，由点光源推广出面光源的表达是精确的：

$L_o(\textbf{v})=\frac{\rho_{ss}}{\pi}E$

其中，$\rho_{ss}$是次表面反照率，或称为表面漫反射颜色。结合开篇的近似公式，可以得到：

$E=\int_{\textbf{l}\in\omega_l}L_l(\textbf{n}\cdot\textbf{l})^+d\textbf{l}\approx\pi\textbf{c}_{light}(\textbf{n}\cdot\textbf{l}_c)^+$

"矢量辐照度"概念有助于理解面光源产生的辐照度。矢量辐照度由 Gershun 提出，他称它为“光矢量”，后续由 Arvo 推广完善。使用矢量辐照度概念，可以将任意尺寸任意形状的面光源转化为用点光源或平行光描述。

想象到达空间一点$\textbf{p}$的辐射度$L_i$（现假设$L_i$是波长无关的标量），则对于由$\textbf{l}$方向的微立体角$d\textbf{l}$，可以构造一个矢量，方向平行于$\textbf{l}$且长度等同于该方向上辐射度与$d\textbf{l}$的乘积。最终，各个方向矢量的和即为矢量辐照度$\textbf{e}$：

$\textbf{e}(\textbf{p})=\int_{\textbf{l}\in\Theta}L_i(\textbf{p},\textbf{l})\textbf{l}d\textbf{l}$

矢量辐照度$\textbf{e}$可以用作寻找任何方向的平面上$\textbf{p}$点的净辐照度（通过点乘法线）：

$E(\textbf{p},\textbf{n})-E(\textbf{p},-\textbf{n})=\textbf{n}\cdot\textbf{e}(\textbf{p})$

净辐照度是正面辐照度和反面辐照度的差。它本身对于渲染没有作用。但如果反面不接收辐射，也就是矢量辐照度和平面法线之间的夹角没有超过$90\degree$的，则$E(\textbf{p},-\textbf{n})=0$，并且可以推出：

$E(\textbf{p},\textbf{n})=\textbf{n}\cdot\textbf{e}(\textbf{p})$

由于兰伯特表面法线和矢量辐照度的夹角不会大于$90\degree$，所以可以直接用上式计算面光源。

现在取消$L_i$波长无关的假设，在更一般的情况下是无法定义一个单独的矢量辐照度$\textbf{e}$的。不过，有色光通常在所有点上都有相同的相对光谱分布，这意味着我们可以用颜色矢量$\textbf{c}'$和一个波长无关的辐射度$L_i'$表示。则原先的式子只需要做一点替换：

$\textbf{l}_c=\frac{\textbf{e}(\textbf{p})}{\|{\textbf{e}(\textbf{p})}\|}\\\textbf{c}_{light}=\textbf{c}'\frac{\|{\textbf{e}(\textbf{p})}\|}{\pi}$

这样就可以在不引入误差的情况下，将任意形状任意尺寸的面光源转换为平行光。

对于其他一些简单的情形，可以通过解析的方式计算面光源。比如一个中心在$\textbf{p}_l$点，半径为$r_l$的圆面光源，其中每一点发出的辐射度都是恒定的$L_l$，则可以得到：

$\textbf{l}_c=\frac{\textbf{p}_l-\textbf{p}}{\|{\textbf{p}_l-\textbf{p}}\|}\\\textbf{c}_{light}=\frac{r_l^2}{\|{\textbf{p}_l-\textbf{p}}\|^2}L_l$

上式和之前章节讨论的光源表述是一致的。

以上的讨论都是建立在“没有反面辐照度”的假设上的，换句话说就是不存在被表面遮挡的光源。我们可以拿掉这个假设，推导更一般的情况。对于兰伯特表面来说，点光源和面光源的差异都是由遮挡的不同引起的。无遮挡的点光源辐照度遵守余弦定律；Snyder 推导了考虑遮挡时圆面光源的解析式，解析式非常复杂。但是，由于该解析式只依赖于两个量（$r/r_l,\space\theta_i$），所以能用预计算的二维纹理替代。Snyder 也给出了两个近似函数可用于实时渲染的计算。

通过之前的观察得知，粗糙表面的面光源效果并不明显，这意味着可以用一种不物理但是有效的方法来建模：wrap lighting。Forsyth 给出的一种 wrap lighting 形式为：

$E=\pi\textbf{c}_{light}(\frac{(\textbf{n}\cdot\textbf{l})+k_{wrap}}{1+k_{wrap}})^+$

其中，$k_{wrap}$的范围在 0~1，0 表示点光源，1 表示覆盖整个半球面的面光源。另一种由 Valve 给出的大尺寸面光源形式为：

$E=\pi\textbf{c}_{light}(\frac{(\textbf{n}\cdot\textbf{l})+1}{2})^2$

一般来说，当计算面光源时，也要相应地使用软阴影。

#### 9.2 光泽材质

面光源对于非兰伯特材质的影响更大。面光源在光泽材质表面的主要效果体现在高光上。高光的尺寸和形状与面光源相似，当粗糙度提升时，高光边缘变模糊。这个观察提供了一些经验近似的方法，比如将高光的计算转变为一个包含截断阈值的平整高光区域。

大部分实际使用的面光源近似方法都基于一个想法：在每个着色点上寻找一个等效的点光源来模拟非点光源。

最早的近似方法之一是由 Mittring 提出的“粗糙度调节”，被用于虚幻引擎的“Elemental demo”中。它的基本思路是找到一个圆锥，包含绝大多数可以到达表面半球面的光源辐照度；然后在镜面反射 lobe 中使用一个相似的圆锥来包含大多数的 BRDF。这两个圆锥将替代半球面上的函数，它们包含了原函数值大于给定值的方向。之后就可以找到一个新 BRDF lobe 和新粗糙度的卷积，来近似替代原始的函数卷积。Karis 给出了一种使用 Mittring 方法实现 GGX 和球面光源的应用，只需要对粗糙度参数$\alpha_g$做一点简单的修改：

$\alpha_g'=(\alpha_g+\frac{r_l}{2\|{\textbf{p}_l-\textbf{p}}\|})^\mp$

该方法虽然效果理想且计算量较小，但对于接近镜面的材质效果较差。这是由于镜面材质的镜面反射 lobe 总是光滑的，不能模拟面光源在表面上形成的高光。另外，由于大部分微平面 BRDF 模型的 lobe 都不具有区域性，也会使得粗糙度重映射的方法不那么有效。

除了调节 材质的粗糙度，另一种思路是使用基于着色点变化的光源方向来描述面光源的照明效果。这种技术被称为“最大代表点”方案，它调整光源矢量来使面光源表面的点产生对着色表面最大的能量贡献。它的理论基础是定积分的均值定理。

代表点方案也可以根据它们对高光形状的影响来确定。在代表点不变的表面区域（反射向量在圆锥之外），可以使用点光源来有效的替代面光源照明，高光的形状只依赖于镜面反射 lobe 的形状。如果着色点的反射向量击中了面光源，那么代表点就需要连续变化来指向贡献值最大的方向，这样做可以将镜面反射 lobe 扩大。这个扩大也是误差的主要来源，粗糙表面上的反光会看上去比真实结果更亮，刚好与粗糙度调整技术的缺陷相反。相关的修复技术是通过调节 BRDF lobes、软阈值、缩放因子来实现的。

#### 9.3 各形状的光源

球形光源最简单的扩展之一是管光源，也被称为胶囊光源，可以用于表现现实中的荧光灯管。对于兰伯特 BRDF，Picott 给出了管光源的闭合形式的解，管光源由两端的两个点光源描述：

$\int_{\textbf{p}_0}^{\textbf{p}_1}(\textbf{n}\cdot\frac{\textbf{x}}{\|{\textbf{x}}\|})\frac{1}{\|{\textbf{x}}\|^2}d\textbf{x}=\frac{\frac{\textbf{n}\cdot\textbf{p}_0}{\|{\textbf{p}_0}\|^2}+\frac{\textbf{n}\cdot\textbf{p}_1}{\|{\textbf{p}_1}\|^2}}{\|{\textbf{p}_0}\|\|{\textbf{p}_1}\|+(\textbf{p}_0\cdot\textbf{p}_1)}$

其中，$\textbf{p}_0,\textbf{p}_1$分别是线性光源的两个端点，$\textbf{n}$是表面法线。 Picott 也给出了使用 Phong 镜面 BRDF 的代表点方法。如同球光源，Karis 也给出了 Picott 方法的一种高效变体，通过使用线光源上到反射向量最近的点。

使用代表点方法近似其他形状的光源很容易，比如近似环形或者贝塞尔曲线光源，但我们通常不希望在着色器中加入太多分支语句。有一类最具代表性的是平面光源，通常是由几个给定的几何体约束的平面（如矩形、圆盘等多边形）。这些图元可以被用作发光面板，比如广告牌、电视屏幕、替代摄影照明、模拟复杂灯光装置、模拟墙面反光等。这类光源最早的一种实现方案是由 Brobot 提出的，该方法也是代表点方法，但它将方法扩展到了二维平面且给出了总体解决方法。Drobot 也是从均值定理出发的，他认为合适的候选点应当出现在全局最大亮度的光源点附近。

对于兰伯特 BRDF，积分式为：

$L_l\int_{\textbf{l}\in\omega_l}(\textbf{n}\cdot\textbf{l})^+\frac{1}{r_\textbf{l}^2}d\textbf{l}$

其中，$L_l$是由光源发出的常量辐射度，$\omega_l$是由光源的几何形状构成的立体角，$r_{\textbf{l}}$是从光源平面到表面的距离（沿着$\textbf{l}$方向）。从表面点沿法线方向交于光源平面的点为$\textbf{p}'$，$(\textbf{n}\cdot\textbf{l})^+$的最大值是光源区域边界上离$\textbf{p}'$最近的点$\textbf{p}_c$。相似的，光源平面上离着色点最近的点为$\textbf{p}''$，$1/r_{\textbf{l}}^2$的最大值是边界上离$\textbf{p}''$最近的点$\textbf{p}_r$。被积函数的全局最大值就在$\textbf{p}_r$和$\textbf{p}_c$之间：

$\textbf{p}_{max}=t_m\textbf{p}_c+(1-t_m)\textbf{p}_r,\quad t_m\in[0,1]$。

Arvo 推广了矢量辐照度概念，提出了更高维的“辐照度张量”，并使用斯托克斯定理将面积分转为沿轮廓积分。该方法仅假设了光源区域对着色点完全可见，但该方法计算开销过大，不适合实时渲染。近年来，Lecocq 找到了该方法的$O(1)$近似，并将其推广到了一般的半矢量 BRDF。

上述的实时面光源方法都使用了一些假设来简化解析推导和积分求解。Heitz 等人则提出了一种使用线性变换余弦（LTCs）的不同方法。线性变换余弦使用一个通过$3\times3$矩阵变换的余弦 lobe 来拟合各种形状。Heitz 等人的关键思路在于，他们意识到使用矩阵变换扩展 lobe 并不会增加积分的复杂度。那么剩下来的工作就是寻找方法来使用 LTCs 近似 BRDF 函数，这可以通过离线计算得到。LTCs 方法可能比代表点方法开销大一点，但是精确很多。

#### 9.4 环境光照

本节虽然讨论环境光照，但并不是指全局光照。它们的关键区别在于，本节不涉及其他物体表面的信息，仅考虑光源的图元。

背景光（Ambient light）是环境光照中最简单的一种模型，其辐射度不随方向变化，始终为$L_A$。背景光的影响是依赖于 BRDF 的，兰伯特表面的背景光：

$L_o(\textbf{v})=\frac{\rho_{ss}}{\pi}L_A\int_{\textbf{l}\in\Omega}(\textbf{n}\cdot\textbf{l})d\textbf{l}=\rho_{ss}L_A$

对于任意的 BRDF：

$L_o(\textbf{v})=L_A\int_{\textbf{l}\in\Omega}f(\textbf{l},\textbf{v})(\textbf{n}\cdot\textbf{l})d\textbf{l}$

上式和定向反照率$R(\textbf{v})$相同，即$L_o(\textbf{v})=L_AR(\textbf{v})$。早期的实时渲染应用中会假定一个固定值用作定向反照率，也就是“环境色”$\textbf{c}_{amb}$，则$L_o(\textbf{v})=\textbf{c}_{amb}L_A$。

#### 9.5 球面、半球面函数

为了推广环境光照（不再是常值），需要考虑更具体的入射辐射度。先从将入射辐射度建模为与入射方向相关（与表面位置无关）的函数开始，这假设了环境光照无限远。

到达某一点的辐射度可能随入射方向的不同而不同，可以使用定义在单位球上或$\mathbb{R}^3$（三维欧几里得）空间的球面函数描述，将球面域记为$S$。对于兰伯特表面，球面函数使用一个预计算的辐照度函数来计算环境光照，例如将辐射度和余弦 lobe 卷积。更复杂的方法会存储辐射度，并在运行时通过 BRDF 计算环境光照的积分。球面函数也经常用于全局光照算法中。

与球面函数紧密相关的是半球面函数，针对于仅有半球面方向上的数值是有定义的情况。球面、半球面函数都称为球基函数。将现有函数转换到特定表示的过程被称为“投影”，从特定表示中计算原函数的值被称为“重建”。

每一种表示方式都有其优缺点，我们在特定基底上寻求的特性一般有：

- 高效的编码和解码
- 以很少的系数和重建误差来表示任意球面函数
- 旋转不变性（旋转后投影和投影后旋转的结果不变）
- 编码后的函数上易于求和与乘积运算
- 易于球面积分和卷积运算

---

**简表形式**

表示球面函数的最直接的一种方式便是选取一些方向，将其值存储在一张表里。计算函数值就是在求值方向周围寻找采样点，通过一些插值进行重建。可以通过增加采样点来提高不同球面函数编码的准确性。

将样本按容易获取的方式分布在一个球面上，且均等地表示各个方向并不容易。最常用的方法是将球面展开成一个矩形域后用网格点采样，这就可以使用纹理来存储采样值，因而可以利用 GPU 加速纹理的双线性滤波来快速重建。

简表形式也有其缺点：低分辨率下的硬件滤波结果通常难以接受；卷积运算的复杂度和采样点数量成比例，有时会非常高；不具备旋转不变性，这会使编码的辐射度能量发生变动，在动画场景中表现为震动走样。通常，以上问题大多可以通过提高采样数来解决。

简表形式适用于存储复杂高频函数，并在编码中尽可能减少误差的情况。如果希望减少数据量，就需要考虑更复杂的基底。

很常用的一种简单基底是 ambient cube(AC)，由沿主轴方向的六个平方余弦 lobe 构成。被称为 ambient cube 是由于它等价于将数据存储在立方体的六个面上，并从一个方向到另一个方向插值。对于任意给定的方向，只有三个 lobe 与其相关。AC 与立方体贴图（cube map）相似。在一些系统中，AC 重建要比 GPU 在立方体贴图上做双线性滤波更快。Sloan 给出了在 AC 和球谐基底之间变换的简单方程。使用 AC 重建的质量很低，一种简单的优化方式是使用 8 个顶点值替代原先的 6 个值。最近有另一种称为 ambient dice(AD)的方法。

---

**球面基底**

投影最主要的目的就是寻找一种数学表达可以将球面域展开成若干个可变参数。之后就可以通过这种数学表达来拟合原先的球面函数。其中最基础的数学表达就是使用一个常数：

$F_c(\theta,\phi)=c\cdot1$

常数的选取可以通过计算球面函数$f$的平均值：$c=\frac{1}{4\pi}\int_{\Omega}f(\theta,\phi)$。周期函数的均值$c$也被称为直流分量。虽然它很简单，但它并不能很好地描述大部分的球面函数。

我们可以扩展使用两个系数来构造近似函数：

$F_{hemi}(\theta,\phi)=a+\frac{cos(\theta)+1}{2}(b-a)$

该函数可以精确地表示极点上的值，并对其间的值使用插值表示，实际上该式可以看作使用两个采样点的简表形式。该式不具备旋转不变性。

一般，当我们提到“基函数空间”时，意味着我们有一组基函数可以通过线性组合来表示其他的函数。

**球面径向基函数**

表格形式的滤波重建质量低的原因是在于所使用的双线性插值函数。可以使用其他的权重函数来重建采样点，其中一类函数便是球面径向基函数（SRBFs）。该类函数径向对称，这使得它们只需要一个参数，即它们的轴向和目标方向之间的夹角。基底便是由这样一类基函数组成，它们分布在球体中，被称为 lobes。为了方便投影，lobes 的方向通常是固定的，所以参数一般不包括方向。重建的方式是计算给定方向在所有 lobes 上的值，然后将这些值加起来。

**球面高斯**

一种最常用的球面径向基函数 lobe 是球面高斯(_spherical Gaussian, SG_)，在方向统计中也被称为*von Mises-Fisher*分布，但在此处我们不适用 von-Mises-Fisher 分布中的归一化常数。SG lobe 的定义为：

$G(\textbf{v},\textbf{d},\lambda)=e^{\lambda(\textbf{v}\cdot\textbf{d}-1)}$

其中，$\textbf{v}$是（单位）目标方向，$\textbf{d}$是 lobe 的方向轴（分布的均值，也是单位的），$\lambda\geq0$是 lobe 的锋利程度。为了构造球面基底，需要将多个球面高斯函数线性组合：

$F_G(\textbf{v})=\underset{k}{\sum}w_kG(\textbf{v},\textbf{d}_k,\lambda_k)$

为了将球面函数投影到上式中，就需要找到一组参数$\{w_k,\textbf{d}_k,\lambda_k\}$使得重建的误差最小。这需要采用数值优化方法，一般采用非线性的最小二乘法（如 Levenberg-Marquardt）。如果允许对整个参数集合使用数值优化，最终得到的可能就不是线性组合的基底。一种更合适的基底选择是使用固定的几个 lobes（确定的方向和锋利度），只需要对权值$w_k$做拟合。这样也可以简化数值优化问题，只需要做线性最小二乘即可。而且这样做也有利于不同数据集之间的插值。

使用球面高斯的优势是，许多操作会比较简单，比如两个球面高斯的乘积还是一个球面高斯：

$G_1G_2=G(\textbf{v},\frac{\textbf{d}'}{\|{\textbf{d}'}\|},\lambda')$

其中，$\textbf{d}'=\frac{\lambda_1\textbf{d}_1+\lambda_2\textbf{d}_2}{\lambda_1+\lambda_2},\quad \lambda'=(\lambda_1+\lambda_2)\|{\textbf{d}'}\|$

球面高斯的积分也可以解析地计算：

$\int_{\Omega}G(\textbf{v})d\textbf{v}=2\pi\frac{1-e^{2\lambda}}{\lambda}$

这也意味着两个球面高斯函数的乘积的积分也是简洁的。

如果我们能将光照辐射度使用球面高斯表示，我们就可以将它和同样使用 SG 编码的 BRDF 做乘积，来进行光照计算。因此，SG 在学术界和工业界使用很广。

对于平面上的高斯分布，von-Mises-Fisher 分布可以被推广为各向异性分布。Xu 等人提出的各向异性球面高斯（ASGs）通过将方向$\textbf{d}$扩展为两个切线空间的轴向$\textbf{t},\textbf{b}$来支持：

$G(\textbf{v},[\textbf{d},\textbf{t},\textbf{b}],[\lambda,\mu])=S(\textbf{v},\textbf{d})e^{-\lambda(\textbf{v}\cdot\textbf{t})^2-\mu(\textbf{v}\cdot\textbf{b})^2}$

其中，$\lambda,\mu>0$，它们控制 lobe 沿着两个轴向的锋利度；$S(\textbf{v},\textbf{d})=(\textbf{v}\cdot\textbf{d})^+$是光滑项，它是 Fisher-Bingham 分布与 ASGs 的主要不同之处。Xu 等人也提供了 ASGs 用于积分、乘积和卷积运算的解析近似式。

虽然球面高斯有很多非常好的性质，但它的一个缺陷是，不像简表形式可以在有限的区间计算，球面高斯是全局支撑的，它的每一个 lobe 都是非零的。这意味着如果我们使用 N 个 lobes 去表示球面函数，就需要全部的 N 个来重建。

**球谐**

球谐（_Spherical harmonics, SH_）是一类球面上的正交基函数。所谓正交基函数，就是指其中的任意两个函数的内积都为零。内积是一种和点乘很相似的概念，向量的内积就是它们的点乘，函数的内积是由乘积的积分导出的：

$<f_i(x),f_j(x)>=\int f_i(x)f_j(x)dx$

上式的积分是在相关域上进行的。对于球面函数，内积的形式会略有区别：

$<f_i(\textbf{n}),f_j(\textbf{n})>\equiv\int_{\textbf{n}\in\Theta}f_i(\textbf{n})f_j(\textbf{n})d\textbf{n}$

其中，$\textbf{n}\in\Theta$说明积分是在单位球面上进行的。

标准正交集是指，一个正交集还额外满足了当且仅当集中的函数和自己求内积时才等于 1：

$<f_i(),f_j()>=\left\{\begin{matrix}0,&{where\space i\neq j,}\\1,&{where\space i=j.}\end{matrix}\right.$

使用标准正交基的好处是可以直接得到闭合形式的近似。投影得到的系数是原函数和合适基底的内积：

$k_j=<f_{target}(),f_j()>\\f_{target}()\approx\underset{j=1}{\overset{n}{\sum}}k_jf_j()$

实际上，该积分将通过数值方式计算，典型的方法是通过蒙特卡洛采样，给球面上均匀分布的 n 个方向取均值。

球谐函数是标准正交的，而且它们还有其他优点。球谐函数具有旋转不变性；球谐基函数的计算较小；球谐函数是 x,y,z 坐标上单位向量的简单多项式。但是，和球面高斯一样，球谐函数是全局支撑的，所以需要全部基函数参与重建计算。

球谐基底按频带排列，第一个基底是常数，接下来的三个基底是球面上缓慢变化的线性函数，再后的五个基底是变化稍快一些的二次函数。低频的函数，比如辐照度，可以用相对较小的球谐系数精确地表示。

当投影到球谐函数时，得到的系数是不同频率的投影函数的振幅，或者说是频谱。其中，两个函数的乘积的积分等同于它们投影系数的点乘。这使我们得以高效地计算光照积分。

大多数球谐函数上的操作都很简单，可以简化为对系数向量的矩阵变换。这些操作中比较重要的操作是计算两个投影到球谐上的函数的乘积、旋转投影函数、计算卷积。球谐函数中的矩阵变换实际上意味着系数个数的平方复杂度，这可能是一个巨大的计算开销。幸运的是，这些矩阵通常都具有特殊的结构，可以用来设计快速算法。Kautz 等人提出了一种优化方法，将旋转计算分解成关于 x 和 z 轴的旋转。目前最好的方法是分解成 zonal 谐函数，由 Nowrouzezahrai 等人提出。

当原始信号中包含快速变化的信息，重建结果可能会产生振荡。极端情况下，重建的函数甚至会产生负值。可以使用预滤波来缓解这个问题。

**其他球面表示**

也有很多其他的表示可以通过一些有限的系数来编码球面函数。线性变换的余弦函数就是一个近似表示 BRDF 的例子。球面小波是一种平衡了空间局部性和频率局部性的基底，可以对高频函数进行压缩表示。球面分段常量基函数将球面划分成多个常量值，通过双聚簇近似，也被用于环境光照中。

---

**半球面基底**

尽管之前提到的基底也可以用于表示半球面的函数，但都太浪费了，近一半的信号都会接近于 0。这种情况下就应该使用一些直接在半球面上构造的表示方法。这类方法和定义在表面的函数紧密相关，比如 BRDF、入射辐射度、某点受到的辐照度等。

**环境光/高光/方向**

最简单的一种表示是将一个常数和一个方向结合，该方向是半球面上信号最强烈的方向。这种表示方法一般被称为“环境光/高光/方向”（AHD）基底，它常被用于存储辐照度。名字即表示了各部分表示的内容：一个常数环境光，一个近似高光方向辐照度的平行光，以及一个入射光线集中的方向。AHD 基底通常需要存储八个参数，两个角度参数用于表示方向，两个 RGB 向量用于表示环境光和平行光强度。

用这种表示方式是有些困难的，因为它不是线性的，寻找最优拟合参数的计算开销很大。实际使用中采用一些启发式的算法。先将信号投影到球谐函数上，将最优线性方向作为余弦 lobe 的方向。得到方向后就可以通过最小二乘法计算环境光和高光的值。

**辐射度法线映射/半衰期 2 基底**

Valve 公司使用了一种创新的表示方法，用在半衰期 2 系列游戏中。起初是打算在允许法向映射的同时，存储预计算的漫反射光照。该技术现在常被称为“半衰期 2 基底”，它通过采样切线空间中的三个方向来表示物体表面的半球面函数。这三个在切线空间中相互垂直的方向组成了坐标基：

$\textbf{m}_0=(\frac{-1}{\sqrt{6}},\frac{1}{\sqrt{2}},\frac{1}{\sqrt{3}}),\quad\textbf{m}_1=(\frac{-1}{\sqrt{6}},\frac{-1}{\sqrt{2}},\frac{1}{\sqrt{3}}),\quad\textbf{m}_2=(\frac{\sqrt{2}}{\sqrt{3}},0,\frac{1}{\sqrt{3}})$

重建时，只需要得到切线空间的方向$\textbf{d}$，就可以沿着坐标基插值这三个值：

$E(\textbf{n})=\frac{\underset{k=0}{\overset{2}{\sum}}\rm{max}(\textbf{m}_k\cdot\textbf{n},0)^2E_k}{\underset{k=0}{\overset{2}{\sum}}\rm{max}(\textbf{m}_k\cdot\textbf{n},0)^2}$

Green 还给出了结合预计算的优化方法，详见书 P403。

**半球谐波/H-基底**

Gautron 等人将球谐函数特化出了半球谐波函数（HSHs）。泽尼克多项式是类似于球谐函数的正交函数，但它是定义在单位圆盘上的。类似于球谐函数，这些函数可以在频域内变换函数。我们可以将一个单位半球面转换为圆盘，然后使用泽尼克多项式来表示半球面函数。但是，对它们进行重建的开销很大。Gautron 等人给出了一种使用系数向量的矩阵乘法的解决方案。

但是，HSH 基底仍然比球谐函数的计算开销大，因为它是将球面的负极移到半球面的外边构造的。移动操作使得基函数不再是多项式，需要进行除法和开方运算，这些计算在 GPU 上都是非常慢的。更糟糕的是，近似误差在接近边界的地方会很大。

Habel 提出了 H-基底，其中包括了经度方向参数化的球谐基底，维度方向则使用了部分半球谐波基底。该基底混合了移动和未移动版本的球谐函数，它仍然是正交基底，可以有效地进行计算。

#### 9.6 环境映射

将球面函数记录在一张或多张图片中的方法称为环境映射，通常使用纹理映射来实现查找表。这是最常用的一种环境光照表示方法。相比于其他的球面表示方法，它虽然内存开销大，但简洁快速，还能精确地表示任意高频的球面信号。环境贴图中存储的辐射度值通常都是高动态范围的，更多的比特位往往意味着更大的空间占用和更慢的访问速度。

对于全局球面函数通常会有一些基本假定，比如入射辐射度只和方向有关，这也意味着环境光和物体相距很远，且物体不反射环境光。

使用环境映射的着色技术更主要的目标是找到适合的近似和假设来完成 BRDF 上环境光照的积分。反射映射是环境映射最基础的情形，这种情况下我们假设 BRDF 是一种完美镜面，镜面将入射光线反射至反射方向$\textbf{r}_i$。类似的，出射辐射度也仅包含来自于单一方向（视线的反射方向）的入射辐射度。镜面反射方程可以简化为：

$L_o(\textbf{v})=F(\textbf{n},\textbf{r})L_i(\textbf{r})$

其中，$F$是菲涅尔项，但与半向量 BRDF 中的菲涅尔项不同的是，此处的菲涅尔项使用的是法线$\textbf{n}$和反射方向$\textbf{r}$（该夹角与$\textbf{n},\textbf{v}$之间的夹角是相同的）。

由于入射辐射度$L_i$仅与方向有关，所以能存储在一张二维表中。通过计算视线的反射方向$\textbf{r}$就可以得到每个着色点的采样方向。这张二维表便是环境贴图。反射映射算法的步骤是：

- 生成或加载一张环境纹理
- 对于有反射的像素，计算其所对应的物体表面上的法线
- 根据视线方向和法线计算反射方向
- 根据反射方向采样环境贴图
- 将采样结果作为入射辐射度

有一个潜在的问题值得注意，平坦表面上使用环境映射的效果并不好，这是由于反射方向在平坦表面上的差别不大，使得环境贴图中较小的区域就能覆盖整个平面。使用考虑了位置信息的方法可以改善这个问题。当然，如果是完全平坦的表面，比如地面，可以使用平面反射这样的技术。

这种使用纹理数据照亮场景的方法也被称为基于图片的光照（IBL），特别是在现实世界中使用相机捕获全景照片作为环境贴图。另外，结合法线映射使用环境映射非常有效，可以产生丰富的视觉效果。

以下介绍几种映射技术

**经纬度映射**

1976 年，Blinn 和 Newell 发明了第一个环境映射算法。他们所使用的映射技术是我们所熟悉的使用在地球仪上的经纬度系统，所以该技术被称为经纬度映射。但不像地球仪是从外观察的，他们映射的环境更像是夜空中的星图。正如地球仪上的信息可以使用墨卡托投影之类的方法投影到平面上，围绕某点的环境也可以被映射进一张纹理中。视线的反射向量会被转化为用球坐标$(\rho,\phi)$表示，其中的圆周角$\phi$相当于经度，范围在$0\sim2\pi$；仰角$\rho$相当于维度，范围在$0\sim\pi$。转换关系为：

$\rho=\rm{arccos}(r_z)\quad \phi=atan2(r_y,r_x)$

值得注意的是，经纬度映射与墨卡托投影并不完全相同。经纬度映射保持了纬度线之间的距离不变，而墨卡托投影在两极处趋于无穷。

映射到平面会产生扭曲，滤波的时候可能会产生瑕疵，特别是在两极处。

**球面映射**

球面映射技术由 Williams 提出，经 Miller 和 Hoffman 发展完善。球面映射是第一个支持通用商用图形硬件的环境映射技术。纹理图像是通过完美镜面球的正交观察获取的环境信息，因此该纹理被称为球面贴图。获取真实自然环境的球面贴图的一种方式是，给一个光泽球拍一张照片。

这张图像也被称为“光照探针”，因为它捕获了球体所处位置的光照环境。

为了从反射方向采样球面贴图，就需要知道每一点的法线信息。球面的法向量是视线方向和反射方向的半角向量，视线方向在球面贴图空间中的方向为$(0,0,1)$，则法向量为$(r_x,r_y.r_z+1)$，归一化后得到$\textbf{n}=(\frac{r_x}{m},\frac{r_y}{m},\frac{r_z+1}{m}),\quad m=\sqrt{r_x^2+r_y^2+(r_z+1)^2}$

如果球位于原点且半径为 1，则$\textbf{n}$就是球面的采样位置$\textbf{h}$，我们不需要$h_z$，$(h_x,h_y)$就描述了球面图像上的位置，但它的范围在[-1,1]。为了得到范围在[0,1]的球面贴图坐标，需要进行简单变换：

$u=\frac{r_x}{2m}+0.5,\quad v=\frac{r_y}{2m}+0.5$

球面映射简单好算，但它的缺陷是球面贴图只能捕获一个有效视线方向的环境信息。实际上，纹理中是包含了完整的环境信息的，但是为另一个视线方向计算纹理坐标通常会产生视觉瑕疵。实际使用中假定了球面贴图会朝向相机。

也可以通过索引两张球面贴图来存储环境光照，一张描述反射向量，另一张描述表面法线，可用于模拟镜面环境光和漫反射环境光。如果调整球面贴图中存储的值，使其考虑颜色和粗糙度，就可以用较低的计算开销生成很真实的材质效果。

**立方体映射**

1986 年，Greene 提出了立方体环境贴图，通常被称为立方体贴图。该技术影响深远，至今仍然是最主流的方案，它的投影已经直接写进了现代 GPU 的硬件实现。立方体贴图是通过将环境信息投影到立方体上得到的。

也可以通过数字合成的方式得到立方体贴图，只需要以$90\degree$视角渲染相机的上下左右前后六个面即可。从现实中生成立方体贴图则需要通过缝合或者使用特制相机来将全景画面投影到立方体贴图坐标系中。

立方体环境映射是视角无关的，这一点与球面映射不同，同时它也比经纬度映射更加均匀。

**其他投影方法**

虽然在今天，立方体贴图是最主流的环境光照表示方式，具有灵活性，可以重现高频细节，还可以使用硬件加速；但是仍然有一些其他的投影技术值得提及。

Heidrich 和 Seidel 提出一种使用两张纹理的双抛物面环境映射。该方法的思路与球面映射类似，但并不是记录球面的反射信息，而是使用两个抛物面来做投影。每个抛物面会生成一个类似于球面贴图的圆形纹理，覆盖一个半球面。

八面体映射是另一种值得一提的投影方式。它将周围环境映射到一个八面体中，它的八个三角面被裁剪后排列进一个平面中。

#### 9.7 基于图像的镜面反射光

虽然环境映射最初是用于渲染镜面表面的技术，但也可以用于光泽反射。当用于模拟无限远光源的镜面反射效果时，环境贴图也被称为镜面反射探针。镜面立方体贴图也被用于模拟光泽材质表面的反射。

为了模拟表面的粗糙度，环境纹理可以先进行预滤波。模糊环境贴图就可以得到看上去更粗糙一些的镜面反射。这类模糊应当使用非线性的方式，因为环境贴图在球面空间的映射是一种非线性的映射。

理论上应当考虑表面的 BRDF 函数，但使用镜面 lobe 进行环境贴图的滤波并不容易，输入值至少是一个五维的数据，存储这样的环境贴图是不可能的。

**预滤波的环境映射**

实际使用的环境光照预滤波需要对 BRDF 进行近似，使得到的纹理不再依赖于视线和法线。

更粗糙的材质，其滤波区域更大，移除了其中的高频信息，则只需要较低的分辨率存储，很适合使用多级纹理（mipmap）。使用 GPU 硬件的三线性滤波可以在预滤波的两个 mip 层级间采样。再结合菲涅尔项，这样的预滤波反射对于光泽表面的效果非常好。

出于性能和抗锯齿考虑，mipmap 层级的选择应当包括着色点的粗糙度和屏幕像素所覆盖区域的法线和粗糙度变化。

上述提到的滤波方法假设了 lobe 对于不同反射反向都是相同的形状和高度，这意味着 lobes 都是径向对称的，但实际不然，这可能对于曲面不易察觉，但平面（比如地面）上的径向对称滤波会产生很明显的错误。

**卷积环境贴图**

将环境辐射度$L_i$和镜面反射 lobe $D$积分：

$\int_\Omega D(\textbf{l},\textbf{v})L_i(\textbf{l})d\textbf{l}$

该积分即为一个球面卷积，且一般情况下无法求出解析解，因为环境辐射度$L_i$是通过查找表获得的。常用的数值求解方法是蒙特卡洛方法：

$\int_\Omega D(\textbf{l},\textbf{v})L_i(\textbf{l})d\textbf{l}\approx\underset{N\rightarrow\infin}{\rm{lim}}\frac{1}{N}\overset{N}{\underset{k=1}{\sum}}\frac{D(\textbf{l}_k,\textbf{v})L_i(\textbf{l}_k)}{p(\textbf{l}_k,\textbf{v})}$

其中，$\textbf{l}_k$是单位球面上（各方向）的离散采样点，$p(\textbf{l}_k,\textbf{v})$是在$\textbf{l}_k$方向生成采样点的概率函数。

蒙特卡洛方法虽然简单而正确，但是收敛过程很慢。为了提高速度，我们可以采用重要性采样做优化。我们使用贴近于镜面反射 lobe 的概率分布来生成采样方向，这是一种常用于蒙特卡洛积分的降低方差技术，且绝大多数的 lobes 都可以使用重要性采样策略。为了进一步提高效率，还可以同时考虑镜面 lobe 的形状和环境贴图的辐射度分布。

为了大幅减少采样偏差（噪声），我们也可以评估使用圆锥进行采样积分和使用单一方向进行采样积分的差别。在圆锥上进行采样可以近似为在 mipmap 上的点采样，这样做虽然会引入偏差，但是能大幅减少需要的采样数。

Kautz 等人提出了另一种技术，他们使用分层技术快速生成滤波后的抛物线反射贴图。Manson 和 Sloan 进一步发展了该技术，他们使用高效的二次 B 样条滤波生成环境贴图的 mipmap，然后通过类似于区域采样的方法，可以得到实时的近乎无区别的环境光照结果。

快速卷积技术可以实时地更新预滤波的立方体贴图，这对于动态地滤波环境贴图是必不可少的。使用环境贴图的一个弊端是难于表现在不同光照环境中移动的物体，比如从一个房间进入另一个房间。但如果使用搞笑的滤波算法，立方体环境贴图可以实时地重新生成，这样就可以相对容易地切换使用不同的镜面反射贴图。

如果几何体是静态地，只有一些光源会移动（比如太阳），一种开销较低的方法是将表面属性（位置、法线和材质）存储进 G-buffer 中，这样就不需要将整个场景动态地渲染进立方体贴图中。

**微平面 BRDF 的分离积分近似**

有一种 BRDF 的积分近似方法，是先作为 Phong lobe 积分，然后乘上一个完美镜面的菲涅尔项：

$\int_{\textbf{l}\in\Omega}f(\textbf{l},\textbf{v})L_i(\textbf{l})(\textbf{n}\cdot\textbf{l})d\textbf{l}\approx F(\textbf{n},\textbf{v})\int_{\textbf{l}\in\Omega}D_{Phong}(\textbf{r})L_i(\textbf{l})(\textbf{n}\cdot\textbf{l})d\textbf{l}$

其中，$\int_\Omega D_{Phong}(\textbf{r})$是将各方向的$\textbf{r}$预计算进环境立方体贴图中。考虑镜面微平面 BRDF 模型，即使将其中的$D(\textbf{h})\approx D_{Phong}(\textbf{r})$，仍然还剩一部分项未被考虑。阴影项$G_2(\textbf{l},\textbf{v},\textbf{h})$和菲涅尔项$F(\textbf{h},\textbf{l})$在积分之外的应用并无理论基础，所以被移除了。

Lazarov 证明，额外乘上一个依赖于$\textbf{n}\cdot\textbf{v}$的完美镜面菲涅尔项，会比完全不使用菲涅尔项引入更大的误差。Gotanda、Lazarov 和 Karis 各自独立地提出了相似的分离积分近似：

$\int_{\textbf{l}\in\Omega}f_{smf}(\textbf{l},\textbf{v})L_i(\textbf{l})(\textbf{n}\cdot\textbf{l})d\textbf{l}\approx\int_{\textbf{l}\in\Omega}D(\textbf{r})L_i(\textbf{l})(\textbf{n}\cdot\textbf{l})d\textbf{l}\int_{\textbf{l}\in\Omega}f_{smf}(\textbf{l},\textbf{v})(\textbf{n}\cdot\textbf{l})d\textbf{l}$

分离出来的两项积分都可以高效地预计算。第一项只依赖于表面粗糙度和反射向量，以及假设 BRDF 是一个径向对称的$D$ lobe。第二项积分是镜面反射项的半球方向反射率$R_{spec}(\textbf{v})$，该函数依赖于仰角$\theta$，粗糙度$\alpha$，以及菲涅尔项$F$。其中，$F$使用 Schlick 近似。因此，$R_{spec}$是一个有三个参数的函数。Gotanda 是将$R_{spec}$预计算出来，存储在一张三维查找表中；Karis 和 Lazarov 则注意到$F_0$可以从$R_{spec}$中提取出来，则每部分只有两个参数（仰角和粗糙度），这样 Karis 就可以将$R_{spec}$预计算为一张二维查找表，而 Lazarov 则推导出了近似的解析函数。

分离积分近似最主要的误差来源是限定了径向对称和无裁剪的镜面反射 lobes。

**不对称、各向异性的 Lobes**

目前已经讨论的方案都基于镜面反射 lobes 呈各向异性的假设。这种假设意味着入射方向和出射方向绕表面法线旋转并不会发生变化。微平面 BRDF lobes 是基于半向量定义的，并不具有对称性（即使是各向同性的 lobe）。半向量一阿里与光线方向$\textbf{l}$，在环境光照种是没有定义的，所以我们假定$\textbf{n}=\textbf{v}=\textbf{r}$，并导出一个常值粗糙度修正系数，用于拟合原式的镜面反射高光。这些假设都是很大的误差来源。

#### 9.8 辐照度环境映射

前几节讨论了为光泽镜面反射使用滤波的环境贴图。这些贴图也可以用在漫反射上。用于镜面反射的环境贴图有着相同的属性，无论是用于完美镜面反射的未滤波环境贴图，还是用于光泽反射的滤波后环境贴图，镜面反射环境贴图都按反射向量索引，它们包含辐射度信息。未滤波的环境贴图包含入射辐射度，滤波的环境贴图包含出射辐射度。

相反，用于漫反射的环境贴图则只通过表面法线$\textbf{n}$索引，它们只包含辐照度信息。因此，它们被称为“辐照度环境贴图”。由于辐照度环境贴图比原始光照模糊太多，所以能用很低的分辨率存储。通常使用预滤波的镜面反射环境贴图中最低一级的 mipmap 来存储辐照度数据。

对于贴图中的每个纹素，需要将对于给定法线方向的全部光照影响的余弦加权贡献值加起来。

辐照度环境贴图会与镜面反射环境贴图分开来存储和使用，通常使用与视角无关的方式，比如立方体贴图。从辐照度环境贴图中获取的值会用来与漫反射相乘，而从镜面反射环境贴图中获取的值会用来与镜面反射相乘。也可以考虑进菲涅尔效果，只需要在掠射角时增加镜面反射，减少漫反射即可。

由于辐照度环境贴图的滤波范围很大，很难实时地通过采样生成。King 提出将环境贴图转换到频域卷积。

漫反射或粗糙表面的滤波后环境贴图通常可以用很低的分辨率存储，但有时也可以从低分辨率的反射贴图中生成。这个方法的一个问题是，将面光源渲染进这样小的纹理中可能会使光源闪烁或者消失。

动态光源也可以添加进预滤波的辐照度环境贴图中。一种开销较低的方法是，将辐照度贴图视为一个光源。光源方向上的辐射度达到最大，物体表面法线方向的辐射度随相对夹角的增大而衰减，直至为零。GPU 可以将该贡献度快速地加到一张辐照度贴图中。

**球谐辐照度**

除了使用纹理贴图存储辐照度环境贴图，也可以使用球谐函数表示辐照度环境贴图。因为环境光照地辐照度是平滑地，辐射度和余弦 lobe 的卷积会消除环境贴图中的所有高频信息。

Ramamoorthi 和 Hanrahan 证实，使用前 9 个球谐系数存储辐照度环境贴图只需要$1\%$的数据量。两人还证实，入射辐射度的球谐系数可以通过乘以一个常数转变为辐照度的球谐系数。这样处理可以快速地将环境贴图滤波为辐照度环境贴图。从辐射度计算辐照度，等价于对入射辐射度函数$L(\textbf{l})$和钳制余弦函数$cos(\theta_i)^+$做球面卷积。由于钳制余弦函数是关于 z 轴旋转对称的，就可以假设一种特殊的球谐形式：它在每个球谐频带上的投影只有一个非零系数。该非零系数所对应的基函数被称为 zonal harmonics。

在一个球面函数和一个旋转对称的函数间做球面卷积的结果是另一个球面函数。该卷积可以在球谐系数上高效进行。卷积结果的球谐系数等于两个函数系数的乘积，然后通过$\sqrt{4\pi/(2l+1)}$缩放，其中的$l$是频带序号。这样，辐照度函数$E(\textbf{n})$的球谐系数就等于辐射度函数$L(\textbf{l})$乘以经频带常数缩放后的$cos(\theta_i)^+$。$cos(\theta_i)^+$的前九个以外的系数都非常小，这也说明了对于辐照度函数$E(\textbf{n})$来说，前九个系数就足够了。

虽然$E(\textbf{n})$的高阶系数很小，但它们不是零。钳制余弦函数和它的九系数球谐近似非常接近，但在球谐曲线的$\pi/2\sim\pi$出现了摆动，此处应当是 0，这种现象在信号处理中被称为“振铃”，它一般发生在使用较少的基函数近似高频函数的时候。振铃一般不会很明显，但在一些极端光照条件下会引起颜色偏移和阴影上的白色斑块。如果辐照度环境贴图仅被用于存储间接光照，那么振铃现象就不是问题，预滤波技术会解决该问题。

动态渲染的立方体环境贴图也可以被投影到球谐基底上。由于立方体环境贴图是入射辐射度函数的离散表示，它的球面积分就变成了立方体贴图上的求和：

$k_{Lj}=\underset{t}{\sum}f_j(\textbf{r}[t])L[t]d\omega[t]$

其中，$t$是当前立方体贴图纹素的索引，$\textbf{r}[t]$是指向当前纹素的方向，$f_j(\textbf{r}[t])$是$\textbf{r}[t]$在第 j 个球谐基底上的值，$L[t]$是存储在当前纹素中的辐射度，$d\omega[t]$是当前纹素所覆盖的立体角。

为了将辐射度系数$k_{Lj}$转换为辐照度系数，就需要将它们乘以缩放过的钳制余弦函数的系数：

$k_{Ej}=k_{cos^+j}'k_{Lj}=k_{cos^+j}'\underset{t}{\sum}f_j(\textbf{r}[t])L[t]d\omega[t]$

其中，$k_{Ej}$是辐照度函数$E(\textbf{n})$的第 j 个系数，$k_{Lj}$是入射辐射度函数$L(\textbf{l})$的第 j 个系数，$k_{cos^+j}'$是钳制余弦函数$cos(\theta_i)^+$用$\sqrt{4\pi/(2l+1)}$缩放后的第 j 个系数。

给出$t$以及立方体贴图分辨率，则因子$k_{cos^+j}'f_j(\textbf{r}[t])d\omega[t]$对于基底$f_j()$来说就是变换常数。该变换常数可以先离线预计算并存储进一张立方体贴图中，该贴图的分辨率与动态环境贴图一致。通过将变换常数分别存储进不同的颜色通道中可以减少所需的纹理数量。为了计算动态立方体贴图的辐照度系数，就需要将不同的变换常数与动态立方体贴图相乘，将乘积加起来。

动态光源也可以加到球谐辐照度环境贴图中。这通过计算光源辐照度贡献的球谐系数，并将它们加到已有的系数上实现。这样做也可以避免重新计算整张辐照度环境贴图。这是一种直观的处理，因为简单解析式（点、圆盘、球面光源）的系数是现成的。将球谐系数相加等同于辐照度相加。通常，这些都使用 zonal harmonics 表示，光源沿着 z 轴，然后通过旋转就可以将光源放在任意的方向上。zonal harmonics 旋转是一种特殊的球谐旋转，非常高效，只需要进行点乘。复杂形状光源的系数，可以先将形状存进一张图片里，然后用数值方法投影到球谐基底上。对于特殊的物理天空模型，Habel 给出了一种 Preetham 天空光照在球谐上的直接扩展。

将常用的解析光源投影到球谐基底上是很重要的，环境照明通常被用于替代远距离或低强度光源。补光光源是一个重要的例子，渲染中用这些光源来模拟场景中的间接光照，例如物体表面的光线弹射。镜面反射部分一般不包含补光光源，特别是当这类光源很大又很暗的时候，它们会使镜面反射高光变散变暗。这类光源在电影打光中有与其对应的光源类型，现实中使用补光光源通常是为了增加阴影的亮度。

在球谐空间中做反向导出也是容易的，也就是从球谐投影中提取出解析光源。Sloan 在论文中展示了如何根据给定的平行光源轴向，从球谐辐照度中计算出它的光照强度。在 Sloan 之前的工作中便展示过如何仅通过第一个频带来得到接近最优的方向。后续的这篇论文中则包含了提出多个平行光的方法。这些工作展示了球谐函数巨大的实用价值。我们可以将大量光源投射到球谐函数上，然后提取出几个平行光源来近似。

虽然在辐照度中用得最多，但球谐投影也可以用在模拟光泽以及依赖视角的 BRDF 光照上。Ramamoorthi 和 Hanrahan 给出了这样的技术。他们将依赖视角的环境贴图编码进球谐函数并存储进立方体贴图中。虽然这种技术会占用比预滤波环境贴图多得多的空间，Kautz 给出了一种更加经济高效方案，只使用二维表来存储球谐系数，但是只能用于低频光照。

**其他方法**

虽然立方体贴图和球谐函数是最常用的方法，但辐照度环境贴图也可以使用其他方法。

大部分的辐照度环境贴图都有两个颜色域：顶部的天空色，底部的地面色。基于此观察，Parker 等人提出了只使用两种颜色的半球面光照模型。上方的半球面均匀地发射天空辐射$L_{sky}$，下方地半球面均匀地发射地面辐射度$L_{ground}$。辐照度地积分则为：

$E=\left\{\begin{matrix}\pi((1-\frac{1}{2}sin\theta)L_{sky}+\frac{1}{2}sin\theta L_{ground}),&{where\space \theta<90\degree}\\\pi(\frac{1}{2}sin\theta L_{sky}+(1-\frac{1}{2}sin\theta)L_{ground}),&{where\space \theta\geq 90\degree}\end{matrix}\right.$

其中，$\theta$是表面法线和天空半球面轴线的夹角。Baker 和 Boyd 提出了快速近似版本：

$E=\pi(\frac{1+cos\theta}{2}L_{sky}+\frac{1-cos\theta}{2}L_{ground})$

上式其实是对天空辐射度和地面辐射度的线性插值，使用$(cos\theta+1)/2$作为插值系数。

Forsyth 提出了一种计算开销不大且灵活的光照模型，被称为*trilight*(三线性光照)，使用方向、副方向、半球面和包裹照明。

如果需要计算光泽反射、遮挡或全局光照效果，就需要更复杂的表示方法存储高频信息。使用预计算光照来考虑光照交互的方法被统称为“预计算的辐射度传播”（PRT）。为光泽光照捕获高频信息的方法也被称为“全频光照”。Ng 等人描述了如何使用哈尔小波生成考虑了自阴影的辐照度环境映射，他们使用小波基底同时存储了环境贴图和阴影函数。

#### 9.9 误差来源

开发实时渲染着色模型时的一个重要工作是确保不同形式光照下的差异很小。具有可解释性的光照结果也许比实际的误差值更重要。

遮挡对于真实感渲染是至关重要的，但大多数面光源都不产生简单的阴影。今时今日仍然没有实时阴影技术可以精确地描述光源的形状。

我们假设了环境光照是无限远的，这并不可能。我们还假设了光源在半球面上均匀地发出辐射，这实际上也是重要的误差来源，因为真实光源通常有着强光方向。

### 10. 全局光照

辐射度是渲染过程的最终结果，因此，我们通过反射方程来计算：

$L_o(\textbf{p},\textbf{v})=\int_{\textbf{l}\in\Omega}f(\textbf{l},\textbf{v})L_i(\textbf{p},\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

其中，$L_o(\textbf{p},\textbf{v})$是表面位置$\textbf{p}$上沿视线$\textbf{v}$方向的出射辐射度，$\Omega$是$\textbf{p}$上的半球面，$f(\textbf{l},\textbf{v})$是沿着$\textbf{v},\textbf{l}$方向的 BRDF 值，$L_i(\textbf{p},\textbf{l})$是从$\textbf{l}$方向到达$\textbf{p}$的入射辐射度，$(\textbf{n}\cdot\textbf{l})^+$是两方向之间的点乘且对负值做了裁剪。

#### 10.1 渲染方程

反射方程只是渲染方程的一种特例，我们使用如下的渲染方程形式：

$L_o(\textbf{p},\textbf{v})=L_e(\textbf{p},\textbf{v})+\int_{\textbf{l}\in\Omega}f(\textbf{l},\textbf{v})L_o(r(\textbf{p},\textbf{l}),-\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

其中，$L_e(\textbf{p},\textbf{v})$是表面位置$\textbf{p}$沿$\textbf{v}$方向的自发辐射度；另外，上式已经过如下替换：

$L_i(\textbf{p},\textbf{l})=L_o(r(\textbf{p},\textbf{l}),-\textbf{l})$

上式是指由方向$\textbf{l}$进入位置$\textbf{p}$的辐射度，等同于其他位置上向$-\textbf{l}$方向发出的辐射度。在本例中，“其他位置”是通过光线投射函数$r(\textbf{p},\textbf{l})$定义的，该函数返回从$\textbf{p}$出发沿$\textbf{l}$方向遇到的第一个物体表面位置。

#### 10.2 通用全局光照

两种通用的解渲染方程的方法是有限元方法和蒙特卡洛方法。辐射度方法属于第一类；光线追踪属于第二类。这两种方法中，光线追踪用得最多，这是由于它可以在同一个框架下高效地求解各种光线传播，包括体积散射。光线追踪也更容易并行计算。

**辐射度**

辐射度算法是模拟漫反射表面之间光线弹射的第一个计算机图形学算法。它的基本思路很简单，即光线在环境中的弹射。当我们把灯打开，光照快速地达到平衡稳定。在这种稳定状态下，每个表面都可以被当作一个光源。基础的辐射度算法假定了所有间接光照都来自于漫反射表面，该假设对于像光泽大理石地面、镜面墙都是不适用的，但对于大部分场景来说都是合理的假设。

辐射度算法假定了每个表面都由若干个小块组成。对于每个小块，算法计算一个单独的平均辐射度值，因此，这些小块需要足够小，小到可以捕获所有的光照细节（如阴影边缘），但它们不需要和底层的三角形一一对应，也不需要大小一致。那么，第$i$个小块的辐射度为：

$B_i=B_i^e+\rho_{ss}\underset{j}{\sum}F_{ij}B_j$

其中，$B_i$表示第$i$个小块的辐射度，$B_i^e$是辐射出射度（也就是从第$i$个小块发出的辐射度），$\rho_{ss}$是次表面反照率。仅当该小块为光源时，自发光不为零。$F_{ij}$是第$i$个小块和第$j$个小块之间的形状因子。形状因子的定义为：

$F_{ij}=\frac{1}{A_i}\int_{A_i}\int_{A_j}V(\textbf{i},\textbf{j})\frac{cos\theta_i cos\theta_j}{\pi d^2_{ij}}da_ida_j$

其中，$A_i$是第$i$个小块的面积，$V(\textbf{i},\textbf{j})$是点$\textbf{i},\textbf{j}$之间的可见性，当它们之间互相可见时为 1，否则为 0。$c\theta_i,\theta_j$是$\textbf{i},\textbf{j}$连线和两个小块法线之间的夹角。$d_{ij}$是连线的长度。

形状因子是一个纯粹的几何项，它是离开第$i$个小块后进入第$j$个小块的均匀漫反射辐射度能量的比例。它们的面积、距离、朝向以及中间是否有遮挡，都会影响它们的形状因子。这些比例最终加起来为 1。

通过形状因子，各小块的辐射度方程就组成了线性系统。求解该系统就可以得到每个小块的辐射度。

由于辐射度算法的使用规模有限，且有着其他的局限性，经典辐射度算法已经很少使用了。但是，预计算形状因子的思想开始在光线传播中广泛流行。

**光线追踪**

光线投射是从一个位置发出射线来确认该位置上的物体是什么。光线追踪则是使用光线来确定不同场景元素之间的光线传播。最基础的情况下，光线从相机发出，穿过像素，到达场景。每一根光线会找到最靠近的物体，这个交点会被判断是否位于阴影处（通过向光源发出阴影射线来检测是否有遮挡）。不透明物体会直接阻断光线，而透明物体会减弱光线。其他光线可能从一个交点产生，如果表面是光泽的，光线会向反射方向生成。光线拾取了交点上的颜色，接着做阴影测试，然后再生成新的光线。

经典的光线追踪只能支持有限的效果：完美反射和折射，硬阴影。但是，它底层的原理可用于求解完整的渲染方程。渲染方程是递归的，这意味着对于每一根光线，我们都需要在另一个位置上重新计算一遍积分。幸运的是，解决这个问题已经有了坚实的数学基础。蒙特卡洛方法，最初被用于曼哈顿计划中的物理实验，正适合于求解该类问题。在积分域上大量随机采样计算被积函数，函数值被用于估算积分结果。采样点越多，精确度越高。该方法最重要的特性是，只需要计算采样点上的被积函数值。只要有充足的时间，可以计算出任意精度的积分结果。沿着路径的光提供了一个积分估计，这个过程被称为路径追踪。

路径追踪唯一的缺点是高保真度所需要的计算复杂度。对于电影级成像质量，需要追踪数十亿路径。这是由于我们从不计算积分，而是估计积分。如果路径太少，则近似值就不准确。另外，相邻的两个点的结果可能大不相同，这就形成了所谓的“高方差”，视觉上体现为图像噪声。人们提出了许多技术用于解决噪声问题，其中最著名的就是“重要性采样”。

#### 10.3 环境光遮蔽

**原理**

环境光遮蔽的原理可以直接从反射方程导出。先以兰伯特表面为例。兰伯特表面的出射辐射度$L_o$与表面辐照度$E$成正比。辐照度是入射辐射度的余弦加权积分。通常，辐照度依赖于表面位置$\textbf{p}$和表面法线$\textbf{n}$。我们也假设入射辐射度是常量，即$L_i(\textbf{l})=L_A$，那么辐照度的计算为：
$E(\textbf{p,n})=\int_{\textbf{l}\in\Omega}L_A(\textbf{n}\cdot\textbf{l})^+d\textbf{l}=\pi L_A$

其中，$\Omega$是半球面。由于常值均匀光照的假设，辐照度不依赖于表面位置和法线，是一个常量。上式并未考虑可见性，有些方向上可能会被遮挡。被遮挡的方向上，入射辐射度就不再是$L_A$了，我们再次假设被遮挡的方向上入射辐射度为 0。然后我们可以得到：

$E(\textbf{p,n})=L_A\int_{\textbf{l}\in\Omega}v(\textbf{p,l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

其中，$v(\textbf{p,l})$是可见性函数，如果从$\textbf{p}$向$\textbf{l}$方向遇到遮挡，函数值为 0，否则为 1。

归一化的、余弦加权的可见性函数积分，被称为环境光遮蔽：

$k_A(\textbf{p})=\frac{1}{\pi}\int_{\textbf{l}\in\Omega}v(\textbf{p,l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

它表示的是半球面上未被遮挡区域占比的余弦加权值。如果值为 0，则表示该点完全被遮挡；如果值为 1，则表示该点没有任何遮挡。如果一个模型是凸模型，且场景中没有任何其他物体，则该模型的环境光遮蔽始终为 1；如果模型存在凹面，则环境光遮蔽值会小于 1。

环境光辐照度可以计算：

$E(\textbf{p,n})=k_A(\textbf{p})\pi L_A$

现在的辐照度就随位置变化了，因为$k_A$会随位置变化。急剧凸起的表面会大幅降低$k_A$；由于$k_A$是余弦加权的，所以即使是相同大小的立体角，覆盖法线方向越多，$k_A$越大。

Landis 还给出了计算平均未遮蔽方向的方法，该方向也被称为 bent normal：

$\textbf{n}_{bent}=\frac{\int_{\textbf{l}\in\Omega}\textbf{l}v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}}{\|{\int_{\textbf{l}\in\Omega}\textbf{l}v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}}\|}$

该向量可以用在着色中替代几何法线，能够提供更精确的结果。

**可见性和遮挡法**

用于计算$k_A$的可见性函数$v(\textbf{l})$需要谨慎定义。对于一个物体，例如角色或者汽车，可以根据射线是否和模型的其他部分相交来定义$v(\textbf{l})$。但这并未考虑到周边物体带来的遮蔽。物体通常被假定放在了一个平面上，将平面纳入可见性计算可以获取到更多的真实遮蔽，也可以为地面提供接触阴影。

可见性函数无法用在闭合几何体中。比如一个封闭的房间中摆满了各式各样的物体，其中所有的物体表面$k_A$都为 0，因为表面发出的光线总会与某样物体相交。一些经验公式可以解决这类问题，比如 Miller 的可访问性着色（accessibility shading）。

Zhukov 等人提出了遮挡法，它将遮蔽计算中的可见性函数$v(\textbf{l})$替换为了距离映射函数$\rho(\textbf{l})$：

$k_A=\frac{1}{\pi}\int_{\textbf{l}\in\Omega}\rho(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

与$v(\textbf{l})$只有两个值（0 或 1）不同，$\rho(\textbf{l})$是一个基于光线前进距离的连续函数。$\rho(\textbf{l})$值为 0，意味着到交点的距离为 0；$\rho(\textbf{l})$值为 1，意味着到交点的距离大于设定的最大距离$d_{max}$或者根本没有交点。但遮挡法实际上并不物理正确，需要根据人的感受来调整$d_{max}$的大小。

**考虑相互反射**

虽然使用了环境光遮蔽后的结果看上去更加真实，但它们比全局光照的结果要暗很多，一个重要的原因是缺少了相互反射。该问题可以通过提升$k_A$解决，改用遮挡法也可以缓解这个问题。

精确跟踪相互反射是开销巨大的，因为这需要求解递归问题。计算$k_A$的值会高效很多。Stewart 和 Langer 提出了一种快速且准确的方法来近似相互反射。他们观察到，漫反射下的兰伯特场景中，同一点上可见的表面辐射度都很相似。假设被遮挡方向的辐射度$L_i$等同于当前着色点的出射辐射度$L_o$，就可以避免递归计算：

$E=\frac{\pi k_A}{1-\rho_{ss}(1-k_A)}L_i$

其中，$\rho_{ss}$是次表面反照率，或称为漫反射。该式等价于替换了$k_A$：

$k_A'=\frac{k_A}{1-\rho_{ss}(1-k_A)}$

该替换可以使结果更接近全局光照的结果，包括了相互反射。该效果高度依赖于$\rho_{ss}$。底层的近似假设了表面颜色与邻近着色点的颜色是相同的，产生了类似于颜色混合的效果。

Jimenez 等人提出了不同的方法，他们先通过离线方式计算包含了相互反射的路径追踪，根据这些结果，他们拟合了三次多项式来近似由$k_A,\rho_{ss}$映射到$k_A'$的函数。

**预计算的环境光遮蔽**

环境光遮蔽的计算可能非常耗时，所以经常采用离线预计算。包含环境光遮蔽的光照预计算通常被称为**烘焙**。

最常见的预计算环境光遮蔽的方法是使用蒙特卡洛方法。举例说明，我们均匀地采样了法线半球面上的$N$个随机方向$\textbf{l}$，然后基于相交结果得到了可见性函数$v$。那么环境光遮蔽就可以计算：

$k_A=\frac{1}{N}\overset{N}{\underset{i}{\sum}}v(\textbf{l}_i)(\textbf{n}\cdot\textbf{l}_i)^+$

当使用遮挡法时，光线距离可以限制在一个最大距离之内，$v$值表示交点距离。

环境光遮蔽的计算包括一个余弦加权因子，虽然可以直接纳入计算，但一个更高效的做法是通过重要性采样包括进去。不再是先均匀发射光线，再使用余弦加权结果，而是直接按照余弦加权光线分布。换句话说，光线就更容易生成在表面法线方向附近，这些方向得到的结果也更重要。该采样方法被称为*Malley's method*。

预计算环境光遮蔽可以在 CPU 或者 GPU 上执行。无论是哪种，都有相应的光线投射加速库。目前最流行的两个库是 CPU 端的 Embree 和 GPU 端的 OptiX。在过去，GPU 管线的一些结果，比如深度贴图或者遮蔽查询，也被用于计算环境光遮蔽；但随着 GPU 中光线投射的解决方案得到广泛支持，它们就用得越来越少了。大部分商用的建模和渲染软件会提供一个选项来预计算环境光遮蔽。

物体上每一点的遮蔽数据都是唯一的。它们通常存储在纹理、体积或者网格顶点上。

预计算的遮蔽数据也可以用于建模物体之间的遮蔽效果。Kontkanen 和 Laine 将物体的遮蔽信息存储在了它的周围（在立方体贴图中），被称为“环境光遮蔽场”。他们使用一个二次多项式的倒数来建模环境光遮蔽值随着与物体距离的增加而改变。它的系数存在立方体贴图中，用于模拟遮蔽的方向变化。运行时，可以根据遮蔽物体的距离和相对位置来获取合适的系数、重建遮蔽值。

Malmer 等人给出了一种改良的方案，他们将环境光遮蔽值以及可选的 bent normal 存储进一个三维网格，称为环境光遮蔽体。它的计算需求更低，因为环境光遮蔽值可以直接从纹理中读取，不需要计算。相比于 Kontkanen 和 Laine 的方法，它只需要存储更少的标量，而且两者所需的纹理分辨率都不大，所以总体所需的存储空间也差不多。Hill 和 Reed 讨论了如何在商用游戏引擎中实现 Malmer 等人的方案，他们讨论了该方法各个方面的实现以及优化方案。上述两种方案都是为刚体设计的，但是也可以扩展到小部分物体发生轻微移动的铰接体，铰接部分会被当作单独的物体处理。

无论我们选用何种环境光遮蔽的存储方案，我们都需要意识到我们是在处理连续信号。当我们从空间中一点发出射线，我们是在采样信号；当我们在着色前对采样结果进行插值，我们是在重建信号。所有来自于信号处理领域的技术都可用于提升采样-重建过程。Kavan 等人提出了一种称为“最小二乘烘焙”的方法，先在网格上均匀采样遮蔽信号，然后导出顶点的遮蔽值，这样就可以使采样值与插值之间的总体误差最小，该方法来自于最小二乘法。虽然他们是在顶点上讨论该方案，但也可以用在纹理存储或者体积存储上。

《命运》是一个用了预计算环境光遮蔽作为间接光照解决方案的游戏。游戏是在硬件代际更迭期发行的，所以需要平衡两代硬件的性能。游戏中设计了动态时间，所有预计算的方案都需要考虑该因素。由于不错的效果和较低的计算开销，开发者选择了环境光遮蔽技术。因为环境光遮蔽技术解耦了光照和可见性计算，所以能在动态时间内使用相同的预计算数据。

育碧的《刺客信条》系列和《孤岛惊魂》系列也使用了预计算环境光遮蔽来增强间接光照效果。他们从顶端向下渲染了深度图来计算大尺度的遮蔽，使用各种启发式方法来估算相邻分布的深度采样值。通过将世界坐标投影到纹理空间，最终的 AO 贴图应用在了全部的物体上。他们称该技术为”世界 AO“。

**动态计算的环境光遮蔽**

对于静态场景，环境光遮蔽和 bent normal 都可以预计算。但是，对于物体发生移动或者变形的场景，更好的解决方案是动态地计算环境光遮蔽。该类方案可以分为两种，一种是在物体空间计算，一种是在屏幕空间计算。

离线方法通常投射大量的射线，从每个表面点投射数十上百根射线寻找交点。该操作非常耗时，所以实时方法只能通过近似或者不使用该方法。

Bunnell 在网格顶点上用一些圆盘形元素来建模表面，通过这些圆盘来计算环境光遮蔽和 bent normal。由于圆盘之间的遮蔽可以解析地计算，就避免了射线投射。直接求和来自于其他圆盘的遮蔽会使结果过暗，因为当多个圆盘都遮挡时会重复计算，其实只有靠近的那个圆盘产生实际的遮挡。Bunnell 使用两个 pass 来避免该问题，在第二个 pass 中减去第一个 pass 的遮蔽来解决重复遮挡。虽然该方法只是一种近似方法，但效果很好。

计算成对圆盘之间的遮挡会带来$O(n^2)$的计算复杂度，除非是简单场景，否则该计算开销过于庞大。通过简化远距离平面的表示，可以降低计算开销。Bunnell 构造了分层树，每个节点表示节点下方子树的聚合。当计算圆盘间遮挡时，高层的节点存储远距离的表面。这样就将计算开销降低至$O(n\log n)$。Bunnell 的方法非常高效地产生高质量的结果，曾被用于电影《加勒比海盗》。

Hoberock 提出了对 Bunnell 算法的一些改进，在提高质量的同时也提高了一些计算开销。他也使用了一种距离衰减因子，类似于 Zhukov 等人提出的遮挡法因子。

Evans 提出了一种基于有向距离场（signed distance fields, SDF）的动态环境光遮蔽近似方法。该方法中，物体被包裹在一个三维网格中，网格中的每个位置都存储着到周边最近物体表面的距离。当网格位置处于物体内部时，该距离为负值；当网格位置处于物体外部时，该距离为正值。Evans 使用体积纹理存储场景的 SDF。为了评估物体上某一位置的遮蔽情况，他使用一种启发式方法，即沿着法线方向步进采样，将采样值结合起来。该方法也可以用在解析法表示的 SDF 中。虽然该方法不是物理正确的，但效果很不错。

使用有向距离场计算环境光遮蔽由 Wright 进一步发展。相比于启发式方法，Wright 提出了锥形追踪。锥形追踪沿着轴线方向步进来检查 SDF 和球的相交。如果 SDF 值小于球的半径，则那部分的圆锥就被遮挡了。只追踪一个圆锥并不精确，也无法合并余弦项，所以 Wright 追踪了一组圆锥，覆盖了整个半球面，来估算环境光遮蔽。为了提高视觉保真度，他的方案不仅使用了全局 SDF，还使用了一些局部 SDFs 描述单独的物体或者逻辑相关的一些物体。

Crassin 等人提出了体素场景下的相似方法。他们使用一个稀疏体素八叉树来存储体素化的场景。他们计算环境光遮蔽的算法实际上是渲染全局光照效果的一个特例。

Ren 等人将遮挡几何体近似为一些球体处理。被球体遮挡的表面某点的可见性函数使用球谐函数表示。被一组球体遮挡的可见性函数的聚合便是每个球体可见性函数的乘积。不幸的是，计算球谐函数的乘积是开销很大的操作。他们的核心思路是将各球谐函数累加后指数化，这可以得到和乘积相同的结果且开销大大减少。

该方法不仅计算了环境光遮蔽，还使用球谐函数表示了完整的球面可见性函数。第 0 阶的球谐系数可用作环境光遮蔽值$k_A$，第 1 阶的三个系数可用于计算 bent normal $\textbf{n}_{bent}$，更高阶的系数可以用作阴影环境贴图或环绕光源。由于几何体用包围球近似，所以褶皱等细节的遮蔽并未被建模。

Sloan 等人提出了 Ren 的可见性函数的屏幕累积方法。对于每个遮挡物，他们考虑了在距离其中心一定世界距离内的像素。这类操作可通过渲染一个球然后使用距离测试或者模板测试实现。对于所有受影响的屏幕区域，一个合适的球谐函数值会被添加进屏后缓冲中。当累积了所有遮挡物的可见性后，缓冲中的值被指数化作为最终每个屏幕像素的可见性函数值。Hill 使用了相同的方法，但是将球谐函数限制在了二阶的范围内。基于该假设，球谐函数的乘积就只是一些标量的乘法，甚至可以用 GPU 的固定编程渲染管线计算。

**屏幕空间的环境光遮蔽**

物体空间的方法，其计算开销与场景复杂度成正比。但是，一些有关遮蔽的信息可以从屏幕空间的数据中导出，比如深度和法线。这类方法有着固定的开销，与场景的复杂度无关，只与渲染的分辨率有关。

Crytek 开发了动态屏幕空间环境光遮蔽（SSAO）算法，用在了《孤岛危机》中。他们在全屏的 pass 中计算环境光遮蔽，只使用了 z-buffer 作为输入。各像素的环境光遮蔽值$k_A$是通过测试像素周围球形范围内的点来估算的。环境光遮蔽值$k_A$是 z-buffer 中相应值前面的样本数量的函数值。样本的权重随着离像素的距离增加而减小，类似于遮挡法。由于样本并未使用$(\textbf{n}\cdot\textbf{l})^+$加权，所以环境光遮蔽的结果是不正确的。相比于只考虑表面半球面的采样，该方法使用了整个球面。这种简化意味着表面之下的采样点也被计算了进去，这会引起平面变暗。但无论如何，该方法的结果仍然很棒。

一个相似的方法同时由 Shanmugam 和 Arikan 提出。他们在论文中描述了两种方法。一种适合生成小型细节带来的环境光遮蔽。另一种适合生成大型物体带来的粗糙的环境光遮蔽。两种方法结合在一起，可以得到最终的环境光遮蔽值。他们细粒度的环境光遮蔽方法使用一趟全屏 pass 获取 z-buffer 和包含表面法线信息的缓冲。对于每个着色像素，附近的像素从 z-buffer 中采样得到。采样的像素用球面表示，然后可以计算出着色像素的遮蔽项，因此结果会有些偏暗。他们粗粒度的环境光遮蔽方法与 Ren 等人的物体空间的方法相似，将遮挡几何体近似为一些球体，当然，他们在屏幕空间累积遮蔽，使用屏幕对齐的广告牌来覆盖每个遮挡球的影响区域，且并没有处理多次阴影覆盖的问题。

以上两种极为简洁的方法迅速引起了工业界和学术界的关注。大量诸如 scalable ambient obscurance 的专用启发式遮蔽算法被提出，这类方法有着很好的效果和适合调节的参数接口。另一些方法则注重合乎原理的计算方法。

Loos 和 Sloan 注意到 Crytek 的方法可以用蒙特卡洛积分解释，他们称这种结果为遮挡体积（_volumetric obscurance_），并给出了定义式：

$v_A=\int_{\textbf{x}\in X}\rho(d(\textbf{x}))o(\textbf{x})\mathrm{d}\textbf{x}$

其中，$X$是点周围的三维球面邻域，$\rho$是距离映射函数，$d$是距离函数，$o(\textbf{x})$是占用函数（如果$\textbf{x}$已经被占用，则值为 1，否则值为 0）。他们注意到$\rho(d)$函数对最终视觉效果的影响很小，可以使用常数函数。基于该假设，遮挡体积就是一个占用函数在邻域球面内的积分。Crytek 的方法在三维邻域内随机采样来计算积分。Loos 和 Sloan 用数值方法在 xy-维度积分，该方法是在某个像素的屏幕空间邻域内随机采样。z-维的积分则是通过解析方法。如果点的球面邻域内没有任何几何体，则积分等于射线和球面交点的长度；如果存在几何体，就使用深度缓冲作为占用函数的近似值，积分则在每个线段上未被占用的部分上进行。该方法得到的结果和 Crytek 的方法相近，但少用了一些采样，因为其中一个维度的积分被提了出来。如果表面法线可获取，该方法也可以扩展考虑进法线，则线积分被钳制在正面进行。

Szirmay-Kalos 等人提出了另一种使用法线信息的屏幕空间方法，称为环境光遮蔽体积（_volumetric ambient occlusion_）。他们认为法向半球面上的积分可以通过移除余弦项改用钳制余弦分布来近似。这使得半球面的积分变为了球面积分，只有原先一半半径的球面沿着法线方向移动至被半球面完全包裹。未被占用体积的计算方式与 Loos 和 Sloan 的方法相同，随机采样像素的邻域并解析地积分 z-维的占用函数。

Bavoil 等人提出了一种估算局部可见性的不同方法。他们的灵感来自于 Max 的视界映射技术。他们的方法被称为视界环境光遮蔽（HBAO），假定了 z-buffer 中的数据是表示连续的高度场。某一点的可见性可以通过视界角（_horizon angles_）估算，视界角是切平面上被邻域遮蔽的最大角。也就是，给出一个特定的方向，我们记录下最高可见物体的角度。如果忽略余弦项，环境光遮蔽值可以被当作视界角上未遮蔽部分的积分，或者用 1 减去视界角下遮蔽部分的积分：

$k_A=1-\frac{1}{2\pi}\int_{\phi=-\pi}^{\pi}\int_{\alpha=t(\phi)}^{h(\phi)}W(\omega)cos(\theta)d\theta d\phi$

其中，$h(\phi)$是切平面上的视界角，$t(\phi)$是切平面和视线方向之间的正切角，$W(\omega)$是衰减函数。$\frac{1}{2\pi}$项是积分的归一化系数，可以使结果落在 0~1 之间。

通过对到点的距离使用线性衰减，可以确定给定$\phi$的视界角，所以积分可以解析地计算：

$k_A=1-\frac{1}{2\pi}\int_{\phi=-\pi}^{\pi}(sin(h(\phi))-sin(t(\phi)))W(\phi)d\phi$

剩下的积分可以用数值方法计算，通过采样一些方向找到视界角。

Jimenez 等人也使用了基于视界的方法，他们称该方法为*ground-truth ambient occlusion*（GTAO）。他们的目标是获取正确的、可以和光线追踪相匹配的结果，但是在只能获取 z-buffer 中高度场信息的情况下。基于视界的环境光遮蔽并不包含余弦项，还增加了专门的衰减项，尽管它的结果很接近光线追踪的结果，但并不一样。GTAO 引入了丢失的余弦因子，移除了衰减函数，准确地给出了视线方向的遮蔽积分，遮蔽因子的定义为：

$k_A=\frac{1}{\pi}\int_0^\pi\int_{h_1(\phi)}^{h_2(\phi)}cos(\theta-\gamma)^+|{sin(\theta)}|d\theta d\phi$

其中，$h_1(\phi)$和$h_2(\phi)$是给定$\phi$的左视界角和右视界角，$\gamma$是法线和视线之间的夹角。归一化项$\frac{1}{\pi}$和 HBAO 不同，这是由于本式中包含了余弦项。其中的内积分可以解析地求解，只有外积分需要数值求解，使用和 HBAO 相同的方法，即采样像素周围的方向。

基于视界的方法中开销最大的部分是沿着屏幕空间的直线采样深度缓冲来找到视界角，Timonen 提出了一种专门提升该步骤效率的方法。他指出，用于估算视界角的样本可以在沿直线分布的像素间重用。他将遮蔽计算分为两步。第一步，他在整个 z-buffer 中做直线追踪，追踪的每一步中都更新视界角，直到最大距离，并将信息写入缓冲中。视界映射中使用的每一个屏幕空间方向都会生成一个这样的缓冲。缓冲不需要和原始的深度缓冲一样大，它们的大小取决于直线间的空间大小以及每次步进的距离，或者选用其他参数，不同的设置会影响最终的质量。第二步是基于缓冲中的视界信息计算遮蔽因子。Timonen 使用了 HBAO 的遮蔽因子定义，但其他的遮蔽计算方式（如 GTAO）也可以使用。

深度缓冲并不是场景的最佳表示，因为只有最近的物体会被记录进深度缓冲中，所以我们并不能知道被最近物体遮挡的信息。有很多的方法使用了各种各样的启发式技术试图推断出可见物体的厚度，这些近似方法可以满足一些场景的需要，也能得到不错的效果。也有一些方法使用多层深度来解决该问题，但并未广泛流行，因为这类方法的积分复杂、计算开销很大。

屏幕空间的方法依赖于对 z-buffer 重复采样来获得某个点附近的简化几何模型。实验表明，要想获得高质量的视觉效果，就需要数百个样本。但是，为了在交互渲染中使用，就只能限定在 10 到 20 个样本。Jimenez 等人提出，如果想在 60 FPS 的游戏中使用该类技术，就只能使用每像素一个采样点。为了弥补理论和实践中的巨大鸿沟，屏幕空间算法通常会使用一些空间抖动。最常见的形式中，每个屏幕像素都会有轻微的变化，使用沿径向随机旋转或移动的样本集。在 AO 计算之后，会过一个全屏的滤波 pass。使用联合双边滤波可以避免对表面不连续性的滤波，保留边缘。该滤波方法使用了深度和法线信息来限制滤波范围在同一平面中的样本之间。

环境光遮蔽的计算也经常会随着时间的推移出现过度采样。该情况经常出现在每帧使用不同采样图案，且对遮蔽因子采用指数平均的方案中。来自上一帧的数据被重新投影到当前视野中，使用的是上一帧的 z-buffer、相机位置和物体移动信息，然后被混合进当前画面。基于深度、法线或速度的启发式方法经常被用于判断上一帧的数据是否应当被丢弃。

**环境光遮蔽的着色**

虽然我们推导了持续性、远距离光照下的环境光遮蔽值，我们也可以将它用在更复杂的光照环境中。如果我们处理一个漫反射的表面，我们可以用兰伯特 BRDF 替换$f(\textbf{l},\textbf{v})$项，这等同于使用此表面反照率$\rho_{ss}$除以$\pi$：

$L_o=\int_{\textbf{l}\in\Omega}\frac{\rho_{ss}}{\pi}L_i(\textbf{l})v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}=\frac{\rho_{ss}}{\pi}\int_{\textbf{l}\in\Omega}L_i(\textbf{l})v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

重新整理该式可以得到：

$L_o=\frac{\rho_{ss}}{\pi}\int_{\textbf{l}\in\Omega}L_i(\textbf{l})\frac{v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+}{\int_{\textbf{l}\in\Omega}v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}}d\textbf{l}\int_{\textbf{l}\in\Omega}v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

结合环境光遮蔽的式子，可以得到：

$L_o=k_A \rho_{ss}\int_{\textbf{l}\in\Omega}L_i(\textbf{l})K(\textbf{n},\textbf{l})d\textbf{l}$

其中，$K(\textbf{n},\textbf{l})=\frac{v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+}{\int_{\textbf{l}\in\Omega}v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}}$

上式给了我们一种新的理解，积分可以被认为是在入射辐射度$L_i$上使用了一个方向性的滤波核$K$。$K$随空间和方向变化，但它有两个重要的属性。第一，它覆盖了几乎整个$\textbf{p}$点的法向半球面；第二，它在半球面上的积分值为 1。

为了着色，我们需要计算入射辐射度函数$L_i$和滤波核函数$K$乘积的积分。在某些情况下，这种计算可以很快，比如$L_i,K$都使用球谐函数表示。其他情况就需要使用近似的滤波核来计算，用得最多的便是滤波核$H$：

$H(\textbf{n},\textbf{l})=\frac{(\textbf{n}\cdot\textbf{l})^+}{\int_{\textbf{l}\in\Omega}(\textbf{n}\cdot\textbf{l})^+d\textbf{l}}$

当没有东西遮挡入射光时，该近似是精确的。它也覆盖了与原始滤波核相同的角度范围。它完全地忽略了可见性，但完整的式子中仍然包含环境光遮蔽项，所以会产生与可见性有关的变暗。采用该近似滤波核之后，出射辐射度的式子变为：

$L_o=k_A\rho_{ss}\int_{\textbf{l}\in\Omega}L_i(\textbf{\textbf{l}})\frac{(\textbf{n}\cdot\textbf{l})^+}{\int_{\textbf{l}\in\Omega}(\textbf{n}\cdot\textbf{l})^+d\textbf{l}}d\textbf{l}=\frac{k_A}{\pi}\rho_{ss}E$

这意味着，在最简单的形式中，带环境光遮蔽的着色就可以通过计算辐照度和环境光遮蔽值的乘积得到。辐照度可能来自任何光源，比如环境贴图。上式的精确性仅取决于近似滤波核的精确程度。对于变化平滑的光照，该近似是合适的。如果入射辐射度$L_i$是在各个方向相同的（比如场景是由纯白环境贴图照亮的），那么该式也是足够准确的。

上式也告诉我们，为何环境光遮蔽不适合近似点光源或小面积光源的可见性。它们只在表面上形成一个很小的立体角，对于点光源来说就是无限小的立体角，而可见性函数对于光照积分会产生很大影响。环境光遮蔽不适合用于建模这类光源的可见性，其他方法比如阴影贴图是一个更好的选择。值得注意的是，有时候，微小的局部光源会被用于建模间接光照，这种情况下用环境光遮蔽值来调节它们的贡献度是合理的。

目前为止我们都假设是在着色兰伯特表面，当处理更复杂的、非定值 BRDF 的表面时，BRDF 不能从积分中提出来。对于镜面反射材质，$K$不仅依赖于可见性和法线，也依赖于视线方向。一个典型的微平面 BRDF lobe 会在积分域上大幅度地变化，用一个特定的形状来近似就过于简单粗暴，这也是为何环境光遮蔽对漫反射 BRDF 的效果是最好的。

使用 bent normal 可以更精确地近似滤波核$K$。虽然可见性项并没有出现在滤波核中，但它的最大值和平均未遮蔽方向是吻合的，这使得它有着更好的近似。

对于环境贴图的着色，Pharr 提出了一个可选的方法，使用 GPU 的纹理滤波硬件来进行动态滤波。滤波核$K$的形状在运行时确定，它的中心方向是 bent normal，大小取决于$k_A$。这种方法可以得到更精确的滤波核。

#### 10.4 方向遮挡（Directional Occlusion）

虽然只使用环境光遮蔽已经可以极大地提升图像的质量，但它仍然只是个简化过的模型。即使是大面积光源，它也很难近似可见性，更不用说点光源。它也不能正确地处理光泽 BRDF 或者复杂的光照设置。

我们专注于编码整个球面或半球面上可见性的方法，即可以描述哪些方向的入射辐射度被遮挡的方法。本节讨论的方法侧重于解决大面积光源或环境光照的遮蔽，它们由近似可见性所引起的瑕疵并不明显。另外，该类方法也可用于为阴影技术提供遮蔽信息，比如凹凸贴图的自阴影细节，或是特大场景的阴影（阴影贴图分辨率不够）。

**预计算的方向遮挡**

Max 给出了一种叫做”视界映射“的概念，用以描述高度场表面的自遮蔽。在视界映射中，视界的高度角由一组方位方向决定，例如”东、南、西、北、东南、东北、西南、西北“。未遮蔽的方向可以整体被建模成一个椭圆形或者圆形的孔洞，该技术被称为环境光孔洞光照，存储需求小于视界映射，但如果未被遮蔽的方向整体不像椭圆形或者圆形，则可能会产生不正确的阴影。

遮蔽技术有很多的变体。Wang 等人使用球面有向距离场（SSDF）来表示可见性。他在球面上编码到遮蔽区域边界的有向距离。与环境光遮蔽相同，方向可见性信息可以被存进纹理中、网格顶点中，或是体积中。

**动态计算的方向遮挡**

大多数用于生成环境光遮蔽的方法都可以用于生成方向可见性信息。Ren 等人的球谐指数方法以及 Sloan 等人修改的屏幕空间变体，都可以生成用球谐向量描述的可见性。如果使用了超过一个球谐频带，这类方法就会天然地带有方向信息。使用更多地频带可以编码出更精确的可见性。

锥形追踪方法可以在每次追踪中都产生一个遮蔽值。出于质量考虑，即使是环境光遮蔽也需要使用多次追踪，所以获得的信息都已经是方向性的。如果只需要特定方向的可见性，我们可以追踪更少的锥形。

Iwanicki 也使用了锥形追踪，但他限制在了一个方向上。追踪的结果是用于生成（用一组球近似的动态角色）投射到静态几何体上的软阴影。在这种方案中，静态物体的光照使用 AHD（ambient/highlight/direction）编码存储。

许多屏幕空间的方法都可以扩展出方向性的遮蔽信息。Klehm 等人使用 z-buffer 数据计算屏幕空间的 bent 锥形，实际上是一个圆形孔洞，非常像离线预计算的结果。当采样某像素的相邻区域，他们将未遮蔽的方向加起来，结果向量的长度可用于估算可见性锥形的顶角，结果向量的方向可用于描述锥形的轴。Jimenez 等人则基于视界角估算锥形的轴向，并从环境光遮蔽因子导出了角度。

**方向遮挡的着色**

我们无法给如此之多不同的方向遮挡使用统一的着色方法，每种着色都依赖于我们想达到的效果。

最简单的处理就是用可见性值的符号来描述点光源阴影。由于该方法简化了绝大多数的可见性编码，所以效果很差，但这可以作为分析的依据，也可以用于因分辨率不足而使传统阴影方法失效的情况，比如超大地形，或是使用凹凸贴图表示的表面细节。

当处理点光源时，方程可写为：$L_o(\textbf{v})=\pi f(\textbf{l}_c,\textbf{v})\textbf{c}_{light}v(\textbf{l}_c)(\textbf{n}\cdot\textbf{l}_c)^+$

其中，$\textbf{c}_{light}$是从白色兰伯特表面反射的辐射度，$\textbf{l}_c$是指向光源的方向。我们可以将上式理解为未受遮蔽的光源在材质上的效果和可见性函数值的乘积。当光源方向落在视界外（使用视界映射时），或是在可见锥形外（使用环境光孔洞光照时），或是在 SSDF 的负值区域时，可见性函数值为零，因此光源不应该有任何光照贡献。值得注意的是，虽然可见性函数是二值函数，许多表示中仍然会返回一个范围值，而不是 0 或 1，这些范围值表示部分遮挡。球谐函数或$H$基底甚至会由于振铃现象重建出负值。虽然这些现象都是我们不想要的，但确实都是编码中潜在的特性。

我们可以对面光源使用类似的处理。这种情况下，$L_i$只有在光源照射的立体角内才不为零，等于光源发出的辐射度。我们使用$L_l$来表示，并假设它在光源的所有立体角上都是相同的值。然后，我们就可以用光源立体角范围取代整个球面：

$L_o(\textbf{v})=L_l\int_{\textbf{l}\in\Omega_l}v(\textbf{l})f(\textbf{l},\textbf{v})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

如果我们进一步假设 BRDF 也是常值，也就是当作兰伯特表面处理，那么也可以从积分中提出来：

$L_o(\textbf{v})=\frac{\rho_{ss}}{\pi}L_l\int_{\textbf{l}\in\Omega_l}v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

为了确定被遮挡的光照，我们需要计算在光照立体角内可见性函数乘上余弦项的积分。有这么几种情况下可以解析地计算积分。Lambert 推导了球面多边形上的余弦积分，如果面光源是多边形，并且能根据可见性裁剪出来，我们就只需要 Lambert 方程即可计算出精确的结果。当我们使用视界角作为可见性表示时，这是有可能的情况。但是，如果我们使用其他的编码方式，比如 bent cones，那么裁剪会产生圆形片段，这种情况下就不能再使用 Lambert 方程。同样的，当我们使用非多边形的面光源时，也不能使用 Lambert 方程。

另一种可以解析地计算积分的情况是，假设余弦项在整个积分域上都是固定的，我们就可以使用面光源中心方向上已经计算好的余弦值，这样就不再需要计算光源立体角内可见性项的积分。接下来的处理则取决于我们选用的可见性表示方法，如果使用球面光源和 bent cones 表示的可见性，那么积分就是对可见性锥形和光源锥形相交部分立体角的积分；如果可见性使用球谐函数编码，则积分也同样可以解析地计算。

对于环境光照，我们无法限制积分范围，因为光照来自于四面八方。我们需要寻找一种计算全域积分的方法，先考虑兰伯特 BRDF：

$L_o(\textbf{v})=\frac{\rho_{ss}}{\pi}\int_{\textbf{l}\in\Omega}L_i(\textbf{l})v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

上式的积分类型被称为三乘积积分。如果每个独立部分都以确定的形式，比如球谐或者小波，那么可以解析地计算。但不幸的是，这对于实时应用来说开销太大了，尽管可以在简单情形下按交互帧率运行。

我们的特例会略微简单一些：

$L_o(\textbf{v})=\frac{\rho_{ss}}{\pi}\int_{\textbf{l}\in\Omega}\overline{L_i}(\textbf{l})v(\textbf{l})d\textbf{l}$

或者：

$L_o(\textbf{v})=\frac{\rho_{ss}}{\pi}\int_{\textbf{l}\in\Omega}L_i(\textbf{l})\overline{v}(\textbf{l})d\textbf{l}$

其中：

$\overline{L_i}(\textbf{l})=L_i(\textbf{l})(\textbf{n}\cdot\textbf{l})^+,\\\overline{v}(\textbf{l})=v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+,$

$\overline{L_i}(\textbf{l})$和$\overline{v}(\textbf{l})$都是球面函数。不计算三乘积的积分，我们先用余弦乘以$L_i$或者$v_i$，这样就只剩下两项乘积的积分。当各因子是用正交基底表示的时，两项乘积的积分也可以按平凡方法计算，即系数向量的点乘。但我们仍需要计算$\overline{L_i}(\textbf{l}),\overline{v}(\textbf{l})$，但由于含有余弦，这比一般情况更简单。如果我们用球谐函数表示，那么余弦投影为 zonal harmonics(ZH)，这是球谐函数的一个子集，每个频带只有一个非零系数。SH 和 ZH 的乘积比 SH 和另一个 SH 的乘积要快很多。

如果我们先用$v$乘以余弦，则我们可以提前离线运算好，这是一种预计算辐射度传输的形式，由 Sloan 等人提出。该形式中，我们无法对法线做小尺度的调整，因为由法线控制的余弦项已经和可见性融合。如果我们还想建模小尺度法线细节，我们可以先将余弦和$L_i$相乘。由于我们并不能预先知道法线的方向，所以我们可以根据不同的法线做预计算，或是在运行时计算。离线预计算$L_i$和余弦也意味着对光照的限制，允许光照在空间中变化会占用大量的内存；另一方面，运行时计算则会开销巨大。Iwanicki 和 Sloan 给出了减小开销的方法，乘积可以较低粒度计算——在顶点上。将结果和余弦项卷积，接着投影到一种简化表示上（AHD），然后逐像素法线插值和重建。该方法可以使算法在需要 60FPS 的游戏中使用。

Klehm 等人提出一种解决使用环境贴图表示光照、使用锥形编码可见性时的方案。他们采用滤波表示可见性与光照乘积的积分，对于不同的锥形开口使用不同大小的卷积核滤波环境贴图。他们将结果按锥形顶角增大的顺序存入不同 mip 层级的纹理中。这是可以做到的，因为锥形顶角很大时的预滤波结果在球面上平滑变化，并不需要存进高分辨率中。预滤波中，他们假定了可见性锥形的方向是和法线对齐的，这是一个合理的近似，实践中的效果也很好。

但如果我们是对光泽 BRDFs 和环境光照做处理，就会比较复杂。我们不能再从积分中提出 BRDF，因为它不能当作常数处理。为了解决该问题，Green 等人建议使用球面高斯来近似 BRDF，这是一类径向对称的函数，可以使用三个参数压缩表示，即方向$\textbf{d}$，标准差$\mu$，振幅$\omega$。BRDF 可以用球面高斯的求和近似：

$f(\textbf{l},\textbf{v})\approx\underset{k}{\sum}\omega_k(\textbf{v})G(\textbf{d}_k(\textbf{v}),\mu_k(\textbf{v}),\textbf{l})$

其中，$G(\textbf{d},\mu,\textbf{l})$是球面高斯的 lobe，朝向$\textbf{d}$，锋利度为$\mu$，第$k$个 lobe 的振幅是$\omega_k$。对于各向同性的 BRDF，lobe 的形状只依赖于法线和视线的夹角。该近似可以存储在一维查找表中插值。使用该近似，原式可以写为：

$L_o(\textbf{v})\approx\int_{\textbf{l}\in\Omega}\underset{k}{\sum}\omega_k(\textbf{\textbf{v}})G(\textbf{d}_k(\textbf{v}),\mu_k(\textbf{v}),\textbf{l})L_i(\textbf{l})v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}\\=\underset{k}{\sum}\omega_k(\textbf{v})\int_{\textbf{l}\in\Omega}G(\textbf{d}_k(\textbf{v}),\mu_k(\textbf{v}),\textbf{l})L_i(\textbf{l})v(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

Green 等人也假定了可见性函数在球面高斯上是常值，这允许他们将可见性从积分中提出来。他们计算了 lobe 中心方向的可见性函数：

$L_o(\textbf{v})\approx\underset{k}{\sum}\omega_k(\textbf{v})v_k(\textbf{d}_k(\textbf{v}))\int_{\textbf{l}\in\Omega}G(\textbf{d}_k(\textbf{v}),\mu_k(\textbf{v}),\textbf{l})L_i(\textbf{l})(\textbf{n}\cdot\textbf{l})^+d\textbf{l}$

剩下部分的积分表示入射光照与球面高斯的卷积。这类卷积的结果可以预计算存进环境贴图中，较大方差$\mu$的卷积存在较低的 mip 层级中。可见性使用低阶的球谐函数编码，但也可以使用其他形式的表示方法。Wang 等人使用相似的方法近似 BRDF，但对可见性函数使用了更精确的处理方式。

对于很多应用来说，该类方法都开销很大。它需要从预滤波的环境贴图中多次采样，但纹理采样也常常是渲染性能的瓶颈。Jimenez 等人和 El Garawany 提出了简化的近似方法。他们使用一个锥形来表示 BRDF lobe，忽略它对视角的依赖，且只考虑特定的参数，比如材质粗糙度。他们将可见性近似为锥形，并计算可见性和 BRDF 锥形相交部分的立体角。最终的标量结果用于光照衰减。虽然这是很极端的简化，但效果挺好。

#### 10.5 漫反射全局光照

接下来的章节将讨论完整光线弹射的实时计算。我们可以大致分为两种，经漫反射表面进入人眼、经镜面反射表面进入人眼。

**预光照表面**

辐射度和路径追踪算法都是离线渲染使用的。但人们仍在努力推进将它们应用到实时领域，虽然还远未达到成熟可用。当前最常见的做法是使用离线算法预计算光照相关的信息。先提前运行开销巨大的离线算法，将结果存储起来用于实时渲染。

虽然可以将漫反射和辐照度乘积得到的出射度存储在一张纹理里，但是考虑到漫反射贴图的重复使用，将两者分开存储通常是更好的选择。

预计算辐照度现在已经用得很少了，因为根据定义，辐照度计算的是给定法线方向的，那么我们就不能使用法线映射提供高频细节。

**预光照方向表面**

为了能够在法线映射的兰伯特表面使用预光照，我们需要找到一种可以表示随表面法线变化的辐照度方法。

最通用的方法是将整个球面辐照度信息存储起来，比如使用球谐函数。如果使用九个球谐系数（三阶球谐），效果很好，但存储开销很大；如果只使用四个球谐系数（二阶球谐），开销大幅减少，但效果也会差一些。Chen 在《光环 3》中使用了一种变体来达到三阶球谐的质量。他从球谐中提取出了主体光源，分开存储其光源颜色和方向，剩余部分再使用二阶球谐编码。

另一个可选的方案是$H$基底。由于它只编码了半球面的信号，所以只需要更少的系数即可达到与球谐函数相同的精度。

球谐基底和$H$基底的一个问题是，它们会表现出振铃现象。虽然预滤波可以缓和该现象，但它仍然会使光照变平滑。另外，即使是开销较低的变体形式，也也很高的计算和存储开销。

AHD 基底仍然很流行，从《半衰期 2》到《使命召唤：二战》和《最后生还者》都使用了该技术。《孤岛惊魂 1》中则使用了 AHD 的一种变体，Crytek 使用一个切线空间平均光照方向、一个平均光照颜色和一个方向标量因子来表示光照。最后的标量因子用于混合环境光和方向。使用该表示方式可以将系数降低至六个：三个值存储颜色，两个值存储方向，一个值存储方向因子。

但上述的表示方式都是非线性的，这意味着对它们使用线性插值的结果是不正确的，如果主光源的方向快速变化，那么阴影边界就很可能会出现瑕疵。

---

另一组方法则是未高质量视觉效果设计的。Neubelt 和 Pettineo 在游戏《教团：1886》中使用纹理贴图来存储球面高斯的系数。他们存储了入射辐射度，将其投影到一组正切框架下的高斯 lobe 上。根据场景的光照复杂度使用 5~9 个 lobe。为了得到漫反射，球面高斯需要和沿着面法线方向的余弦 lobe 做卷积。这种表示方式对于一些光泽度较低的镜面效果也足够精确。

如果我们需要来自任意方向的光照信息，不仅仅是上半球面（比如动态几何体的间接光照），那我们可以使用一些对整个球面编码的方法。球谐函数是很自然的选择。球面高斯也可以对整个球面编码，但由于 lobe 需要覆盖立体角，所以往往需要更多的 lobe。

如果想要解决振铃问题，但又不想使用太多的 lobe，可以使用环境光立方体。它由六个钳制的$cos^2$ lobes 组成，每个 lobe 沿着一条轴线。每个余弦 lobe 都覆盖一个半球面，因为它们由局部支撑，所以它们仅在它们的半球面域上的一个子集上有非零值。因此，只有其中三个 lobes 需要存储和用于重建。

环境光骰子（Ambient dice）可以达到比环境光立方体更高的质量。该方法使用 12 个 lobes，分别沿着 20 面体的每个顶点方向，每个 lobe 都是$cos^2$和$cos^4$lobe 的线性组合。12 个 lobes 中的 6 个会用于存储和重建。该方法的质量相当于三阶球谐函数。

**预计算传输**

虽然预计算光照的效果很好，但它本质仍然是静态的方法，对几何体或者光照的任何修改都会使方法失效。正如现实中一样，打开窗帘（局部的几何体变动）可以让整个房间充满光线（全局的光照变化）。

如果我们假定场景中的几何体不会变化，就只有光照会发生变化，我们就可以预计算光照和模型的交互。物体间效果，如相互反射、次表面散射，都可以预先分析好，并将结果存储起来。这种将入射光线转变为场景中辐射度分布的函数，被称为**传输函数**。预计算传输的方法被称为**预计算传输**或**预计算辐射度传输**（PRT）方法。

与完全地离线烘焙光照相反，这类方法都有着很明显的实时运算开销。当显示场景时，需要计算特定光照设置下的辐射度。为了实现辐射度的计算，实际的直接光照被“注入”进系统中，传输函数随后将它们传播至整个场景。一些方法假定了这些直接光照来自于环境贴图，而另一些方法则允许任意的光照设置。

预计算辐射度传输的概念由 Sloan 等人引入到图形学领域。他们使用了球谐函数中的术语，但该方法其实并未用到球谐函数。它的底层思路很简单，如果我们用一些基本光线来描述直接光照，我们就可以预计算出场景是如何被光线照亮的。想象一个房间中摆放着三台显示器，假设每台显示器都只显示单一的颜色，但强度可变。我们可以独立地预计算每台显示器对场景的影响。由于光线传输是线性的，所以场景中三台显示器的辐照度等同于它们三者叠加的结果，无论是直接光照还是间接光照。由于不同显示器之间发出的光线不会相互影响，所以将其中一台显示器的亮度调节为原来的一半，也只会改变它自身的光照贡献。

以上方法使得我们可以快速地计算整个房间中的光线弹射。我们预计算每个光源的辐射度传输，将它们的结果加到一起。我们还可以控制显示器的开关，或是调节它的亮度乃至颜色。我们可以将辐射度传输写成：

$L(\textbf{p})=\underset{i}{\sum}L_i(\textbf{p})\textbf{w}_i$

其中，$L(\textbf{p})$是点$\textbf{p}$上的最终辐射度，$L_i(\textbf{p})$是从光源$i$出发的预计算光照贡献，$\textbf{w}_i$是它的亮度。该式定义了一个数学上的向量空间，$L_i$是其中的向量基底，所有的光照都可以通过基底的线性组合得到。

Sloan 等人最初的 PRT 采用了相同的推导过程，但它们用的是通过球谐函数表示的无限远的光照环境。他们没有存储光源对场景的贡献，而是将光源对周围环境的影响用球谐函数存了起来。这样他们就可以渲染出使用任意环境光照照亮的场景。他们将光照投影到球谐函数上，将各结果的系数乘起来，就得到它们叠加在一起的效果。

注意到表示光线注入场景的基底，和表示最终光照的基底之间并无依赖性。比如，我们可以使用球谐函数表示场景的照明，但用另一套基底存储每一点上的辐射度。

Sloan 等人的 PRT 论文中分析了两种情况。第一种情况是，表面使用一个标量辐照度描述接收到的辐射度，这种情况下要求接收面是一个完全的漫反射表面，有着预定的法线（不能使用法线贴图），其传输函数是输入光照的球谐投影和预计算的传输向量的点乘。

如果我们需要渲染非兰伯特材质，允许使用法线贴图，我们就需要使用第二种方法。第二种情况下，周围光照的球谐投影被转换为某点入射辐射度的球谐投影，该操作可以为我们提供球面上完整的辐射度分布信息，我们就可以将其和 BRDF 做卷积。转换函数通过矩阵乘法的形式将一种球谐向量映射为另一种球谐向量，该乘法开销很大，如果使用三阶球谐，就需要对每个点存储一个$9\times 9$的矩阵，而这只是对单通道的转换。

Sloan 等人于一年后解决了该问题。不直接存储转换矩阵，他们采用了主成分分析（PCA）的技术。转换系数可以被当作是多维空间（比如 81 维）中的点，但它们的集合并不是均匀分布的，它们呈现出低维的聚簇。Sloan 等人使用该方法将转换矩阵从 625 维降低至 256 维。

这种降维方法会产生误差，在少数情况下可以产生一个完美的低维空间，但大多数情况下都只是近似。为了提升质量，Sloan 等人将转换矩阵划分为多个簇，并分别使用 PCA。该类技术还有一种允许物体有限变形的扩展方法，被称为*local deformable precomputed radiance transfer*(LDPRT)。

PRT 以不同的形式用在了很多的游戏中。它在游戏玩法侧重于时间流动和天气可变的游戏中特别流行。《孤岛惊魂 3》和《孤岛惊魂 4》中的 PRT 使用了二阶球谐基底和一种定制的四向基底。

SIGGRAPH 2005 course 中有关 PRT 的内容给了一个很全面的总结。

目前为止有关 PRT 的讨论都集中在对于某些要素的预计算传输。另一类流行的使用计算传输的方法是关于表面之间的。在该类系统中，实际的照明光源变得无关紧要，任何光源都可以使用，因为方法的输入是一些表面的出射辐射度。该类方法中最流行的系统是 Geomerics 公司的*Enlighten*方法。虽然算法的具体细节并未公开披露，但无数的讨论和演讲给出了该系统精确的阐述。

Enlighten 方法在计算光线传输时假定了场景是兰伯特的。用 Heckbert 标记法，光路可以写为$LD*(D|S)E$，只有最后进入人眼之前的表面可以是非漫反射的。该系统定义了一些“源”元素，和另一些“汇”元素。源元素从表面离开，并带有表面的一些属性，比如漫反射颜色和法线。预处理阶段计算源元素和汇元素之间的光线传输，该类信息提取出的形式取决于源元素是什么以及汇元素所使用的基底。最简单的形式中，源元素是点光源，我们关注汇点接收的辐照度。这种情况下，传输的系数只有源和汇之间的相互可见性。在运行中，所有源元素的出射辐射度都会提供给系统，这样就可以数值地计算出反射方程的积分（使用预计算的可见性和源汇的位置与朝向信息）。这样就完成了一次光线弹射。正如绝大多数的间接光照都来自于第一次弹射，完成一次弹射就足够提供真实的光照效果。但我们也可以再次进行光线传播来生成第二次光线弹射，这通常会分布在几帧的过程中完成，某一帧的输出可以用作下一帧的输入。

使用点作为源元素会导致大量的连接。为了提升性能，将一簇表示相似法线和颜色的点集作为源，这样传输的系数就和辐射度算法中是一样的了。但要注意到，即使它们很相似，但算法仍然与经典的辐射度算法不同，它每次只需要计算一次光线弹射，且不需要求解线性方程系统。这带来了一种叫做“渐进辐射度”（_progressive radiosity_）的思路。在该思路中，每个表面小块在迭代中确定了它从其他小块接收了多少能量。将辐射度传递到汇点的过程被称为“聚集”（_gathering_）。

汇元素的辐射度可以不同形式聚集，传输到汇元素可以使用各种方向基底。这种情况下，单一的系数变成了向量值，其维数等同于汇元素的基函数数量。当使用方向性基底表示聚集，那么结果和离线方法中的一样，因此可以使用法线贴图或是低光泽度的镜面反射。

相同的思想用在了不同的变体中。为了节省内存，Sugden 和 Iwanicki 使用球谐传输系数，将其量化后间接地存储为调色板的词条索引。Jendersie 等人则构建了一个分层的源块集，当子节点对应的立体角很小时，将层级调高。Stefanov 提出了一种中间步骤，将表面元素的辐射度先传播到体素化的表示中，再作为源元素传播。

对源的理想表面分割取决于汇点的位置。对于距离远的元素，将它们认为是单独的实体将产生不必要的存储开销，但当近距离观察时，则需要视作不同的实体。对源块的分级可以缓解该问题，但还不能彻底解决。对于特定汇点来说，某些本可以合并的源块可能分开较远而无法合并。针对该问题的一种新方法由 Silvennoinen 和 Lehtinen 提出。他们的方法不显式创建源块，而是为每个汇点创建不同的源集。物体被渲染进一些环境贴图的稀疏集合中，每一张贴图都被投影到球谐函数中，且这个低频的版本又“虚拟”地投影回了环境中。汇点记录了有多少投影可以被看见，该过程在每个源的球谐函数上都会进行。这样做可以根据环境探针和汇点的可见性为每个汇点生成不同的源元素集。

**存储方法**

无论我们是使用完全预计算的光照，还是预计算传输信息以供光照调节，其结果数据都需要存储起来。GPU 友好型的存储格式是必须的。

光照贴图是一种最常用的存储预计算光照的方法。它们是一些存有预计算信息的纹理。在运行时会使用 GPU 内建的纹理机制，纹理通常会被双线性插值，这对于某些表示方式来说会引起错误，比如使用 AHD 表示法，那么 D（方向）在插值后就不再是单位向量，需要重新归一化。插值也意味着不精确，但效果通常是可接受的。

大部分情况下，光照贴图并不使用多级纹理，因为光照贴图的分辨率比反照率贴图和法线贴图小很多。即使是高质量应用，单个光照贴图的纹素也能覆盖至少$20\times 20$厘米的区域，甚至更大。这种尺度下，额外的多级纹理几乎没有必要。

为了在纹理中存储光照，物体需要被唯一参数化。当我们将漫反射纹理映射到一个模型上时，网格的不同部分共用同一张纹理是很合适的，特别是当一个模型的纹理是平铺使用时。但复用光照贴图的效果并不好，网格上每一点的光照都是不同的，所以网格上的每个三角形都应该占据光照贴图中一块专属的区域。参数化方法是从将网格分割成一个个小块开始的，这既可以通过一些启发式方法自动分割，也可以手动分割，通常会直接使用其他纹理已有的分割；接着，每个小块都单独参数化，确保它的各部分不会在纹理空间中产生重叠，放在纹理空间中的元素就被称为“壳”；最后，所有的壳都被放进一张普通的纹理中。需要注意的是，必须保证壳之间不会相互重叠，且滤波也必须确保相互分离。所有壳覆盖（包括滤波后）的纹素都应当标记为“已使用”，这样才能避免其他壳的重叠。

优化纹理中壳的排列是一个 NP-完全问题，现阶段无法使用多项式时间求解出最佳结果。实时应用中可能需要将成百上千个壳放进一张纹理中，所有实际使用的方案都是使用微调的启发式方法和仔细优化过的代码来快速生成。

光照贴图的一个常见问题是接缝问题。因为网格被分成了不同的壳，且被单独参数化，所以无法保证沿着分割边缘两侧的光照都是相同的，最终体现为视觉上的不连续。手动分割网格可以一定程度上避免该问题，比如将接缝放在看不见的位置。但这样无疑是一种费力的方式，无法用于自动分割。Iwanicki 提出了一种光照贴图的后处理修复方法，沿着分割边缘调整纹素来减少两侧的插值差别。Liu 和 Ferguson 等人优化了沿边缘插值结果的匹配性，他们通过等式约束，并求解出平滑的纹素值。另一种方法是在参数化和排列时考虑该问题，Ray 等人提出使用“网格保持的参数化”（_grid-preserving parameterization_）来生成较少瑕疵的光照贴图。

预计算的光照也可以存储在网格的顶点中。但缺陷是光照质量就依赖于网格的细分程度了。一般很难保证网格有足够的顶点可以使其在不同光照环境下都具有理想的光照效果。另外，细分较高的网格会带来更大的开销，如果网格被细分过度，也可能会导致光照信号的过采样。如果在存储光照时使用了方向性的方法，那么就需要使用 GPU 进行顶点间的插值，并将插值结果传递到像素着色器阶段来执行光照计算。传递如此之多的数据会给 GPU 带来巨大的负担，性能损耗严重。因此，将预计算光照存储在网格顶点中的方法用得很少。

虽然入射辐射度信息是物体表面所使用的，我们仍然能以体积的方式预计算和存储，这样就可以在任意的空间位置查询光照信息，为那些未参与预计算的场景物体提供照明信息。但要注意的是，这些未参与预计算的物体也无法正确地反射和遮挡光照。

Greger 等人提出了辐照度体积（_irradiance volume_），它使用辐照度环境贴图的稀疏空间采样来表示五维（三维空间+二维方向）的辐照度函数。也就是，空间中有三维网格，每一个网格点都是一张辐照度环境贴图。动态物体从最近的贴图中插值出辐照度值。Greger 等人使用两级自适应网格来进行空间采样，但也可以使用其他的体积数据结构，比如八叉树。

在最初版的辐照度体积中，Greger 等人将每个采样点的辐照度存储在一张很小的纹理中，但这种表示方法无法在 GPU 中高效滤波。今天，大多数的体积光照数据都存储在三维纹理中，因此，采样体积也可以使用 GPU 加速滤波。采样点处辐照度函数最常见的表示方法包括：

- 二阶或三阶的球谐函数。
- 球面高斯
- 环境光立方体或环境光骰子

AHD 编码方法虽然很适合表示球面辐照度，但会产生瑕疵。如果使用了球谐函数，球谐梯度可以进一步提高质量。上面列举的几种表示方法都在游戏中成功应用。

Evans 在《小小大星球》中使用了一种辐照度体积的 trick。他没有表示完整的辐照度贴图，而是在每个点存储了平均辐照度。从辐照度场的梯度计算得到一个近似的方向性因子，即辐照度场中变化最快的方向。

辐照度体积也可用于提供静态表面的光照。这样做就可以不用再为光照贴图做参数化，也不会产生接缝。体积表示法在延迟渲染中很方便，其中所有的光照都在一个 pass 中计算。最主要的缺陷是内存开销较大。

将表面光照存储在体积结构中是比较棘手的。有着不同光照特性的多层材质可能会占据同一个体素，从这样的体素中采样往往会得到不正确的结果。纠正的方法是使用足够小的体素尺寸，但这通常是不现实的，因为会增加很多的开销。最常用的方法是沿着法线方向移动采样位置，或是调整在三线性插值混合中使用的权重。但这种方法并不完美，需要调整几何体来掩盖问题。Hooker 为辐照度体积增加了额外的裁剪平面，这将它们的影响限制在凸多边形的内部。

存储光照的体积结构不一定要是规则的。一种很流行的选择是将光照存储在不规则的点云中，然后将它们连接成 Delaunay 四面体。为了找到相应的光照，我们首先找到采样位置所在的四面体，这是一个迭代过程，可能会开销较高。我们遍历网格，在相邻的网格之间移动。一旦确定了四面体的位置，就可以对存储在其各角上的光照使用重心插值。

光照预计算和存储的位置可以手动放置或者自动生成。它们被称为光照探针。该术语应当和环境光照的光照探针做区分，后者指记录在环境贴图中的远处光照。

从四面体网格中采样的光照质量高度依赖于网格的结构，而不是探针的密度。如果它们非均匀分布，则生成的网格可能会包含细长的四面体从而产生视觉瑕疵。如果手动放置探针，问题可以较容易地修正，但这毕竟还是手动操作。如果使用自动放置探针的方法，可以将一些可见性信息添加到探针或四面体中，来限制它们只对相关区域产生影响。

对静态几何体和动态几何体使用不同的存储方法是很常见的处理方式。比如，静态网格可以使用光照贴图，动态物体则从体积结构中获取光照信息。虽然这种处理方法很流行，但它们可能产生光照效果的不一致，这种问题一定程度上可以通过正则化来消除。

当烘焙光照时，需要额外注意仅在有效区域计算。模型网格通常是不完美的，一些顶点可能会出现在几何体的内部，一些网格会出现自交叉的情况。在这种有缺陷的网格处计算辐射度会出现错误，引起过暗或漏光。Kontkanen 和 Laine 以及 Iwanicki 和 Sloan 讨论了不同的启发式方法来解决这些问题。

**动态全局漫反射光照**

虽然预计算的光照可以产生非常棒的视觉效果，但它最大的优势也是它最大的缺点——它需要预计算。这类离线处理过程可能相当漫长。光照烘焙几个小时是很常见的事情。由于光照计算非常耗时，艺术家们往往被迫在不同的效果级别上工作，这又会进一步加剧对美术资源的要求，使烘焙时间进一步加长。这种恶性循环可能会严重影响产品的开发和迭代。在某些情况下，则完全无法使用预计算光照，比如几何体会在运行时变化，或是由用户创建出了新的几何体。

人们开发出了一些方法用于在动态环境中模拟全局光照，这些方法不需要预处理，或是它们的准备阶段足够快速，可以每帧执行。

最早的模拟动态全局光照的方法使基于“即时辐射度”的。虽然名字很像，但它和辐射度算法几乎没有交集。该方法从光源发出光线，光线命中的每一个位置上都会放置一个光源，表示该表面位置的间接光照。这些光源被称为“虚拟点光源”（_virtual point lights, VPL_）。基于该思路，Tabellion 和 Lamorlette 开发了一种用在《怪物史莱克 2》中的方法，该方法先在一个光照 pass 中执行了直接光照，并将结果存储在纹理中，然后根据缓存的光照信息来追踪光线以产生一次弹射的间接光照。对于大多数情形来说，一次弹射就足以创造出逼真的间接光照效果。该方法最早是离线方法，但它给予了 Dachsbacher 和 Stamminger 灵感，创造出了被称为“反射阴影贴图”（_reflective shadow maps, RSM_）的方法。

类似于常规的阴影贴图，反射阴影贴图也是从光源的视角渲染的。但不只是深度信息，它还存储了关于可见表面的其他信息，比如它们的反照率、法线和直接光照（flux）。当执行最终着色时，RSM 的纹素被当作点光源处理，它们产生一次间接光照弹射。由于一个典型的 RSM 中包含了成百上千的像素，只有其中的一个子集会被选中，这是通过基于重要性的启发式方法选定的。Dachsbacher 和 Stamminger 后来展示了使用逆向过程来优化该方法。相较于为每个着色点从 RSM 中提取相关的纹素，逆向过程则基于整个 RSM 生成一些光源投射到屏幕空间。

该方法的主要缺陷是不支持间接光照的遮蔽。

为了得到高质量的结果和维持光照移动时的时间稳定性，就需要生成大量的间接光源。如果生成少了，就会在 RSM 重新生成时发生位置突变，从而引起闪烁。另一方面，太多的间接光源会产生严重的计算开销。Xu 提出了用于《神秘海域 4》的技术，为了满足性能要求，它只使用了每像素 16 个光源，但是会使用多帧上的光源并在时域上滤波。

不同的方法被提出用于解决间接遮蔽的问题。Laine 等人使用双抛物线阴影贴图来作为间接光源，但将它们逐步地添加进场景中，因而在每帧中只需要渲染少量的阴影贴图。Ritschel 等人使用一种简化的基于点的场景表示，来渲染大量不完美的阴影贴图，这些贴图都很小且有缺陷，但经过滤波后就可以提供足够的清晰度和间接光照度的遮挡效果。

**光传播体**（Light Propagation Volumes）

辐射度传输理论是一种建模介质中电磁辐射传播的通用方法。它考虑了自发光、散射和吸收。虽然实时图形也致力于实现所有的效果，但即使是对最简单效果的模拟，也需要几个数量级的计算开销。但也有些技术对这类效果很有用。

光传播体由 Kaplanyan 提出，其灵感来源于辐射度传输理论中的离散坐标法（_discrete ordinate methods_）。该方法中，场景被离散为三维的规则网格，每一格中都有流过其中的辐射度的方向分布。他使用二阶球谐来存储这些数据。首先，光照被注入包含直接光照表面的格子中（可以使用 RSM 来查找这些格子，也可以用其他方式），注入的光照是从该表面反射出的辐射度。因此，它朝着离开表面的方向，有一个围绕法向的分布，并从材质中获得了颜色。接下来，这些辐射度会被向外传播。所有格子都分析相邻的辐射场，然后结合各方向的辐射度来调整自身的分布。

该方法的一个重要优势是，它为每个格子都生成了完整的辐射场。这意味着我们可以在着色中使用任意形式的 BRDF，虽然对于光泽 BRDF 来说，二阶球谐的反射质量不高。

为了支持远距离的光线传播，在增加体积覆盖的区域面积时，保持合理的内存开销，一种级联的变体方法被 Kaplanyan 和 Dachsbacher 提出。他们不再使用均匀体积的格子，而是渐进增大且相互嵌套的格子。光照被注入全部层级的格子，然后各自单独传播，查找时则选用当前位置细节程度最高的一级。

最原始的实现版本并未考虑间接光照遮蔽。修改后的版本则使用了 RSM 的深度信息来补充各体积之间的光线遮挡。这些信息并不完整，但场景可以在预处理阶段体素化以得到更精确的表示。

该方法也遇到了其他体积方法遭遇的问题，最大的问题就是漏光。不幸的是，增加网格的分辨率来修复该问题同样会引发其他的问题。如果使用较小尺寸的格子，就需要更多的迭代次数，严重增加了计算开销。在网格分辨率和性能表现上想要取得平衡并不容易。该方法也还有其他问题，如果限制了网格的分辨率，使用粗略的方向来表示辐射度分布，会引起传播时的信号衰减。对角线上的传播也容易在多次迭代后产生空间上的走样，但这类问题可以之后通过空间滤波解决。

**基于体素的方法**

由 Crassin 提出的体素锥形追踪全局光照（_voxel cone tracing global illumination, VXGI_）也是一种基于体素化场景的方法。几何体本身被存储在稀疏体素八叉树中。核心理念在于，该结构提供了一种类似于 mipmap 的场景表示，因此，场景中的一个体积区域可以快速地进行遮挡测试。体素中也包含了从其中的几何体反射而出的光线数量的信息。它们以一种方向性的形式存储，类似于辐射度向六个主要方向的反射。先使用 RSM 将直接光照注入最低层级（最精细）的八叉树中，再向更高层次传播。

八叉树是用于估计入射辐射度的。理想情况下，我们可以追踪一条光线来获取某个特定方向的辐射度。但这样做就需要大量的光线，所以使用一个平均方向的锥形追踪来替代。精准地测试锥体和八叉树的相交并不容易，所以通过沿着锥体轴向的查找来近似，每次查找都读取与给定点处截面尺寸对应的八叉树级别。这样的查找可以获得反射到锥点方向的辐射度，以及查找过程中被几何体占据的比例。该比例信息被作为后续点的光照衰减，类似于透明混合。整个锥形的遮蔽会被追踪，每一步中都会根据被几何体占据的比例减去一定的遮蔽。当累积辐射度时，会先乘以遮蔽因子。该策略不能探测出完整的遮蔽，但结果已经很好。

为了计算漫反射光照，就需要追踪多个锥形。生成多少锥形去追踪，则需要在性能和精确度上做取舍。一般认为整个锥形上的余弦项是一个常值，因此该项可以从反射方程的积分中提出来。这样做可以使得漫反射光照的计算可以像计算锥形追踪返回值的加权和一样简单。

该技术最早在虚幻引擎中实现，其开发者给引擎使用者们提供了一些优化建议。包括在低分辨率级别上进行锥形追踪，这样每个像素只需要追踪一个锥形。

使用稀疏八叉树存储光照信息的主要问题在于查询开销。一次典型的内存读取往往需要几百个时钟周期。GPU 的设计倾向于高并发高延迟。当遍历层级数据结构时，大部分的时间都浪费在等待下一个内存节点。

McLaren 使用级联三维纹理取代八叉树，类似于级联光照传播体。它们具有相同的维度，但会逐渐增大覆盖区域，这种方式下就可以仅通过纹理查询读取数据。存储在纹理中的数据和存储在稀疏体素八叉树中的数据是相同的，它们也包含反照率、占据比例，和六个方向的光照弹射信息。由于级联位置会随相机的移动而变化，物体会不断地进出高分辨率区域。由于内存限制，不太可能一直持有不同版本的体素信息，因此仅在需要的时候进行体素化。McLaren 同时也提出了很多其他的优化方案使得该技术可以在 30FPS 的游戏《明日之子》中使用。

**屏幕空间的方法**

正如屏幕空间的 AO，一些漫反射全局光照效果也可以仅使用屏幕上的表面位置模拟。这些方法不如 SSAO 流行，主要由于它们可用数据有限从而引起比较严重的走样。像颜色溢出效果往往是由强烈的直接光照照射大面积同色表面产生的，这样的表面很难完整地出现在视野中。这类情况就使弹射的光线数量高度依赖于当前帧的视野，在相机移动时会产生很明显的波动。出于此类原因，屏幕空间的方法仅用于在精细尺度上增强一些效果。这类系统曾用在游戏《量子破碎》中。辐照度体积被用于建模大尺度的全局光照效果，其屏幕空间方案可以提供有限距离内的光线弹射。

**其他方法**

Bunnell 计算 AO 的方法（顶点圆盘法）也可用于计算动态全局光照。

#### 10.6 镜面反射全局光照

如果我们想要显示非常光滑的材质，也就是有着很窄的镜面反射 lobe 的材质，我们就需要一种可以传递这类高频细节信息的表示方式。但同时，这也意味着反射方程的计算仅需要较小立体角中的入射光线，而不像兰伯特 BRDF 需要反射整个半球面的光照。这样的特性告诉我们应该如何做取舍。

存储入射辐射度的方法可用于传递粗略的、有视角依赖的效果。当使用 AHD 编码或者 HL2 基底时，我们可以将光照当作来自于编码方向的直接光照处理。但这类方法很不精确，特别是对于 AHD 编码。这些瑕疵也可以用更高精度的表示方式来缓解。Neubelt 和 Pettineo 使用球面高斯来表示入射辐射度（教团：1886）。为了渲染镜面效果，他们使用由 Xu 等人提出的技术，这是一种对典型微平面 BRDF 的镜面反射快速近似的方法。如果光照使用球面高斯表示，且菲涅尔项和遮挡-阴影函数在其支撑域中为常值，那么反射方程可以近似为：

$L_o(\textbf{v})\approx\underset{k}{\sum}(M(\textbf{l}_k,\textbf{v})(\textbf{n}\cdot\textbf{l}_k)^+\int_{\textbf{l}\in\Omega}D(\textbf{l},\textbf{v})L_k(\textbf{l})d\textbf{l})$

其中，$L_k$是表示入射辐射度的第$k$项球面高斯，$M$是结合菲涅尔项和遮挡-阴影函数的因子，$D$是 NDF。Xu 等人提出了一种各向异性球面高斯（ASG），他们使用该基底来建模 NDF。他们也提供了一种高效近似 SG 和 ASG 乘积积分的方法。

Neubelt 和 Pettineo 使用 9~12 个高斯 lobe 来表示光照，这使他们只能建模中等光泽的材质。由于游戏的故事设定发生在 19 世纪，所以该表示已经可以表示绝大多数的光照和材质。

**局部环境贴图**

到目前为止讨论的方法还不能渲染出真实的光滑材质。一种方法是使用更多的球面高斯或者更高阶的球谐函数来存储高频细节。但这有着很严重的性能问题，两者都具有全局支撑，需要存储和处理大量的数据。

在实时渲染中传递全局光照的镜面反射信息，最流行的方法是局部环境贴图。将入射辐射度用一张环境贴图表示，这样就只需要一点数值来计算辐射度。这种环境贴图是在场景中的特定一点渲染的，也经常被称为“反射探针”。

最早将环境贴图和场景中特定点联系起来的作品的《半衰期 2》。在该系统中，艺术家首先在场景中放置采样位置，之后的预处理阶段会为每一个位置渲染一张立方体贴图。物体就使用最靠近位置的贴图作为入射辐射度的表示来计算镜面反射的光照。但该技术可能会出现相邻的物体使用不同环境贴图的情况，这会引起视觉上的不匹配，但艺术家们可以手动修复该问题。

当物体较小时，在其中心位置应用局部环境贴图的效果很好很精确。但不幸的是，这类情况并不多见。更常见的情况是，多个物体共用同一个反射探针。离探针中心越远的物体，其表面的镜面反射准确度就越差。

Brennan 和 Bjorke 提出了一种解决方案。他们将入射辐射度当作来自于有限的球面范围处理。当查找入射辐射度时，并不直接根据方向索引环境贴图，而是当作从表面点发出的检测射线，真正的采样方向则使用环境贴图中心到球面交点的方向。这样做可以修正环境贴图的采样位置，该处理方式也被称为“视差校正”。该方法也可以用在其他图元上，比如盒形立方体，这类形状被称为“反射代理体”。当渲染光泽材质时，可以根据着色点到交点的距离来确定采样的环境贴图 Mip 层级。当多个探针覆盖相同区域时，一些直觉的方法是根据人为设定的优先度选择，或是做光滑的混合。

但不幸的是，该方法仍然会引起很多的瑕疵。反射代理体很少能精确匹配几何体，这会使得物体表面有些位置的反射被拉伸。对于一些非常光滑的材质尤为明显。另外，物体表面的 BRDF 中，有一部分来自于环境贴图的位置，接收该位置信息的表面点并不能被正确地存储进环境贴图中。

反射代理体也会引起光照泄露。经常发生在射线检测无法获取几何体遮挡信息的时候，这会使结果变量。该问题可以通过定向遮挡方法缓解。另一种常见的解决方法是使用预计算的漫反射光照，先将环境贴图中的值除以着色点的平均漫反射光照，这样就移除了环境贴图中的光滑度和漫反射贡献，只剩下高频部分。

人们提出了一些复杂的表示方法来描述反射代理体。Szirmay-Kalos 等人将每个反射探针的深度贴图存储起来，在查找时对其执行光线追踪。这可以提升结果准确度，但会引入额外的开销。McGuire 等人提出了一种更高效的光线追踪方法，他们存储了多个反射探针，如果一开始选用的反射探针不能提供足够的射线检测信息，那么就回退到另一个反射探针的深度缓冲。

反射代理体未必要是闭合的，凸的。像平面、矩形也可以用作反射代理体。

**动态更新环境贴图**

使用局部反射探针要求每张环境贴图都被渲染和滤波。虽然这项工作一般都是离线完成的，但也有一些情况需要运行时生成。比如开放世界的时间变化，或是场景物体的动态生成。

实际上，确实有一些游戏会在运行时渲染反射探针。这类系统需要谨慎处理性能问题。一般情况下不太可能每帧重新渲染全部的可见探针，因为典型的游戏场景中通常存在数十乃至上百的探针。幸运的是，我们确实也不需要每帧全部重新渲染。我们很少需要反射探针精确地描述周围的物体。这种假设允许我们在加载时间渲染一些探针，然后渐进地渲染剩下的探针。

虽然我们很想实时地渲染动态几何体，但我们也可以接受在较低的帧率下更新探针。我们可以人为定下多少帧来渲染反射探针，每帧更新多少个探针。启发式的方法基于探针距离相机的距离及上次更新的时间等因素来确定更新的时机，对于时间开销吃紧的情况，也可以将一张环境贴图的渲染拆分到多帧，比如每帧只渲染立方体贴图中的一个面。

高质量的滤波一般用在离线的卷积运算中。这类滤波方法包含了对输入纹理的多次采样，几乎无法在高帧率下运行。Colbert 和 Krivanek 开发了一种使用重要性采样的技术，可以较好地处理滤波。为了消除大多数噪声，他们从各级 mip 中采样立方体贴图，使用启发式方法来决定每个样本从哪一级 mip 中读取。Manson 和 Sloan 构建了基函数所需要的滤波核。构建该核所需要的精确系数必须在优化过程中获得，但对于给定的形状，优化过程只发生一次。卷积分两个阶段执行，第一个阶段，环境贴图使用一个简单的核同时降采样；第二个阶段，从各级 mip 上采样到的样本结合到一起来构建最终的环境贴图。

渲染复杂场景时，即使是渲染立方体贴图的一个面，对于 CPU 来说也是开销巨大的。一种解决方案是离线地为环境贴图准备 G-buffers，且只对光照和卷积做计算。需要时，也可以在预生成地 G-buffers 上渲染动态几何体。

**基于体素的方法**

在性能限制严格的情况下，局部环境贴图是一个很好的解决方案，但效果比较一般，实际使用中必须找一些变通方法来遮掩探针布置不足的问题。

体素锥形追踪（稀疏八叉树版本或级联版本）也可用于镜面反射的处理。该方法对存储在稀疏体素八叉树中的场景使用锥形追踪。一次锥形追踪只能得到一个值，即锥形所覆盖的立体角的平均辐射度。对于漫反射光照来说，需要追踪多个锥形，单独追踪一个锥形的结果是不准确的。但对光泽材质使用锥形追踪则效率上可以高很多。在镜面反射光照中，BRDF 的 lobe 是狭窄的，且只需要考虑一个立体角内的辐射度，不再需要考虑追踪多个锥形。只有当处理较粗糙表面的镜面反射时才可能需要追踪多个锥形，但是由于这类反射通常是模糊的，那么只需要回退到局部反射探针就足以满足需要，不用再进行锥形追踪。

当处理非常光滑的材质时，锥形非常狭长，几乎是一条直线，这会使得底层的体素化较为明显，呈现出体素化的立方体。但在实际使用中，这类瑕疵很少构成问题，因为反射效果通常不是直接看到的。反射贡献会经由纹理调整，这通常可以遮掩其中的问题。当确实需要完美镜面反射时，有许多其他方法可以做出很好效果的同时降低开销。

**平面反射**

另一种处理镜面反射可选的方案就是重用常规的场景表示方法、将场景重新渲染到一张图片中。如果场景中的反射表面很有限，且都是平面的，我们可以使用常规的 GPU 渲染管线来生成反射图片。这些图片不仅提供了精确的反射信息，而且可以结合一些其他的处理得到非常逼真的光泽材质效果。

根据反射定律，我们可以将反射渲染当作对镜像物体的渲染。为了得到准确的光照，光源也需要被放进平面中。一种等效的方法是将观察者的位置放置到反射平面的另一边，这样就可以通过简单调整投影矩阵得到反射结果。但位于另一边的物体不应当被记入反射中，该问题可以通过反射面的表达式解决。最简单的方法是在像素着色器中定义一个与反射平面重合的裁剪平面。

**屏幕空间的方法**

正如 AO 和漫反射全局光照一样，镜面反射也有屏幕空间的方法。屏幕空间的反射要比屏幕空间的漫反射精确一些，因为其 lobe 要锋利很多。镜面反射所需要的辐射度只来自于有限的立体角，而不是整个半球面，因此，屏幕中的数据有很大概率可以包含这类信息。这类方法由 Sousa 等人率先提出，该方法族统称为“屏幕空间反射”（_screen-space reflections, SSR_）。

给定一个着色点、视线方向和表面法线，我们就可以沿着视线的反射方向追踪光线，测试其与深度缓冲的相交。该测试是通过迭代地沿着光线前进得到的，每一步中将当前位置投影到屏幕上，和深度缓冲的深度做对比，如果当前位置的深度大于深度缓冲中的深度，则光线与该位置的几何体相交，就可以读取该位置的颜色缓冲值来表示该方向的入射辐射度。该方法假定了所有相交的几何体表面都是兰伯特的，这是一种近似处理。在有限距离内，可以通过多次迭代二分查找来定位精确的交点位置。

McGuire 和 Mara 注意到，由于透视投影，世界坐标下统一步长的贡献并不相同。较近的步进可能会越过一些交点，较远的步进采样则可能重复采样。他们建议使用屏幕空间的步进来替代世界空间下的步进，使用“数值微分法”（DDA），一种可用于光栅化直线的方法。

首先，先将所追踪光线的起点和终点投影到屏幕空间。依次检查沿着该直线的每个像素，保证其具有屏幕空间上的均匀精度。该方法不需要对视界空间中每个像素深度的重建做相交测试。视角空间深度的倒数，也就是典型透视投影下存储在 z-buffer 中的值，在屏幕空间中是线性变化的。这意味着我们可以在追踪前通过屏幕空间坐标计算出导数，然后使用插值的方式得到沿着屏幕空间线段的值。插值得到的结果可以直接和深度缓冲中的数据比较。

最基本的屏幕空间反射形式仅追踪一条光线，也只能支持完美镜面反射。但是，完美镜面反射很少见到。在现代 PBR 管线中，光泽反射用得更多，SSR 也同样被用于渲染光泽反射。

一种专门设计的简单方法是，反射仍然只追踪沿着反射方向的一条光线，但结果存储在一个离屏缓冲中，留待后续步骤处理。后续步骤会应用一系列的滤波核，通常会结合降采样来生成一组反射缓冲，每一个都对应不同的模糊程度。当计算光照时，再根据 BRDF lobe 的宽度选用不同的反射缓冲采样。尽管通常选用匹配 BRDF lobe 形状的滤波器，但这仍然只是一种粗略的近似方式，因为屏幕空间的滤波并未考虑不连续性、表面朝向以及其他一些对结果精度影响很大的因素。最后会增加一些客制化的启发式方法来提高视觉效果。

Stachowiak 以一种更合理的方式解决该问题。计算屏幕空间的反射是一种光线追踪形式，正如光线追踪一样，它也可用于计算蒙特卡洛积分。他使用对 BRDF 的重要性采样，并随机地射出光线。由于性能限制，追踪过程只采用一半的精度和少量的 SPP（1~4）。这样少的光线数量会使结果含有大量噪声，所以相交结果会在邻近像素内共享。该方法假定了一定范围内像素的局部可见性是相同的。如果从$\textbf{p}_0$向$\textbf{d}_0$的光线与场景交于$\textbf{i}_0$，则可以假定一条从$\textbf{p}_1$向$\textbf{d}_1$也经过$\textbf{i}_0$的光线与场景的交点也在$\textbf{i}_0$，且在这之前没有其他交点。

为了进一步提升有效光线数量，可以对结果进行时间滤波。通过离线计算与场景无关部分的积分并存储在查找表中，也可以减少最终积分的方差。当我们可以在屏幕空间中获得这些信息时，就可以应用这些策略来得到精确的、无噪声的结果，十分接近路径追踪的结果。

在屏幕空间追踪光线是开销很大的。它需要重复地采样深度缓冲很多次，并对查找结果执行一些操作。由于这些读取操作相当不连贯，缓存的利用率会很差，使得着色器在执行时会有很多的时间浪费在内存读取上。屏幕空间反射通常在更小的分辨率上计算，然后叠加一个时间滤波来弥补降低的分辨率。

Uludag 提出了一种使用多级深度缓冲的优化方法来加速追踪。首先建立一个多级深度缓冲，将深度缓冲逐级降采样。更高层级深度缓冲中的每个像素，存储了低层级上相应四个像素中的最小深度值。接着在多级深度缓冲中追踪光线。如果某一步未命中几何体，则前进到像素边界处，下一步使用更低分辨率的深度缓冲；如果某一步命中了，则前进到相交的位置，在下一步中使用更高分辨率的深度缓冲；直到达到最高分辨率的深度缓冲时，追踪结束。

该方法对于长远光线追踪的效果良好，因为它保证了不会遗漏任何特性的同时能以较大的步长前进。它同样使得缓存命中率提高，深度缓冲不再是随机读取，而是在邻域内读取。

其他方法则避免完整地追踪光线。Drobot 复用了反射代理体的相交位置，并从中查找屏幕空间反射的辐射度。Cichocki 假定了使用平面反射并逆转了光线追踪的过程，通过一个全屏的 pass 让所有像素将其值写入应当反射的位置。

和其他屏幕空间的方法一样，屏幕空间的反射也会遇到由数据量有限引起的瑕疵。通常发生在反射光线离开屏幕范围的时候仍未有交点。这类情况需要谨慎处理，因为即使是相邻的像素，其追踪的有效性也是不同的。

另一种 SSR 的问题是缺少深度缓冲中物体的厚度信息。因为深度缓冲中只存储了一个值，所以无法获取光线穿透表面之后的信息。Cupisz 讨论了不同的低开销方法来弥补该问题。Mara 等人提出了深度 G-buffer，可以存储多层深度数据。

屏幕空间反射是一类提供反射效果的有力工具，比如附近物体在平整表面的局部反射。屏幕空间反射作为第一层处理，如果它无法准确的结果，则回退到使用局部的反射探针。如果该区域没有使用任何反射探针，就使用一个全局的、默认的探针。

#### 10.7 统一方法

虽然目前为止讨论的方法可以结合起来生成非常漂亮的图片，但它们不如路径追踪那样理论简洁、实现优雅，它们对渲染方程的每个部分都做不同的处理，每种方法都有自己不同的妥协，即使最终的结果看上去不错，但仍存在很多情况会使这些方法失效。因此，实时路径追踪成为了研究的重点。

使用路径追踪渲染出可接受质量的图片，其计算量远超 CPU 的能力，需要使用 GPU 计算。实时路径追踪的应用包括建筑漫游和电影预览渲染。这些应用可以接受较低的不断变化的帧率。像渐进细化一类的技术也可以在相机不动时提高图片质量。高端系统可以考虑使用多 GPUs。

与之相反，游戏需要按最终画质渲染，且需要在稳定的时间预算中完成。此外，GPU 可能还需要执行渲染以外的任务。比如，粒子模拟通常需要在 GPU 上执行，来降低 CPU 的负担。以上种种因素使得路径追踪用于游戏暂且无法实现。

相比于没有硬件支持的纯路径追踪渲染，更合理一些的方案是使用路径追踪渲染那些用光栅化很难处理的效果。这样的系统仍然是一种缝合物，仍然缺少纯路径追踪的简洁和优雅，但是实时渲染总是伴随着妥协的。如果放弃一些优雅可以换来少许的时间提升，那么这就是最正确的选择，因为帧率是不可退让的。虽然我们可能永远无法解决实时渲染的问题，但是路径追踪的广泛应用可以使终极目标越来越近。

光线追踪依赖于某种加速结构，比如多级包围体（_bounding volume hierarchy, BVH_）来加速可见性测试。原生的 BVH 实现并不适合 GPU，GPU 每个 warp 中的多个线程同时执行相同的操作，因此需要使代码中尽可能减少分支语句。假设每个线程处理一根光线，该方法通常会使线程间有大量的分支。不同的光线执行不同的分支，在遍历中会与不同的包围体相交，有些光线会提前退出遍历。为了解决该问题，遍历方法需要调整为减少分支、且可以继续利用已经结束遍历的线程。

为了生成高质量的图片，每个像素往往需要追踪成百上千的光线。即使是优化的 BVH、高效的遍历算法、最快的 GPU，也不太可能做到在哪怕最简单的场景里实时地计算。而在可接受性能范围内渲染出的图片则具有很多的噪声，不适合直接显示。但是，它们可以通过降噪算法来去除绝大多数噪声。我们甚至可以使仅使用 1spp 渲染的图片，降噪后的效果看上去很接近参考图。

### 11. 图像空间特效

#### 11.1 图像处理

结合可编程着色器以及将输出图片作为输入纹理，为使用 GPU 来实现各种图像处理效果开辟了道路。在渲染后对图像最调整被称为“后处理”。

使用 GPU 进行后处理有一些关键技术。场景通常被渲染进某种形式的离屏缓冲中，比如颜色图片、深度缓冲等。这些图片会被当作纹理使用，该纹理将被应用到填充屏幕的四边形中。

sinc 滤波器和高斯滤波器的一个问题是，它们的作用域是无限远的。一种解决方案是将滤波器钳制在特定的直径或矩形区域内，将任何超出该范围的值视为 0。其他的滤波核可能为不同的目的设计，比如易于控制、平滑、或是易于计算。Bjorke 和 Mitchell 等人给出了一些常用的具有旋转不变性的滤波器。

任何全屏滤波操作都会在边缘处试图采样到屏幕外的像素。比如，如果使用$3\times 3$的滤波核，那么当处理最左上角的屏幕像素时，就会尝试获取一些不存在的像素。一种基本的解决方案是将采样器钳制在边缘内。当出现超出屏幕的采样时，使用最接近的边缘纹素值。这会导致边缘滤波出现错误，但这通常不很明显。另一种解决方案是生成一张分辨率略高于屏幕的图片。

利用 GPU 的优势，可以通过其内建的插值和多级纹理映射机制来减少滤波所需的纹素。对$3\times3$网格进行 9 次采样是完全没有必要的，当一张纹理使用了双线性插值，一次纹理读取可以获得相邻四个纹素的加权和。基于此，$3\times3$网格可以通过 4 次纹理读取获得加权和。而对于盒式滤波器来说，其各样本的权重相等，$2\times2$的盒式滤波器可以通过采样一次四个纹素的中间位置得到这四个样本的均值。对于高斯滤波器而言，由于各位置权重不同，使用双线性插值的结果并不准确，但仍然可以将采样位置放在两个纹素之间，但位置有所偏移。

一些滤波核是可分离的。两个例子是高斯滤波器和盒式滤波器。这意味着它们可以拆成两个一维的滤波核。这样做可以显著减少需要访问的纹素。比如$5\times5$的盒式滤波器可以先做水平方向相邻 5 个像素的均值，再做竖直方向相邻 5 个像素的均值，这样就可以将原本需要的 25 个纹素降低为 10 个。卷积核越大，效益越明显。

圆盘滤波器，对散景效果尤为有用，但计算开销较大，它并不能在实数域上被分离，但可以使用复数域。Wronski 讨论了该方案的实现细节。

计算着色器很适合滤波计算，而且滤波核越大，相较于像素着色器的优势就越明显。

降采样是另一项常用于模糊的技术。其思路是生成更小分辨率的图像用于处理。比如将分辨率沿两个轴向减小到原来的一半，从而得到原图四分之一尺寸的图像。取决于输入数据和算法需求，原图可能是通过滤波降低分辨率，也可能是直接生成了低分辨率图像。当最终输出为完整分辨率的图像时，需要使用双线性插值放大图像。这个过程就产生了模糊效果。将小分辨率的图像放大可以显著减少需要获取的纹素数量，当然，模糊质量并不高，但当模糊具有相似颜色的区域时，例如眩光效果，其中的小瑕疵并不会很明显。降采样也可用于其他变化不大的现象，比如许多例子系统就使用半数分辨率渲染。降采样的思路还可以推广到从多级纹理中采样来进一步加速模糊处理。

**双边滤波**（Bilateral Filtering）

上采样以及其他一些图像处理结果可以通过双边滤波来提升质量。该方法的思路在于降低或者丢弃与中心样本所在表面无关的样本。这类滤波器是用于保持边缘的。 有些情况下只需要使用像素的颜色信息就可以决定哪些像素应当被丢弃；在一些更复杂的情况下，双边滤波器使用更多的额外信息，比如深度、法线、ID、速度等。

只使用相机深度信息来寻找边缘通常是不够的。我们可以仅使用具有相似深度和面法线的相邻像素做滤波，这类双边滤波器被称为边缘保持滤波器（_edge-preserving filters_）。如何选用相邻像素由开发者决定，这也依赖于模型、渲染算法、观察环境等因素。

除了测试相邻像素需要的额外开销，双边滤波也有其他的性能问题。一些滤波优化方案，比如分离滤波和双线性插值可能就不那么好用了，因为我们并不能提前知道哪些样本会被丢弃。

实现后处理管线最常用的方法是使用乒乓缓冲（_ping-pong buffers_）。它的思路很简单，就是在两个离屏缓冲中应用后处理操作，一个缓冲用于当前操作，另一个用于最终结果。在第一个 pass 中，第一个缓冲作为输入纹理，第二个缓冲作为输出纹理；在之后的 pass 中，两者对调。

在之前的章节中，像素着色器中获得相邻像素的信息来做形态学抗锯齿、软阴影、屏幕空间 AO 以及其他一些操作。后处理效果也基本上都是在最终图像上进行的，可以模拟热成像效果、胶片颗粒、色差、边缘检测、热源效果、涟漪等。

#### 11.2 重投影技术

重投影的灵感来源于复用之前帧得到的样本。正如其名，会尽可能从一个新的视角位置和方向复用之前帧的样本。重投影方法的目的是为了在多帧上摊销渲染成本。另一个目的是为了能在应用程序未及时生成当前画面的情况下，得到一帧近似的画面。后者对虚拟现实应用很重要。

重投影技术分为逆向重投影和正向重投影。

**逆向重投影**：当需要渲染时刻 t 的一个三角形时，就需要同时计算当前帧和上一帧的顶点位置。计算两帧中同一像素的深度信息，如果它们足够接近，则颜色缓冲中的像素可以被复用。如果之前帧中该位置像素被遮挡了，但在当前帧又可见，则被称为*cache miss*，需要进行像素着色计算。由于重用着色值假定了与移动方式无关，那么最好不要在过多帧上复用。另一种逆向重投影的方法是将速度缓冲存下来，在整个屏幕上做测试，这样可以避免运算两次顶点坐标变换。

为了得到更高的重投影质量，通常会使用平均运动滤波器（_running-average filter_），它能逐步丢弃比较旧的值，常被用于空间抗锯齿、软阴影和全局光照中。该滤波器描述为：

$\textbf{c}_f(\textbf{p}^t)=\alpha\textbf{c}(\textbf{p}^t)+(1-\alpha)\textbf{c}(\textbf{p}^{t-1})$

其中，$\textbf{c}(\textbf{p}^t)$是点$\textbf{p}^t$的新值，$\textbf{c}(\textbf{p}^{t-1})$是之前帧的逆向重投影值，$\textbf{c}_f(\textbf{p}^t)$是滤波后的最终值。Nehab 等人使用$\alpha=3/5$作为常用值，但建议根据实际渲染情况使用不同的值。

**正向重投影：**正向重投影则是将上一帧的像素投影到当前帧上，因此不需要两次顶点着色。这意味着上一帧的像素被分散到了当前帧，而逆向重投影则是将上一帧的像素收集起来用于当前帧。这些方法都需要解决原本被遮挡的区域之后可见的问题，通常使用不同的启发式填充方法解决，也就是从周边像素推断缺失部分的像素。Yu 等人使用正向重投影来计算景深效果。相比于经典的孔洞填充方法，Didyk 等人使用依据移动向量自适应生成的网格覆盖上一帧，这些网格根据深度测试渲染，投影到当前帧，这意味着遮蔽和折叠可以当作依据深度测试来光栅化这些自适应网格的三角形处理。Didyk 等人使用该方法来实现从左眼到右眼的重投影，从而实现虚拟现实的立体视觉。后来，Didyk 等人提出了感知运动方法来实现时序上采样，例如将帧数由 40Hz 提升到 120Hz。

Yang 和 Bowles 提出了向相邻两帧（t, t+1）之间投影的方法，也就是投影到$t+\delta t,\delta t\in[0,1]$。该方法更适合解决遮挡问题，因为它利用了两帧画面的信息。这类方法常用于游戏插帧，可以将画面帧率从 30FPS 提升到 60FPS，因为该方法的计算开销通常少于 1ms。

#### 11.3 镜头光晕和辉光

镜头光晕是一种由光线穿透镜头时的间接反射引起的现象。光晕又可以细分为几类典型的现象，其中最重要的是光环和纤毛状光环。光环是由镜头的径向透镜结构引起的，看上去像一圈围绕光源的环，外环是红色，内环是紫色；光环的大小是固定的，与光源距离无关。纤毛状光环则是由镜头的密度变化引起的，看上去像是从一点发出的许多条射线。

当光线在镜头间发生反射和折射时还会产生一些次生效果。辉光是由镜头或眼睛内部的光线散射引起的，会在光线周围产生发光效果且使场景其余部分变暗。

光晕、纤毛状光晕和辉光效果，统称为眩光效果。

实际上，随着相机技术的不断进步，这类瑕疵效果越来越少。镜头模组的设计、防反射涂层等技术都可以减少这类问题。但是现在常通过数字合成方式将这类效果添加到照片中，这是由于显示器的亮度是有限的，我们可以通过添加这类效果创造出更加明亮的印象。

镜头光晕应当伴随光源的移动而变化。King 生成了一系列不同纹理的方块来表示镜头光晕。这些方块之后按照从光源位置到屏幕中心的方向排布。当光源距离屏幕中心较远时，这些方块就小而透明，越接近屏幕中心则变得越大且不透明。

来自场景中明亮物体或光源的眩光也可以用相似的方式来出处理，即通过半透明广告牌或者后处理滤波。例如《GTAV》中就为广告牌应用一组纹理来制作各种效果。

还有许多其他变种技术存在。Milttring 使用图像处理来分割明亮区域，降采样后模糊，复制、缩放、镜像、着色等过程处理之后合成回来。

辉光效果是一种亮度溢出效果。基本思路是将画面中的明亮物体“过曝”后模糊，再合成回原来的图像中。 模糊通常使用高斯模糊，虽然和参考照片的比对表明，该分布存在较多的峰值形状。制作辉光效果的常用方法是使用一个*bright-pass filter*，它保留明亮的像素，将其余像素设为黑色，过渡处使用一些混合或者缩放。

辉光图像可以渲染在低分辨率上，比如原图宽高的一半到八分之一都可以。降低分辨率既可以节省计算开销，也有助于提高滤波效率。这些低分辨率的图像在模糊后与原图结合。降低分辨率的方法在后处理中经常使用。辉光图像可以降采样多次，从这些低分辨率的图像中采样可以在降低采样开销的同时创造出丰富的模糊效果。

由于辉光效果是使图像中的明亮区域看起来过曝，这要求颜色叠加到原来的图像上。增量混合会使颜色最终变为白色。也可以使用透明混合来提供可控的艺术效果。不设定阈值，改用 HDR 图像也可以带来更好的滤波效果。LDR 和 HDR 的辉光效果可以各自计算后再合成到一起，来描述不同的现象。

#### 11.4 景深

对于给定的相机参数，有一个确定的对焦范围，也就是它的“景深”。范围之外的物体会变得模糊，离得越远越模糊。在摄影中，这种模糊和光圈大小以及焦距息息相关。减小光圈会增加景深范围，也就是对焦范围更长，但是画面的进光量会减少。拍摄室外白天场景通常会使用大景深，因为室外光线充足，可以使用较小的光圈，极端情况下就是针孔相机。拍摄昏暗室内场景时，通常使用较窄的景深。因此，控制景深效果的一种方案是将其与色调映射绑定，当画面亮度降低时，就使离焦物体更加模糊。另一种控制方案就是手动调节，可以按照艺术需求调节想要的效果。

累积缓冲也可用于模拟景深效果。通过调节相机位置，但固定焦点，那么场景物体就会依据与焦点的距离而产生不同程度的模糊。类似于其他累积效果，该方法需要多次渲染画面，最终逐渐收敛至正确结果。该方法通常用于效果测试。光线追踪也可以使用类似的方法得到物理正确的结果。如果要提高效率，可以对离焦物体使用低级别的 LOD。

虽然对交互应用不实用，但是累积方案提供了一种记录各像素信息的理想方法。物体表面可以分成三种区域：焦点附近的区域（对焦区）、更远一些的区域（远场）以及更近一些的区域（近场）。因此，景深效果就变成了对近场和远场物体做模糊的效果。

解决该方法的一个受限方案是生成几个不同的图像。分别渲染出对焦图像、远场图像和近场图像。这可以通过调节远近裁剪平面实现。然后将远场图像和近场图像模糊后，与对焦图像按照从后向前的顺序合成到一起。但是如果物体横跨多个图像就会出现问题，另外模糊效果也是相对固定的，并不会随着到焦点的距离改变。

另一种思路是按照景深效果对表面单个位置上的影响考虑的。想象表面上的一个小点，如果该表面处于焦平面上，则该点只会对应一个像素。如果该表面处于焦外，则该点也会影响其周边的像素，取决于具体的视点，极端情况下，该点会在周围形成一个填充的圆圈，摄影术语中称为“散光圈”。在摄影中，离焦区域的艺术效果被称为"散景"（_bokeh_），来自于日语中的“模糊”。由于穿过光圈的光线通常是均匀分布的，所以散光圈的形状一般和光圈叶片的数量、尺寸相关。寻常价位的相机通常会产生五边形的散光圈。高端的相机会有更多的叶片，光圈叶片越多，散光圈也就越接近于圆形。

一种计算景深的方法是将表面像素的着色值分散到圆形或多边形内部。这种分散并不适合像素着色器，因为像素着色器是为并行计算设计的，无法高效地获取周边像素的信息。一种解决方案是为每一个处于近场或远场的像素都渲染一张精灵图片。每张精灵图片都渲染在一个单独的层上，其尺寸取决于散光圈的大小。每个层上存储重叠的精灵图片的平均混合和，并向下合并。该方法有时也被称为正向映射技术。但该技术存在一些问题，其中最严重的就是时间开销不固定，这容易引起性能问题，使用户体验不稳定。

另一种方法是假定局部相邻像素之间的深度是相同的。那么就可以从之前的 pass 中聚集信息完成着色，根据深度信息模糊像素以产生景深效果。这类方法被称为反向映射或逆向映射方法。

大多数实际使用的算法都从相机角度的原始图像开始。这意味着从一开始就已经丢失了一些信息。从其他视角观察场景可以找到在单一视角中不可见的部分。我们应当尽可能地利用可见的样本信息。

这里介绍 Bukowski 等人的聚集方法。他们的方法基于深度信息为每个像素都生成一个带符号的值来表示散光圈的半径。该半径可以从相机设置中导出，但艺术家们往往喜欢手动调节效果。半径的符号表示像素位于近场还是远场，而当$-0.5<r<0.5$，则表示落在焦平面上，给半个像素的模糊。

包含散光圈半径的缓冲之后被分成了两张图像，一张表示近场信息，另一张表示剩下的信息，两张图像都进行降采样和模糊处理。这种分割可以解决一个关键问题，即近场物体应当有模糊的边缘。如果我们只根据像素的半径来模糊像素，这可能会使得前景物体被模糊了，但其边缘仍然是锋利的。例如，当轮廓介于前景物体和焦点物体之间时，由于采样半径突然降至 0，前景的模糊效果在其轮廓处突然消失。我们需要在近场物体的边缘上也具有平滑的模糊效果。这可以通过在一张单独的近场物体图像上做模糊实现。另外，近场图像上的每一个像素都有一个 alpha 值，表示混合因子，该值也同样被模糊。使用双边滤波和其他的测试方法可以获取到这两张图像。

当完成分离图像和模糊操作后进行图像的合成。散光圈的半径就成为了图像之间的线性插值系数。近场图像中的 alpha 值用于混合近场图像和插值结果。这样，近场模糊的内容就可以正确地扩散到后方的场景中。

#### 11.5 运动模糊

快速运动的物体如果在两帧中“越过”了一些像素，就会形成一种时域上的走样问题。运动模糊就是一种消除时域走样问题的技术。正如增加分辨率只能改善走样问题而不能消除走样问题，增加帧率也只能改善时域走样，消除时域走样需要借助运动模糊。实际上，30FPS 的游戏使用了运动模糊后的观感甚至好于 60FPS。

运动模糊依赖于相对运动。如果物体从左往右穿过屏幕，那么它就是水平模糊的。如果相机跟踪一个运动物体，则物体不会有模糊，而背景会模糊。优秀的导演直到如何拍摄，可以使感兴趣的内容落在焦点上而不产生模糊。

运动模糊确实也可以通过混合一段时间内的画面得到，但是这种方法效率很低，而且如果物体运动速度过快，仍然会留下鬼影。如果相较于物理相机的真实性，更看重的是对运动状态的暗示，那么可以用更高明的方法来实现画面积累。比如我们想通过积累 8 帧画面制作运动模糊，那么接下来只需要再渲染一次第 1 帧并将其从累积中减去，加上新的第 9 帧，就可以得到新的连续 8 帧画面。这就可以将渲染开销从每帧渲染 8 次，降低至渲染 2 次。

实时渲染需要比多次渲染更快的技术方案。景深和运动模糊当然都可以通过多视角的画面累积得到，但为了更高效地生成这些效果，应该将样本向周围像素发散，但通常会采用从周围聚集的方式。

运动模糊有几种不同的类型，可以分为相机朝向的变化、相机位置的变化、物体位置的变化和物体朝向的变化。如果相机位置不变，则可以将整个场景当作一个天空盒，相机朝向的变化会给运动模糊带来一个方向，当给定相机转动的方向和速度后，沿着该方向采样每个像素，并根据速度决定滤波宽度。这类方向性的模糊被称为线积分卷积（LIC），也常被用于流体可视化。

如果相机位置改变，就需要考虑视差因素，比如远距离的物体在视野中的相对运动就没有那么快，因此模糊效果也会更弱。如果相机向前运动，则视差可以忽略，使用径向模糊可能就足够了，但也可能会产生过于夸张的效果。

为了提高真实性，比如在竞速游戏中，我们需要一个正确计算物体运动的模糊效果。比如在向前的视角下水平移动，在图形学中称为“pan”，深度缓冲中的信息可以告诉我们如何模糊各物体。越靠近的物体，模糊程度越高。向前运动的情况就会复杂一些，Rosado 提出使用之前帧相机的视角矩阵来实时计算运动速度。这个思路在于根据深度信息重建屏幕像素的三维坐标，然后再将这些三维坐标用上一帧的视角矩阵转变回屏幕坐标，计算出运动向量用于运动模糊。

如果物体独立于其他物体运动，则问题会更加复杂。一种简单但有局限性的方法是，各自处理自身的运动模糊。这也是通过绘制线段来表示粒子运动的原理。这个思路也可以被推广到其他物体上，想象一把剑划过空中，在剑刃前后沿着边缘增加两个多边形。这两个多边形带有顶点透明度，当剑刃处于其中时为不透明，当剑刃处于边缘时，则完全透明。该思路的关键在于通过透明度来模拟方向性的运动模糊。但这种几何操作是非常昂贵的，因此人们用聚集方法替代发散。对于景深效果，我们将每个像素都扩散到它的散光圈中；对于运动模糊，则将样本沿运动路径拉伸，类似于线积分卷积。快速运动的样本会覆盖更多的区域，则每个位置上留下的就比较少。理论上，我们可以为每个屏幕样本绘制其半透明线段。

为了使用上述方法，我们就需要直到每个屏幕像素的运动速度。一个广泛采用的方法是使用速度缓冲。Wronski 讨论了计算速度缓冲以及将运动模糊和时域抗锯齿结合。

得到运动缓冲和原始画面后，我们就可以重建出每个像素受哪些物体影响。在第一个 pass 中，计算出屏幕上每个区域的最大速度，比如对于每个$8\times8$的屏幕分片，就可以得到每个分片的最大速度向量。第二个 pass 中，对分片的缓冲使用$3\times3$的测试，找出其中最大速度。该 pass 确保了快速运动的物体会对它周围的分片产生影响。在最后的 pass 中计算出模糊的图像。

### 12. 多边形之外

除了传统的顶点表示模型之外，基于图像的渲染也是很有用的手段。像云、毛发等物体很难用三角形表示，而分层的半透明图像更适合表示这类复杂材质。

#### 12.1 渲染光谱

渲染的目标是为了在屏幕上描述物体。目前尚没有唯一正确的方法渲染场景。每一种真实感渲染方法都是对现实的近似。

![](D:\Projects\RealtimeRendering\images\Rendering_Spectrum.png)

#### 12.2 固定视角的效果

具有复杂几何和着色模型的场景可能很难在交互速率下重复渲染。但限制了视角的移动后就有了很多加速方案。最严格的限制之一就是相机完全无法移动，这种情况下，许多内容只需要渲染一次。

比如，想象一个用栅栏围起来的牧场，一匹马儿穿过。牧场和栅栏只需要渲染一次，颜色缓冲和深度缓冲都存储下来。每一帧中都使用该颜色缓冲和深度缓冲作为初始化信息，只需要再单独渲染马匹即可。

#### 12.3 天空盒

环境贴图可以表示局部空间的入射辐射度信息，虽然这类贴图常用于模拟反射，但它们也可用于表示周围的环境。任何环境贴图的表示形式，如全景图或者立方体贴图，都可用于该目的。它们的网格模型足够大，可以包括进整个场景，这个网格模型就被称为天空盒。

对于比较靠近的物体，可以观察到明显的视差现象，这种现象反过来也有助于获取物体的深度信息；但对于足够远的、相互之间比较接近的物体，几乎很难观测到视差现象。

天空盒通常以相机位置为中心，伴随相机移动。对于大多数天空盒来说，相机的移动距离都不足以产生视差效果。

天空盒通常使用立方体贴图或者盒模型渲染，如果需要较高质量的天空盒，一般需要较高分辨率的纹理，即纹理分辨率和屏幕分辨率相当，这种对应关系可以用公式描述：

$\rm texture\ resolution=\frac{screen\ resolution}{tan(fov/2)}$

其中，fov 即为相机的视界角。视界角越小则纹理分辨率越高，因为更小的纹理区域却对应了相同的屏幕区域。

其他形状的天空盒也是可能的，比如用一块平整的穹顶表示天空，这种方式很适合模拟云在空中的运动。

由于天空盒总是位于一切物体之后的，所以我们不必记录天空盒的深度信息，我们也通常首先绘制天空盒。当然，如果在不透明物体之后、透明物体之前绘制天空盒，也可以减少 overdraw。

#### 12.4 光场渲染

辐射度可以从不同的位置、不同的方向、不同的时间捕获。现实中，计算摄影学领域就致力于探索如何提取出这些信息。纯粹的基于图像的物体表示方法也可用于显示。例如，光流场技术（Lumigraph）和光场渲染技术就尝试从不同视角捕获同一个物体。当给定一个全新的视角，该类技术就尝试从已有的不同视角中插值出新的结果。这是一类很复杂的问题，需要存储大量的数据。该类技术类似于全息投影，全息投影通过二维的视角数组来表示物体，该类技术的诱人之处在于，可以完整捕获现实中的一个物体，并从任意角度展示该物体。无论光照环境和物体的复杂度如何，该类技术都能以固定的开销显示物体。

#### 12.5 精灵图片和图层

基于图像的渲染中最简单的一种方式是使用精灵图片。精灵图片是指一张可以在屏幕中移动的图像，比如鼠标的图像。精灵图片不一定非要是矩形，因为某些像素可以是透明的。对于简单的精灵图片，直接将其中的像素拷贝到屏幕上显示。动画则可以通过连续显示不同的精灵图片实现。

一种更通用的精灵图片类型是将图像渲染在一个始终面向相机的多边形上。这就允许了对精灵图片的大小调整和变形。这类精灵图片也可以拥有一个深度值，这样它们就有了一个在场景中的具体位置。

可以将场景想象成一系列的图层，通常可以当作二维的赛璐璐动画。每个精灵图片都有其相应的层级，渲染时则按照从后向前的画家算法渲染，完全不需要深度缓冲。相机的变焦只是改变了物体的大小，这可以很容易地通过缩放或多级纹理实现。

可以用一组精灵图片表示一个物体，不同的精灵图片表示不同的视角。如果物体在屏幕上的占比不大，那么存储各个视角方向的物体图像，甚至包括其动画图像，也是可行的策略。

#### 12.6 广告牌

将一个有纹理的矩形对准视角方向的技术被称为广告牌。当视角改变时，广告牌的朝向也会相应改变。广告牌技术结合透明纹理、动画等技术，可以制作出丰富的效果，例如草地、烟雾、火焰、爆炸、能量护罩、水汽、云层等。

矩形的表面法线和上方向用于表示广告牌的朝向，这两个向量足以构建表面的正交基。通常情况下，面法线和上方向并不垂直，但会固定其中的一个方向，那么就可以很容易地建立正交基底。

**对齐屏幕的广告牌**

最简单的一种广告牌类型就是对齐屏幕的广告牌。这类广告牌就和二维精灵图片一样，图像始终平行于屏幕，有一个固定的上方向。由于该类广告牌的面法线和上方向是固定的，因此旋转矩阵也是固定的。需要注意，这类广告牌的大小是依赖于视角位置的，这可能会使裁剪变得复杂。

**世界朝向的广告牌**

有时我们也希望有一类切实存在的广告牌物体，它们仍然是面向相机的，但是绕自身的轴旋转。广告牌的面法线仍然是对视平面的法线取反，但上方向则需要采用世界的上方向。

使用一些边缘的凸包技术可以大幅减少需要处理的纹理数量，整体上可以降低$40\%\sim48\%$的处理面积。

烟雾的广告牌常常会在与物体相交的部分产生瑕疵。一种解决方案是，做深度测试但不写入深度，当物体和广告牌足够接近时，就将广告牌的片元变得更透明一些。粒子的消散范围随着到相机的距离变化而调整的粒子，被称为软粒子（soft particles）。在相机穿越软粒子的时候可能会出现粒子突然被近平面裁剪掉的情况，可以通过使粒子接近相机时变得透明来修复该问题。

**轴向广告牌**

轴向广告牌不直接朝向相机，而是沿着世界空间的轴旋转，尽可能朝向相机。这类广告牌可用于远距离的树木。

**顶替物（impostors）**

顶替物是指将从当前视角渲染复杂物体的图像作为纹理的广告牌。在渲染出顶替物图片之前，需要先将视角中心设置到物体的包围盒中心。顶替物的四边形也应当是包围盒投影的最小包围矩形。除了被渲染的物体外，其他部分的 alpha 值都为 0。但由于顶替物通常没有厚度，有时会穿帮。

**广告牌的表示方式**

顶替物的一个问题是，渲染出的图像必须朝向相机。如果远距离的物体改变了它的朝向，那么就需要重新计算顶替物。Decoret 等人提出了广告牌云，像法线、置换贴图和材质等信息都可用于表面。

#### 12.7 置换技术

如果顶替物的纹理中包含深度信息，那么这就是一个深度精灵图片，或称为钉板（_nailboard_）。因此，纹理图像就是一个带有$\Delta$参数的 RGB 图像，或者表示为$\rm RGB\Delta$纹理，其中的$\Delta$存储的是精灵图片深度到精灵图片所描述的几何体的真正深度的距离。$\Delta$通道是视角空间的高度场。由于含有深度信息，深度精灵图片要优于顶替物，深度精灵图片可以更好地与周围地物体合并，特别是当深度精灵图片穿过周边几何体时。

与深度精灵图片相关地还有一种叫做“浮雕纹理映射”的技术。浮雕纹理是一种使用高度场表示表面位置的图像。与深度精灵图片不同的是，浮雕纹理并不是渲染在广告牌上的。使用 GPU 可以将高度场映射到物体表面，然后通过光线步进来渲染。浮雕纹理映射技术与光栅化多层包围体技术相似。

Policarpo 和 Oliveira 在一个四边形上使用一组纹理来表示高度场，轮流渲染它们。做一个简单的类比，在注塑机中成型的任何物体都可以用两个高度场表示。每个高度场都可以表示一般的模具。更复杂的模型则可以引入额外的高度场参与重建。给定模型的一个视角，所需的最大高度场数量等同于像素上覆盖的最大表面数量。该技术也可用于为物体表面创建复杂的几何细节。

#### 12.8 粒子系统

粒子系统就是一些单独的小物体通过一些算法来运动。它的应用面包括模拟火焰、烟雾、爆炸、水流、旋转星系等现象。控制粒子在生命周期中的产生、运动、变化和消失都是粒子系统的一部分。

粒子可能是一个像素或者一条从上个位置连出的线段，但更多情况下，它们用广告牌表示。每个粒子的广告牌可以通过几何着色器生成，但实际上使用顶点着色器绘制精灵图片会更快。

**粒子着色**

粒子着色需要根据粒子设计。像火星之类的粒子效果通常不需要着色，而是使用叠加混合。Green 描述了应当如何将流体系统当作球体粒子渲染进深度图中，然后做深度模糊，导出法线，将结果与场景融合。小型粒子，比如尘埃、烟雾，可以使用逐片元或者逐顶点值着色，但在光照下会让具有不同表面的粒子看起来都是平坦的。额外提供一张法线贴图可以使它看起来更好，但会增加额外的纹理开销。对于圆形粒子来说，在粒子的四个角落分别使用四个法线可能就足够了。烟雾粒子有一些针对于光线散射效果的复杂模型。辐射度法向映射和球谐函数也常被用于粒子光照。大型粒子可以使用细分，顶点上累积的光照可以通过域着色器计算。

粒子的着色也可以采用顶点光照计算，然后插值着色。这个方法虽然快速，但是对大型粒子的着色质量较差，容易遗漏一些小光源的光照贡献。一种解决方案是在低分辨率上使用逐像素光照计算。为此，需要给每一个可见的粒子分配一个光照贴图纹理上的区域。该区域的大小可以根据粒子在屏幕上的尺寸调整，从$1\times1$到$32\times32$都是可能的。当区域分配好之后，粒子就被渲染到相应的区域上，并将对应像素的世界坐标写入第二张纹理中。之后使用计算着色器计算到达每个坐标的辐射度。辐射度是通过采样场景中的光源后聚集得到的。得到的辐射度可以颜色形式写进光照贴图纹理中，也可以用球谐函数的形式。当每个粒子最终需要渲染到屏幕上时，通过在粒子上映射相应的光照贴图区域来应用光照。

除了光照，粒子的体积阴影的生成以及自阴影需要谨慎处理。对于来自其他物体的遮蔽，小型粒子通常只能在顶点处测试，而不能逐像素地测试。由于粒子是一个个的平面，无法在阴影贴图上使用光线步进，但可以使用溅射方法。为了得到粒子的自阴影，就需要更多的技术手段，比如傅里叶不透明映射（FOM）。但由于只使用了有限的傅里叶基底，可能会产生振铃现象，这会导致粒子的部分区域过亮或者过暗。除了傅里叶不透明映射外，也有其他一些方案可选，比如自适应的体积阴影贴图，或是 GPU 优化的粒子阴影贴图，或是投射函数映射。

另一种着色方法是将粒子区域体素化为含有消光系数$\sigma_t$的体积。该方案可以统一计算粒子和参与介质的体积阴影。

**粒子模拟**

粒子模拟是个很宽泛的话题，本节只提供一些相关资料。GPU 可以生成精灵图片的动画路径并可以计算碰撞。流输出可以控制粒子的产生和消亡。这些都通过将结果存储在顶点缓冲中并每帧更新实现。

#### 12.9 点渲染

1985 年，Levoy 和 Whitted 写了一篇开创性的技术报告，他们介绍了使用点作为渲染的图元。大体思路是使用大量的点来描述物体表面并进行渲染。

在今天的点云渲染系统中，数据集可能非常庞大，由数千亿点组成。如此之多的数据不可能一次性加载进内存中，更不用说按交互速率显示了。从加载到显示都依赖于层级结构。具体的数据结构可以视数据类型而定，例如对于地形来说，四叉树要好于八叉树。

#### 12.10 体素

正如像素是图片的元素，纹素是纹理的元素，体素则是体积的元素。颜色、法线、有向距离或是其他的数值都可以存进体素中以便渲染。位置信息不需要存储，因为体素的索引就包含了位置信息。

**应用**

用体素表示模型可用于不同的目的。规范的网格数据适用于对完整物体的任何操作，而不仅仅是对表面的操作。比如，用体素表示的物体的体积就是其中各体素的体积和。具有规则结构和良好定义的局部邻域体素的网格，意味着可以用元胞自动机或其他算法模拟烟雾、侵蚀、云的形成之类的现象。有限元分析利用体素来定义物体的抗拉强度。雕刻模型变成了对模型体素的削减。相反，可以通过将多边形模型放置到体素网格中并决定覆盖哪些体素来构建复杂模型。这类构建实体几何的建模操作高效、可预测、有用，而传统的多边形建模工作流则必须解决孤点和精度问题。基于体素的系统，例如 OpenVDB 和 NVIDIA GVDB Voxels 被用于电影制作、科学与医学可视化、3D 打印等应用领域。

**体素存储**

体素存储的内存需求巨大，因为数据的增长速度是$O(n^3)$的。

存储在体素网格中的数据通常是高度相关的，相邻的位置上很可能具有相似的数值。根据数据来源不同，大量网格可能都是空值，这种就是稀疏体积。网格的局部相关性和整体的稀疏性都导向紧密表示。八叉树结构就可被用于网格存储上。最底层的八叉树层级上，$2\times2\times2$的体素样本集可能是完全相同的，这就可以用八叉树存储而丢弃掉原本的体素。该过程可以沿着八叉树向上进行，相同的八叉树节点向上合并，子节点被丢弃。只有数据不同的节点被存储下来。这类稀疏体素八叉树（SVO）天然地具备多级细节表示。

**生成体素**

产生体素模型的数据有很多来源。对于网格模型，一种快速但粗糙的方法是由 Krabassi 等人提出的，从六个正交视图渲染物体，从每个视图中生成深度缓冲，这样就得到了各个视图上看到的第一个体素。如果体素超出了全部六个深度缓冲，则该体素不可见，应当位于物体内部。这种方法会遗漏一些从六个视图中都看不到的细节，被错误地标注为处于物体内部。

受可见性壳体的启发，Loop 等人使用一种甚至更简单的系统创建现实中人体的体素化模型：将一组照片中的人的轮廓提取出来，将轮廓以外的体素全部剔除掉。

体素网格也可以从一组图片中创建。比如医用成像设备会产生切片图像，堆叠起来就成了体素模型。

使用现代 GPU 的新功能可以更加高效地完成体素化。Schwarz、Seidel 和 Pantaleoni 提出了一种使用计算着色器实现体素化的系统，可以直接构建 SVO。

**渲染体素**

体素数据存储在一个三维数组中，可以当作（事实上也确实如此）三维纹理处理。

先考虑最简单的情形，体素中只包含一个 bit 来标记它是位于物体内部还是外部。有很多种方法展示这种类型的数据，其中一种便是直接用光线投射寻找最近的表面；另一种方案是将体素转变为一组多边形。

用立方体来渲染体素并不能令人信服，另一种常用的着色方案是通过诸如步进立方体的方案来生成光滑网格，这类方法被称为“表面提取”或者“多边形化”。

近几年的研究趋势不再局限于八叉树。八叉树的一个重要缺陷是，像光线追踪这样的操作需要对八叉树进行大量的遍历。Hoetzlein 展示了在 GPU 上光线追踪 VDB 树（一种层级网格结构）可以达到比八叉树高很多的效率，而且也很适合动态改变体积数据。

### 13. 体渲染和半透明渲染

#### 13.1 光线散射理论

本节讨论单次散射模型。单次散射只考虑光线在介质中的粒子上进行一次弹射。

**参与介质材质**

介质中的辐射度传播有四种不同的现象：

- 吸收（吸收率$\sigma_a$）：光子被介质中的物质吸收并转化为热或其他形式的能量
- 外散射（散射率$\sigma_s$）：光子在介质中从粒子上散射出去
- 发光：当介质达到一定热量时可能会发出光线，例如火焰的黑体辐射
- 内散射（散射率$\sigma_s$）：来自于各个方向的光子可能散射往当前光路的方向，内散射到某个方向的光线数量依赖于光线方向的相函数

总结一下，给定光路上的增加的光子等同于内散射加发光；消失的光子等同于外散射加吸收。根据辐射度传播方程，在位置$\textbf{x}$上向着$\textbf{v}$方向的辐射度表示为$L(\textbf{x},\textbf{v})$。光子的散射和吸收共同决定了介质的反照率：

$\rho=\frac{\sigma_s}{\sigma_s+\sigma_a}=\frac{\sigma_s}{\sigma_t}$

其中，$\sigma_t$表示消光系数。

考虑了参与介质对光路中光线的影响后，光线传输方程就需要修正为：

$L_i(\textbf{c},-\textbf{v})=T_r(\textbf{c},\textbf{p})L_o(\textbf{p},\textbf{v})+\int_{t=0}^{\|{\textbf{p}-\textbf{c}}\|}T_r(\textbf{c},\textbf{c}-\textbf{v}t)L_{scat}(\textbf{c}-\textbf{v}t,\textbf{v})\sigma_sdt$

其中，$T_r(\textbf{c},\textbf{x})$是从给定位置$\textbf{x}$到相机位置$\textbf{c}$之间的透射率，$L_{scat}(\textbf{x},\textbf{v})$是沿着视线方向在位置$\textbf{x}$上的散射光线。

**透射率**

透射率$T_r$表示光线在介质中前进一段距离的比例。具体定义为：

$T_r(\textbf{x}_a,\textbf{x}_b)=e^{-\tau},\qquad where\quad \tau=\int_{\textbf{x}=\textbf{x}_a}^{\textbf{x}_b}\sigma_t(\textbf{x})\|{d\textbf{x}}\|$

该关系式常被称为 Beer-Lambert 法则。光学深度$\tau$是一个无单位量，表示光线的衰减程度。消光系数越高、光程越长，光学深度就越大。光学深度$\tau=1$大约会消除掉约$60\%$的光线。

**散射现象**

对点光源的内散射积分可以表示为：

$L_{scat}(\textbf{x},\textbf{v})=\pi\overset{n}{\underset{i=1}{\sum}}p(\textbf{v},\textbf{l}_{c_i})v(\textbf{x},\textbf{p}_{light_i})c_{light_i}(\|{\textbf{x}-\textbf{p}_{light_i}}\|)$

其中，$n$表示光源的数量，$p()$是相函数，$v()$是可见性函数，$\textbf{l}_{c_i}$是指向第$i$个光源的方向，$\textbf{p}_{light_i}$是第$i$个光源的位置，$c_{light_i}()$是来自第$i$个光源的辐射度。可见性函数表示了光线到达某位置的比例，可以表示为：

$v(\textbf{x},\textbf{p}_{light_i})=\rm shadowMap(\textbf{x},\textbf{p}_{light_i})\cdot volShad(\textbf{x},\textbf{p}_{light_i})$

其中，$\rm volShad(\textbf{x},\textbf{p}_{light_i})=T_r(\textbf{x},\textbf{p}_{light_i})$。在实时渲染中，阴影来自于两方面的遮挡：不透明物体和体积。不透明物体的阴影通常使用阴影贴图计算。上式中的$\rm volShad(\textbf{x},\textbf{p}_{light_i}))$表示从光源到采样点的透射率，范围在$[0,1]$。而来自于体积的遮挡则是体渲染的重要部分，因为体积可以对自身和场景投射阴影。这类问题通常使用光线步进解决。“光线步进”是指对两点之间的路径进行$n$次采样，沿着该路径上的采样点积分光线的散射和透射。但由于光线步进的复杂度是$O(n^2)$的，这就使得该算法计算开销过大。

**相函数**

参与介质是由半径不同的粒子组成的。粒子的尺寸分布会影响光线在特定方向上的散射概率。从宏观层面上描述散射方向的概率分布就是使用相函数。最简单的相函数是各向同性的，光线会被均匀地散射往各个方向：

$p(\theta)=\frac{1}{4\pi}$

其中，$\theta$表示入射光线和外散射方向之间的夹角，$4\pi$是整个单位球面的面积。

基于物理的相函数则依赖于粒子的相对尺寸$s_p$：

$s_p=\frac{2\pi r}{\lambda}$

其中，$r$是粒子的半径，$\lambda$是波长：

- 当$s_p\ll 1$时，发生瑞利散射（空气）
- 当$s_p\approx 1$时，发生米氏散射
- 当$s_p\gg 1$时，发生几何散射

**瑞利散射（Rayleigh Scattering）**

瑞利爵士推导出了空气分子的光线散射项，其相函数包含两部分 lobe，被称为后向散射和前向散射。该相函数表示为：

$p(\theta)=\frac{3}{16\pi}(1+cos^2\theta)$

瑞利散射是高度波长相关的，其散射系数和波长的关系满足：

$\sigma_s(\lambda)\propto\frac{1}{\lambda^4}$

上式意味着，波长较短的可见光散射得更多。对 RGB 使用上式可以得到散射系数$\sigma_s=(0.490,1.017,2.339)$

**米氏散射（Mie Scattering）**

当粒子尺度与波长相仿时，发生米氏散射。该类散射不依赖于波长。对特定尺寸粒子的米氏散射的相函数是一个比较复杂的分布，它具有明显的方向性 lobe，也就是有散射方向的倾向性。计算米氏散射的相函数通常是开销巨大的，但很少会遇到需要计算相函数的情况。通常，介质中的粒子尺寸都是连续分布的，对不同尺寸粒子的相函数取平均可以得到介质中整体平滑的相函数，因此，使用相对平滑的相函数就可以表示米氏散射。

常用的一种相函数是 Henyey-Greenstein 相函数（HG 相函数），最初是在模拟星际尘埃的光线散射时提出的。该函数并不能完整描述现实世界中的散射现象，但是很符合其中一类相函数，也就是沿着主散射方向的相函数。HG 相函数可用于表示烟、雾、尘埃等介质，这类介质显示出强烈的后向或前向散射，使光源周围显示出较大的可见光环。这类现象的例子包括雾气中的聚光灯、云层边缘的强烈银线效应等。

HG 相函数可用于表示比瑞利散射更复杂的现象，其表达式为：

$p_{hg}(\theta,g)=\frac{1-g^2}{4\pi(1+g^2-2gcos\theta)^{1.5}}$

根据参数$g\ (g\in[-1,1])$的不同，上式可以表达多种形状的相函数，例如后向散射（$g<0$），各向同性（$g=0$），前向散射（$g>0$）。

一种快速近似 HG 相函数的方法是使用 Blasi 等人提出的近似公式，一般称为 Schlick 相函数：

$p(\theta,k)=\frac{1-k^2}{4\pi(1+kcos\theta)^2},\quad k\approx1.55g-0.55g^3$

上式不包含复杂的幂运算，只有一个平方运算。为了和 HG 相函数对应，需要引入一个参数$k$来替代参数$g$。

也可以通过混合多个 HG 相函数或 Schlick 相函数来表示复杂的相函数。这就允许我们表示出同时具备强烈的前向和后向散射的 lobe，比如云的散射效果。

**几何散射（Geometric Scattering）**

当粒子尺度远大于波长时发生几何散射。这种情况下，光线可能在粒子上发生反射和折射，宏观上的模拟就需要一个复杂的相函数。光的偏振效应也会影响这类散射，例如彩虹现象，它是由光线在空气中的水分子之间来回反射引起的。

#### 13.2 专用体渲染

**大尺度雾效**

雾效可以用基于深度的效果来模拟。最基础的一种方法是使用雾气颜色和屏幕做透明混合，混合权重根据相机深度调节，这类雾效被称为深度雾（_depth fog_）。这类效果提供了一种视觉上的信息线索。首先，它可以提升真实感和画面效果；其次，它提供了深度信息；最后，它可以被用作遮蔽剔除，即当物体距离足够远可以被雾完全覆盖，就可以将它们安全地裁剪掉，提升性能。

一种表示雾效程度的方式是使用$[0,1]$范围内的数值$f$表示透射率，即当$f=0.1$时，可以看到背景中$10\%$的表面。假设输入颜色为$\textbf{c}_i$，雾的颜色为$\textbf{c}_f$，则最终颜色$\textbf{c}$可以表示为：

$\textbf{c}=f\textbf{c}_i+(1-f)\textbf{c}_f$

$f$值可以通过多种途径计算，它可以基于相机深度线性增加：

$f=\frac{z_{end}-z_s}{z_{end}-z_{start}}$

其中，$z_{start},z_{end}$是用户定义的雾效的起始深度和完全深度，$z_s$则是从相机到物体表面的线性深度。物理正确的计算雾效透射方法是使其按距离指数增加，这样才符合 Beer-Lambert 法则。这种非线性雾效可以这样计算：

$f=e^{-d_fz_s}$

其中，标量$d_f$是控制雾效浓度的用户参数。这类传统的大尺度雾效方法是一类粗糙的光线散射和吸收的近似模拟，但直到今天也广泛运用于游戏中。

以上是过去的 OpenGL 和 DirecX 上实现的硬件雾效。这类方案在今天的移动设备上仍然很有价值。当下的许多游戏可能会采用更先进的屏幕后处理来制作雾效之类的大气散射效果。透视视野下计算雾效的一个问题是，深度缓冲值是非线性的。当然，这种非线性值可以通过求投影矩阵的逆矩阵转换回线性深度。之后就可以通过一个全屏 pass 制作更加进阶的雾效，比如高度相关的雾效、水下效果等。

其他的许多使用深度和高度的雾效变体都是可能的。雾效颜色$\textbf{c}_f$可以是一个单一的颜色，也可以是从立方体贴图中采样的颜色，甚至可以是从复杂的大气散射中根据逐像素的相函数计算得到的颜色。也可以结合深度$f_d$和高度$f_h$来计算雾效的透射率$f=f_df_h$。

深度和高度雾效都是宏观尺度的雾效。有可能需要渲染一些更具有局部性的雾效，比如单独的雾效区域，例如洞穴中或是几个坟头附近。可以使用椭球体或者立方体作为局部雾效的形状，在像素着色器中计算出视线方向和雾效形状的最近最远深度。体积中的深度可以表示为$d=max(0,min(z_s,d_b)-d_f)$，$z_s$表示最近的不透明表面的线性深度，这样就可以计算出透射率$T_r$，进而得到透明度$\alpha=1.0-T_r$，散射的颜色就是$\alpha\textbf{c}_f$。

水体是一种基于深度颜色衰减的参与介质。近海的透射率典型值为$(0.3,0.73,0.63)$每米。

**简单体积光**

参与介质中的光线散射可能很难计算。但在很多情形下，可以用一些高效方法近似计算。

计算体积效果的一种最简单的方法是渲染出和帧缓冲混合的透明网格模型。我们称这种方法为溅射方法。为了让光簇透过窗户或者森林照射出来，或是从聚光灯照射出来，一种方案是使用相机对齐的粒子，每一张粒子纹理沿着光簇的方向拉伸。溅射方法的一个缺陷是累积大量透明网格模型会增加对内存带宽的需求，容易引发性能瓶颈。为了解决该问题，在后处理中使用封闭形式的解来计算光线散射。假设光线散射是使用齐次的球形均匀相函数，那么散射光线的积分就可以沿着光线路径计算。

Dobash 等人提出了一种使用一组平面采样体积来渲染宏观尺度大气效果的方法。这些平面都和视线方向垂直，从后向前渲染。Mitchell 也提出了相同的方法来渲染聚光灯，使用阴影贴图来投射不透明物体的体积阴影。

Mitchell，Rohleder 和 Jamrozik 提出了一种可选的屏幕空间方法。该方法可以渲染远距离光源的体积光效果（如太阳光）。该方法首先在光源附近渲染一个明亮的物体，将其渲染到一张纯黑的帧缓冲中，然后根据深度测试找到未被遮挡的像素；接着，对图像使用一个方向性的模糊效果来模拟辐射度从光源溢出的效果；最后，将模糊后的图像叠加到屏幕缓冲中。

#### 13.3 通用体渲染

本节讨论更加基于物理的体渲染技术，也就是用介质的材质和光照交互来表述体渲染。通用体渲染一般和空间变化的参与介质相关，通常采用体素表示。通用体渲染方法必须考虑到由各种场景要素构成的体积。

**体积数据可视化**

*Volume data visualization*是一种用于显示和分析体积数据的工具，通常用于标量数据。CT 扫描和核磁共振技术都被用于生成人体内部结构的临床诊断图像。一个典型的数据集中可能包含$256^3$个体素，每个位置上都包含一个或多个数值。这些体素数据可用于构建三维图像。体素渲染可用于展示实体模型，或是分开显示不同的材质（皮肤或骨骼）。通过裁剪平面还可以展示不同分块的体积。

体素渲染技术有很多种，可以使用常规的路径追踪算法或是光子映射算法。也有一些开销较低的算法可用于实时渲染中。

对于实体模型来说，一些隐式表面技术可以将体素模型转为多边形表面模型。

**参与介质的渲染**

使用参与介质的渲染，实时应用可以绘制出更丰富的场景。这类效果因为许多因素变得愈发需求旺盛，例如时间、天气和环境的变化，建筑物被破坏等。穿过树林的光簇应当随着太阳的变化而改变方向和颜色，也应当随着树木的移动而变化。比如通过爆炸移除一些树木，则光线的散射会因为遮蔽和尘埃而发生变化。烟花、闪光弹以及其他光源也会产生散射。本节讨论可用于实时模拟这类动态视觉效果的方案。

有一些技术是用于渲染单一光源的大尺度散射阴影的。其中一种方法由 Yusov 提出，它是一种基于沿对极线采样内散射的方法，对极线是投射到相机图像平面上成一行的光线。从光源视角的深度图被用于确定样本是否为阴影。该算法从相机处开始执行光线步进，沿着光线的最小/最大层级被用于跳过一些空白空间，只有深度不连续时进行光线步进，也就是当需要精确计算体积阴影的地方。除了沿着对极线采样不连续深度外，也可以通过在相机空间渲染出由光源空间深度贴图生成的网格模型。在相机空间中，只有在前后面之间的体积需要计算出最终的散射辐射度。为此，通过将正面的散射辐射度增加到相机上，再减去背面的散射辐射度，就可以计算出内散射。

上述两种方法都可以有效地计算单一光源散射的不透明物体阴影。但是，这两种方法都不能表示成分复杂的参与介质，因为它们都假定了参与介质是同质的。更进一步，这类技术未曾考虑透明表面的体积阴影，例如参与介质的自阴影、粒子的透明阴影。但这类方法仍然用在游戏中，它们运算快速且效果很好。

溅射方法被用于解决更一般的情形，即介质混杂的情形。不考虑入射光线，Crane 等人使用溅射方法渲染烟雾、火焰和水体，都采用流体模拟的方式。对于烟雾和火焰，从每个像素生成一根光线执行穿透体积的光线步进，聚集其中的颜色和遮蔽信息。对于水体，当光线第一次到达水体表面时终止体积采样，表面法线则根据每个样本位置的密度场梯度计算。为了确保具有光滑的水面，需要对密度值使用三立方插值。

上述方案有一个共通的问题，按照深度顺序的体积元素溅射无法对透明表面执行正确的顺序，例如大型的非凸透明网格模型或者大尺度的粒子效果都无法按照正确顺序计算。这个问题可以通过完全体素化辐射度传播解决，影视行业就是这样做的。

Wronski 提出一种方法，场景中由光源发出的散射辐射度体素化为映射到视角裁剪空间的三维体积纹理$V_0$。计算每一个体素中心的世界坐标位置的散射辐射度，那么它的 x，y 坐标是和屏幕坐标对应的，而 z 坐标则可以映射到视锥体的深度上。这张体积纹理的分辨率比最终成像的分辨率要低得多。典型实现中会采用屏幕 x,y 轴的$1/8$，深度上的分片可以根据性能需求调整，一般采用 64 个分片。该纹理中包含用 RGB 表示的内散射辐射度$L_{scat_{in}}$以及用 A 表示的消光系数$\sigma_t$。通过这些数据，就可以由近及远地迭代计算出散射体积$V_f$：

$V_f[x,y,z]=(L'_{scat}+T'_rL_{scat_{in}}d_s,T_{r_{slice}}T'_r)$

其中，$L'_{scat}=V_0[x,y,z-1]_{rgb},T'_r=V_0[x,y,z-1]_a,T_{r_{slice}}=e^{-\sigma_td_s}$。这意味着分片$z$的信息是从之前深度的分片$z-1$推出的。注意到式中的内散射$L_{scat_{in}}$只受前一深度透射率$T'_r$的影响，这是不正确的，应当也受到当前分片的消光系数的透射率影响。该问题是由 Hillaire 发现的，他给出了解析法积分$L_{scat_{in}}$的方法：

$V_f[x,y,z]=(L'_{scat}+\frac{L_{scat_{in}}-L_{scat_{in}}T_{r_{slice}}}{\sigma_t},T_{r_{slice}}T'_r)$

最终，不透明物体表面的辐射度$L_s$传播到像素上的辐射度$L_o$变为$L_o=T_rL_s+L_{scat}$。

Hillaire 提出了基于物理的方法定义参与介质材质：散射系数$\sigma_s$，吸收率$\sigma_a$，相函数参数$g$以及自发辐射度$L_e$。材质被映射到相机的视锥体中，并存储在参与介质的体积纹理$V_{pm}$中，类似于三维版本的 G-buffer。只考虑单一散射和离散体素的情况下，该方法接近路径追踪的结果。

基于视锥体分块方法的唯一缺陷是，需要降低分块的分辨率的来满足性能需求。但这是溅射方法所擅长的，它可以生成清晰的视觉细节。如前所述，溅射方法需要更多的内存带宽并提供统一方法，例如它无法妥善处理透明表面，也无法处理可以产生自阴影的参与介质。

除了直接光照外，间接光照也可以穿过介质。虚幻引擎中通过烘焙体积光照贴图实现，它将辐照度存储在体积中，当视体积进行体素化时，将辐照度散射回介质中。为了在参与介质中得到动态全局光照，也可以使用上光照传播体（LPV）。

体积渲染的一个重要特性是使用体积阴影。如果没有体积阴影，则浓雾场景的最终图像就会看上去太亮太平。更进一步，阴影本身也是一种重要的视觉线索，可以帮助观察者感知场景的深度和体积。Hillaire 提出了一种产生体积阴影的统一方法。参与介质体积和粒子都被体素化为相机周围的三个级联体积，称它们为消光体积（_extinction volumes_），它们含有消光系数$\sigma_t$可用于计算$T_r$，并作为统一数据源来作为不透明阴影贴图的采样结果，渲染体积阴影。该方法可以粒子和参与介质产生自阴影并相互之间投射阴影。

体积阴影可以使用不透明阴影贴图表示。但是，高分辨率下使用体积纹理很快就会受到限制。因此，就需要一些其他的表示方案来存储$T_r$等系数，该类方法包括各类正交基底，如傅里叶、离散余弦变换。

#### 13.4 天空渲染

渲染一个世界场景一般都需要有天空、云体等大气效果。蓝天是地球上太阳光对大气中参与介质的大气散射结果。由于大气效果和太阳光方向相关，所以也提供了时间感知上的线索。

**天空和空气透视**

为了渲染大气效果，我们首先需要考虑两个主要部分。首先是模拟太阳光和空气粒子之间的相互作用，也就是产生波长相关的瑞利散射。瑞利散射提供了天空的颜色并产生薄薄的雾效，被称为空气透视。然后是近地面的大粒子和太阳光之间的相互作用。这类大粒子的产生和聚集依赖于天气情况和污染程度。大粒子通常会引发波长不相关的米氏散射。

解析的天空模型可以快速计算，但是仅限于地面视角，大气参数不能改变，因而无法模拟外星大气效果或是给天空增加艺术效果。

另一种渲染天空的方法是假定了地球是一个由匀质参与介质组成的大气包裹的完美球体。基于此，就可以预计算出大气透射率积分值的查找表。该方法在 EA 的寒霜引擎游戏中用得很多。

**云体**

天空中的云体是比较复杂的元素。天空中的云可能暗示着暴风雨或其他的天气现象。云随时间的变化很缓慢，但无论是宏观形状还是细节，都会随着时间发生变化。具有时间和天气系统的大型开发世界往往比较复杂，需要一套动态云体渲染的解决方案。根据性能和视觉效果需求，有多种不同的技术可以使用。

云是由小水滴组成的，具有高散射系数和复杂的相函数，通常使用参与介质模拟，一般认为它的材质具有较高的单次散射反照率$\rho=1$，且消光系数大约在$[0.04,0.06]$（低层水平云，层云）或是$[0.05,0.12]$（低层絮状云，积云）。

渲染云层的经典方法是使用一张天空的全景纹理来做透明混合，该方法主要用在静态天空中。

---

_粒子云_

Harris 使用粒子体积和顶替物体积渲染云体。除此以外，Yusov 也提出了另一种粒子云渲染方式。他使用被称为体积粒子的图元进行渲染，其中的每一个体积粒子都使用四维查找表表示，可以通过太阳光和实现方向从 LUT 中获取散射光照和透射率。该方法很适合渲染层积云。

当使用粒子云渲染时，经常会出现游离的小瑕疵，特别是当围绕云体旋转时很容易观察到。该问题可以通过体积感知混合解决。

---

_参与介质云_

将云体当作各向同性的元素，Bouthors 等人使用两个部分表示云体：网格模型（用于描述宏观形状）、超级纹理（hypertexture, 增加高频细节）。使用这种表述方式，就可以沿着云层的边缘做细粒度的光线步进来聚集细节信息。在光线步进的过程中也会计算的辐射度的积分，可以使用不同的算法计算散射辐射度，单次散射可以按解析方式积分，多次散射通常使用离线预计算传输查找表。

除了将云处理成各向同性的元素，也可以将它们视作大气中的一层参与介质建模。基于光线步进，Schneider 和 Vos 提出了一种渲染云体的高效方法。只需要使用很少的几个参数，就可以渲染出复杂、动态、充满细节的云体。这一层参与介质使用两个不同级别的程序化噪声合成。第一个噪声级别提供了云体基本的形状；第二个级别则负责添加细节。

云体的体积阴影可以通过计算一些样本的透射率获得。也可以通过采样噪声纹理的低级别纹理来进行阴影采样，以获得更高的性能和更平滑的结果。避免二次光线步进计算阴影的方法是存在的，可以将透射率曲线编码进纹理中，例如《最终幻想 15》就使用了透射率函数映射。

高分辨率下执行光线步进可能会非常消耗性能。为了获得更好的性能，可以在低分辨率下渲染云体。一种方法是只对$4\times4$像素中的一个进行更新，而其他的部分则复用之前帧的信息。

云体的相函数也是复杂的。这里提供两种可用于实时渲染的方法。可以将相函数编码进纹理中，并按$\theta$值采样。但这么处理需要占用很大的内存和带宽。也可以使用两个 Henyey-Greenstein 相函数来近似：

$p_{dual}(\theta,g_0,g_1,w)=p_{dual_0}+w(p_{dual_1}-p_{dual_0})$

其中，两个主要的散射偏心度$g_0,g_1$以及混合系数$w$，都可以人为调整。

近似云体所散射的环境光也有一些方法。最直接的方法就是将单一的辐射度输入渲染进立方体贴图中，表示天空的均匀辐射度积分。

---

_多次散射的近似_

云体看上去光亮洁白，是由于光线在其中的多次散射。如果没有多次散射，则较厚的云层只有边缘部分才会透光，其他区域都会很暗。多次散射使得云体不显得浑浊，但使用路径追踪计算多次散射开销很大。一种近似方法是使用 Wrenninge 提出的光线步进方法：

$L_{multiscat}(\textbf{x},\textbf{v})=\overset{o-1}{\underset{n=0}{\sum}}L_{scat}(\textbf{x},\textbf{v})$

其中，当计算$L_{scat}$时，进行以下替换（例如使用$\sigma'_s$替换$\sigma_s$）：$\sigma'_s=\sigma_sa^n,\sigma'_e=\sigma_eb^n,p'(\theta)=p(\theta c^n)$，其中$a,b,c$是范围在$[0,1]$的用户控制参数，可以控制光线穿透参与介质的程度。当参数接近 0 时，云层看上去更加柔和。为了保证能量守恒，计算$L_{multiscat}(\textbf{x},\textbf{v})$时必须确保$a\leq b$，否则就会有更多的光线被散射而出。该方法的好处在于可以运行时计算光线步进，缺点是无法处理复杂的多次散射。

---

_云体与大气相互作用_

当渲染带有云体的场景时，应当考虑到大气散射之间的相互作用，这样才能确保视觉效果上的一致。由于云体是大尺度的元素，所以应当有大气散射。对云层样本计算大气散射是可行的，但是开销较大。通常采用的方法是根据云体的平均深度和透射率计算大气散射。

如果云层变厚了，比如模拟雨云，那么应当减少下方云层中的太阳光散射量。

总结一下，云体渲染可以通过基于物理的材质表示即光照解决。写实的云体形状和细节可以通过程序化噪声获得。最后，大尺寸的图像中需要考虑云体和天空的相互作用。

#### 13.5 半透明表面

半透明表面一般特指那些具有高吸收率和低散射系数的材质。这类材质常见的有玻璃、水等。

**覆盖和透明度**

透明表面可以被当作表面覆盖了一个薄层，不透明的织物或者纤维结构会遮盖住表面的一部分。对于玻璃等其他材质，我们则希望以半透明的方式计算，也就是让一部分光线可以穿透整个体块。那么，对于第一种覆盖透明来说，可以表述为：

$\textbf{c}_o=\alpha\textbf{c}_s+(1-\alpha)\textbf{c}_b$

而另一种半透明表面则可以描述为：

$\textbf{c}_o=\textbf{c}_s+\textbf{T}_r\textbf{c}_b$

其中，$\textbf{c}_s$包含了物体表面的镜面反射。$\textbf{T}_r$是一个由三个值构成的透明度颜色矢量。为了获得彩色的半透明，可以利用现代图形 API 的双源颜色混合特性来将输出的颜色与缓冲中的颜色混合。Drobot 提出了一种不同的混合操作，可以根据给定表面的反射和透射是否着色来决定。

一般情况下，是可以对覆盖和透明度使用同一个透明混合操作的：

$\textbf{c}_o=\alpha(\textbf{c}_s+\textbf{T}_r\textbf{c}_b)+(1-\alpha)\textbf{c}_b$

当厚度改变时，光线透射率可以根据下式计算：

$\textbf{T}_r=e^{-\mathbf{\sigma}_td}$

其中，$d$是穿透材质体积的距离。物理消光系数$\mathbf{\sigma}_t$表示光线穿过介质时的光线衰减率。为了满足艺术家的需要，Bavoil 将目标颜色$\textbf{t}_c$设置为某个给定距离$d$处的透明颜色。那么消光系数就可以重建为：

$\mathbf{\sigma}_t=\frac{-log(\textbf{t}_c)}{d}$

举个例子，如果目标透明颜色为$\textbf{t}_c=(0.3,0.7,0.1)$且穿透距离为$d=4.0$米，那么可以重建出：

$\mathbf{\sigma}_t=\frac{1}{4}(-log0.3,-log0.7,-log0.1)=(0.3010,0.0892,0.5756)$

需要注意的是，如果透射率为 0，则需要单独处理。一种解决方法是减去一个极小的偏移，比如对$\textbf{T}_r$的每个分量都减去$0.000001$。

对于内部空心的外壳物体，其表面由一个透明薄层构成，那么背景颜色应当按照光路穿越介质的距离$d$的函数被遮挡。因此，沿着法线或切线方向观察，可以看到不同程度的背景色遮挡。Drobot 提出了一种方法，其中的透射率计算方式为：

$\textbf{T}_r=e^{-\mathbf{\sigma}_td},\qquad where\quad d=\frac{t}{max(0.001,\textbf{n}\cdot\textbf{v})}$

对于实心的半透明物体，有很多种方法可以计算出光线穿透介质的实际距离。一种最常用的方法是先渲染出视线离开体块的那个表面。这个表面既可能是水晶球的背面，也可能是水底的海床。存储下该表面的深度信息，然后渲染体块的表面，那么就可以在 shader 中计算出表面和底面之间的距离，这个距离就可以被用作计算透射率。

该方法有效的前提是，需要保证体块是封闭的凸多边形，也就是要求一条穿越体积的光线只能有一个入点和一个出点。对于更复杂的模型，比如水晶雕塑，就需要使用深度剥离计算，按照严格的从后往前的顺序逐一渲染前表面。

当渲染大区域的水体时，可以将场景的深度缓冲直接作为背面海床的深度使用。当渲染透明表面时，还必须考虑菲涅尔现象。大多数透明介质都具有比空气大得多的折射系数。在掠射角时，所有的光线都会从交界面弹回。

**折射**

对于透明物体来说，我们假设了入射光线都是来自于体积之外的一条笔直的光线。当体积的前表面和后表面互相平行，且整体厚度不大的时候，这是一种很合理的假设，比如玻璃板。但对于另外一些透明介质，折射系数就很重要。

根据能量守恒，光线要么反射要么透射，因此透射部分的辐射通量比例是$1-f$，其中$f$是反射的光线量。透射辐射度和入射辐射度的关系可以描述为：

$L_t=(1-F(\theta_i))\frac{sin^2\theta_i}{sin^2\theta_t}L_i$

再根据斯涅尔定律重写形式为：

$L_t=(1-F(\theta_i))\frac{n^2_2}{n^2_1}L_i$

Bec 提出了一种高效计算折射向量的方法：

$\textbf{t}=(w-k)\textbf{N}-n\textbf{l}$

其中，$n$是折射系数，$\textbf{N}$是表面法线，$\textbf{l}$是光线方向，另外有：

$w=n(\textbf{l}\cdot\textbf{N})\\k=\sqrt{1+(w-n)(w+n)}$

由上式计算得到的折射向量$\textbf{t}$是单位化的。水的折射系数约为 1.33，玻璃的折射系数约为 1.5，空气的折射系数约为 1.0。折射系数随波长改变，这意味着透明介质会以不同的偏角弯曲各色光线，这种现象被成为光的色散。光的色散会使相机镜头产生色差问题，在摄影领域被称为紫边。一些 VR 渲染器中会给画面应用一个逆向色差来进行色散矫正。

制作折射效果的一般方法是在折射物体的位置处生成一张立方体环境贴图。当需要渲染这个物体时，就可以通过环境贴图获得折射信息。除了使用环境贴图之外，Sousa 提出了屏幕空间方法。首先，正常渲染屏幕上除了折射物体以外的其他场景内容；接着，将折射物体单独渲染到初始化为 1 的透明通道中。如果某个像素通过了深度测试，则将透明通道的值写为 0。最后，通过对背景中颜色的扰动偏移采样，折射物体就可以被完整地渲染出来。

以上方法虽然可以营造出折射的效果，但是并不符合物理正确。

**焦散和阴影**

计算由折射形成地焦散和阴影是非常复杂的。在非实时环境中，有许多方法可以计算，比如双向路径追踪、光子映射等。幸运的是，也有许多方法可以实时计算，近似这类效果。

为了生成水面的焦散效果，一种方法是应用一张离线计算的焦散动画纹理。

对于水下效果，也可以使用相似的方法。Lanza 提出了一种两步法来生成光斑。首先，将光源位置看到的光线折射方向记录下来；接着可以从水面开始向折射方向延伸，采用叠加混合的方式和后处理模糊得到最终的效果。

Wyman 提出了一种图像空间的焦散渲染方法。首先计算出光子和透明物体的前表面、后表面碰撞的位置及折射方向；接着将记录下来的光子溅射到画面中。

#### 13.6 次表面散射

次表面散射是具有高散射系数固体材料中的一种复杂现象。这类材料包括蜡、人体皮肤、牛奶等。

在一些情况下，散射的尺度很小，散射会从邻近的表面重新射出。这种位置上的变化就意味着次表面散射不能按照 BRDF 建模。

散射会使得入射的光线产生许多不同的光路，即使是离线渲染也无法模拟每个光子的路径。

区分不同光路的一种重要因素是散射事件的数量。有些光路只经过一次弹射便离开物体；有些光路则需要两次、三次乃至更多次。散射光路可以通常分为单次散射和多次散射，对这两种散射通常采用不同的处理方法。有些材料中，多次散射占主导，比如皮肤。对于这类材料，就需要着重模拟多次散射的效果。

**Wrap Lighting**

最简单的次表面散射方法是使用包裹光照（wrap lighting）。该技术曾作为面光源的近似方法提出。当使用近似次表面散射，我们可以额外增加一个颜色偏移。这样就可以考虑到光线穿透材质时被部分吸收。比如渲染皮肤时，就可以增加一个红色偏移。

包裹光照也可以建模多次散射的效果。从相邻点上溢出的光线使得由亮到暗的过渡更加柔和。Kolchin 指出这种效果和表面的曲率相关，并推导出了基于物理的版本。

**法线模糊**

Stam 指出，多次散射可以按漫反射过程建模。Jensen 等人进一步发展了该观点，并推导出了解析的双向表面散射分布函数（BSSRDF）模型。该模型是考虑了全局次表面散射后，更一般的 BRDF 模型。漫反射过程对出射辐射度具有空间模糊效果。

这种模糊效果仅适用于漫反射。镜面反射不受次表面散射的影响。由于法线贴图通常编码了小尺度的变化，一种做次表面散射很有用的 trick 便是对镜面反射使用法线贴图。将平滑的、未扰动的法线用于漫反射。

对于很多材质来说，多次散射只发生在很浅的区域。皮肤是一个重要的例子，大部分的散射发生在几毫米的深度上。对于这类材质，不扰动漫反射法线的技术就足够了。

**预积分的皮肤着色**

结合了包裹光照和法线模糊，Penner 提出了一种预计算的皮肤着色方案。

- 散射和透明度在积分后存储在一张二维查找表中。这张二维查找表的第一个维度是$\textbf{n}\cdot\textbf{l}$，第二个维度是$1/r=\|{\partial n/\partial p}\|$，表示表面曲率。曲率越高，对透明度和散射颜色的影响越大。由于每个三角形中的曲率是相同的，所以这些值需要经过离线烘焙和平滑。

**纹理空间的漫反射**
